Index: 1
File: /Users/cryptskii/client/tsconfig.node.json

{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}

--------------------------------------------------------------------------------

Index: 2
File: /Users/cryptskii/client/index.html

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <link rel="icon" href="./favicon_io/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#000000">
  <link rel="manifest" href="https://overpass-channels-czhd-git-crypskii-brandons-projects-d6012021.vercel.app/tonconnect-manifest.json">
  <meta name="description" content="Web site created using Vite">
  <link rel="apple-touch-icon" href="./logo.png">
  
  <!-- Load tonweb library before ton-access, to ensure dependencies are available in the correct order -->
  <script src="https://cdn.jsdelivr.net/gh/toncenter/tonweb/dist/tonweb.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/orbs-network/ton-access@2.2.0/dist/index.min.js"></script>
  
  <!-- Web App Manifest -->
  <link rel="manifest" href="./manifest.json">
</head>

<body>
  <nav>
    <ul>
      <li><a href="/">Home</a></li>
      <li><a href="/about">About</a></li>
      <li><a href="/services">Services</a></li>
      <li><a href="/contact">Contact</a></li>
      <li><a href="https://overpass-channels-czhd-git-crypskii-brandons-projects-d6012021.vercel.app/terms-of-use.html">Terms of Use</a></li>
      <li><a href="https://overpass-channels-czhd-git-crypskii-brandons-projects-d6012021.vercel.app/privacy-policy.html">Privacy Policy</a></li>
    </ul>
  </nav>
  <noscript>You need to enable JavaScript to run this app.</noscript>
  <div id="root"></div>
  <script type="module" src="./src/main.tsx"></script> <!-- Load the main.tsx file -->    

  <script>
    document.addEventListener("DOMContentLoaded", function () {
      // Check if TonAccess is defined to proceed with initialization
      if (typeof TonAccess !== 'undefined') {
        TonAccess.getHttpEndpoint({ network: 'testnet' }).then(async (endpoint) => { // Get the decentralized RPC endpoint
            console.log('TonAccess endpoint:', endpoint);
            const tonweb = new TonWeb(new TonWeb.HttpProvider(endpoint)); // Initialize tonweb library
            console.log('TonWeb initialized with endpoint');
            const wallet = tonweb.wallet.createRandom(); // Create a new wallet instance
            const address = wallet.address; // Get the wallet address (public key)
            console.log('Wallet address:', address);
            const balance = await tonweb.getBalance(address); // Fetch the wallet balance
            console.log('Wallet balance:', balance);
            const privateKey = wallet.privateKey; // Retrieve the wallet private key (hex)
            console.log('Wallet private key:', privateKey);
            const publicKey = wallet.publicKey; // Retrieve the wallet public key (hex)
            console.log('Wallet public key:', publicKey);
        }).catch((error) => {
          console.error('Failed to get TonAccess endpoint:', error);
        });
      } else {
        console.error('TonAccess is not defined. Please ensure the ton-access script is loaded correctly.');
      }
    });
  </script>

  <script>
    // Implement and enable functionality when DOM is fully loaded
    document.addEventListener('DOMContentLoaded', function() {
      console.log('Functionality implemented and enabled');
      enableFunctionality();
    });

    function enableFunctionality() {
      // Add event listeners for navigation and user interactions
      console.log('Enabling functionality...');
      document.querySelector('nav').addEventListener('click', handleNavigation);
      initializeComponents(); // Initialize additional components on the page
      setupUserInteractions(); // Set up user interactions like button clicks
      console.log('Functionality enabled');
    }

    function handleNavigation(event) {
      if (event.target.tagName === 'A') {
        event.preventDefault(); // Prevent default link behavior
        const href = event.target.getAttribute('href'); // Get href attribute of clicked link
        console.log(`Navigating to: ${href}`);
        // Implement your navigation logic here (e.g., page transition or AJAX loading)
      }
    }

    function initializeComponents() {
      // Example: Initialize a modal component and add it to the DOM
      console.log('Initializing components...');
      const modal = document.createElement('div');
      modal.id = 'modal';
      modal.style.display = 'none'; // Initially hide the modal
      document.body.appendChild(modal);
      console.log('Components initialized');
    }

    function setupUserInteractions() {
      // Example: Set up a button click interaction to log a message
      console.log('Setting up user interactions...');
      const button = document.createElement('button');
      button.textContent = 'Click me';
      button.addEventListener('click', () => {
        console.log('Button clicked');
        // Implement additional button click logic here (e.g., show modal or trigger an action)
      });
      document.body.appendChild(button);
      console.log('User interactions set up');
    }
  </script>

</body>
</html>
--------------------------------------------------------------------------------

Index: 3
File: /Users/cryptskii/client/tailwind.config.js

/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ['class'],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
  ],
  prefix: '',
  theme: {
    container: {
      center: true,
      padding: '2rem',
      screens: {
        '2xl': '1400px',
      },
    },
    extend: {
      colors: {
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        primary: {
          DEFAULT: 'hsl(330, 100%, 50%)', // Hot pink
          foreground: 'hsl(0, 0%, 100%)', // White
        },
        secondary: {
          DEFAULT: 'hsl(195, 100%, 50%)', // Cyan
          foreground: 'hsl(0, 0%, 100%)', // White
        },
        destructive: {
          DEFAULT: 'hsl(350, 100%, 50%)', // Bright red
          foreground: 'hsl(0, 0%, 100%)', // White
        },
        muted: {
          DEFAULT: 'hsl(210, 40%, 96%)', // Light blue-gray
          foreground: 'hsl(215, 16%, 47%)', // Dark blue-gray
        },
        accent: {
          DEFAULT: 'hsl(265, 100%, 60%)', // Bright purple
          foreground: 'hsl(0, 0%, 100%)', // White
        },
        popover: {
          DEFAULT: 'hsl(0, 0%, 100%)', // White
          foreground: 'hsl(215, 16%, 47%)', // Dark blue-gray
        },
        card: {
          DEFAULT: 'hsl(0, 0%, 100%)', // White
          foreground: 'hsl(215, 16%, 47%)', // Dark blue-gray
        },
      },
      borderRadius: {
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)',
      },
      keyframes: {
        'accordion-down': {
          from: { height: '0' },
          to: { height: 'var(--radix-accordion-content-height)' },
        },
        'accordion-up': {
          from: { height: 'var(--radix-accordion-content-height)' },
          to: { height: '0' },
        },
        'neon-glow': {
          '0%, 100%': { 
            textShadow: '0 0 7px #fff, 0 0 10px #fff, 0 0 21px #fff, 0 0 42px #0fa, 0 0 82px #0fa, 0 0 92px #0fa, 0 0 102px #0fa, 0 0 151px #0fa'
          },
          '50%': { 
            textShadow: '0 0 4px #fff, 0 0 7px #fff, 0 0 14px #fff, 0 0 28px #0fa, 0 0 55px #0fa, 0 0 62px #0fa, 0 0 68px #0fa, 0 0 101px #0fa'
          }
        }
      },
      animation: {
        'accordion-down': 'accordion-down 0.2s ease-out',
        'accordion-up': 'accordion-up 0.2s ease-out',
        'neon-glow': 'neon-glow 1.5s ease-in-out infinite alternate'
      },
      fontFamily: {
        'miami': ['Brush Script MT', 'cursive'],
      },
      backgroundImage: {
        'miami-gradient': 'linear-gradient(to right, #ff6b6b, #4ecdc4)',
      },
    },
  },
  plugins: [require('tailwindcss-animate')],
}
--------------------------------------------------------------------------------

Index: 4
File: /Users/cryptskii/client/vercel.json

{
  "buildCommand": "npm run build",
  "outputDirectory": "dist",
  "rewrites": [{ "source": "/(.*)", "destination": "/index.html" }],
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        {
          "key": "Access-Control-Allow-Origin",
          "value": "*"
        },
        {
          "key": "Access-Control-Allow-Methods",
          "value": "GET, POST, PUT, DELETE, OPTIONS"
        },
        {
          "key": "Access-Control-Allow-Headers",
          "value": "X-Requested-With, Content-Type, Accept, Authorization"
        }
      ]
    }
  ]
}

--------------------------------------------------------------------------------

Index: 5
File: /Users/cryptskii/client/tsconfig.app.json

{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

    /* Optimization */
    "removeComments": true,
    "importHelpers": true,
    "noEmitHelpers": true,
    "downlevelIteration": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "**/*.spec.ts"]
}

--------------------------------------------------------------------------------

Index: 6
File: /Users/cryptskii/client/example.ts


--------------------------------------------------------------------------------

Index: 7
File: /Users/cryptskii/client/jest.setup.ts

import '@testing-library/jest-dom';
// Additional setup if required

--------------------------------------------------------------------------------

Index: 8
File: /Users/cryptskii/client/package.json

{
  "type": "module",
  "name": "overpass-client",
  "version": "1.0.0",
  "scripts": {
    "start": "vite --host",
    "build": "vite build",
    "test": "jest",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "format": "prettier --write \"src/**/*.{ts,tsx}\"",
    "typecheck": "tsc --noEmit",
    "prepare": "cd .. && husky install client/.husky",
    "analyze": "vite build --mode analyze",
    "storybook": "storybook dev -p 6006",
    "build-storybook": "storybook build",
    "chromatic": "chromatic --exit-zero-on-changes"
  },
  "dependencies": {
    "@babel/core": "^7.22.10",
    "@emotion/react": "^11.0.0",
    "@emotion/styled": "^11.0.0",
    "@hookstate/core": "^4.0.1",
    "@mui/icons-material": "^5.16.7",
    "@mui/material": "^5.13.6",
    "@mui/system": "^6.1.0",
    "@noble/hashes": "^1.5.0",
    "@orbs-network/ton-access": "^2.3.3",
    "@radix-ui/react-accordion": "^1.2.0",
    "@radix-ui/react-alert-dialog": "^1.1.1",
    "@radix-ui/react-aspect-ratio": "^1.1.0",
    "@radix-ui/react-avatar": "^1.1.0",
    "@radix-ui/react-checkbox": "^1.1.1",
    "@radix-ui/react-context-menu": "^2.2.1",
    "@radix-ui/react-dropdown-menu": "^2.1.1",
    "@radix-ui/react-hover-card": "^1.1.1",
    "@radix-ui/react-icons": "^1.3.0",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-menubar": "^1.1.1",
    "@radix-ui/react-navigation-menu": "^1.2.0",
    "@radix-ui/react-popover": "^1.1.1",
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-radio-group": "^1.2.0",
    "@radix-ui/react-scroll-area": "^1.1.0",
    "@radix-ui/react-select": "^2.1.1",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slider": "^1.2.0",
    "@radix-ui/react-switch": "^1.1.0",
    "@radix-ui/react-tabs": "^1.1.0",
    "@radix-ui/react-toast": "^1.2.1",
    "@radix-ui/react-toggle-group": "^1.1.0",
    "@radix-ui/react-tooltip": "^1.1.2",
    "@tanstack/react-query": "^5.56.2",
    "@ton/core": "^0.57.0",
    "@ton/crypto": "3.3.0",
    "@ton/crypto-primitives": "2.1.0",
    "@ton/ton": "^15.0.0",
    "@tonconnect/sdk": "^3.0.1",
    "@tonconnect/ui-react": "^2.0.9",
    "@types/bn.js": "^5.1.5",
    "@types/lodash": "^4.14.195",
    "@types/recharts": "^1.8.29",
    "@vercel/analytics": "^1.3.1",
    "@vitejs/plugin-react": "^4.3.2",
    "aria-query": "^5.3.0",
    "bn.js": "^5.2.1",
    "buffer": "^6.0.3",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.0.0",
    "cmdk": "^1.0.0",
    "core-js": "^3.38.1",
    "cors": "^2.8.5",
    "crypto-js": "^4.2.0",
    "embla-carousel-react": "^8.1.5",
    "express": "^4.21.0",
    "framer-motion": "^11.3.17",
    "gsap": "^3.12.5",
    "i18next": "^23.15.2",
    "input-otp": "^1.2.4",
    "lodash": "^4.17.21",
    "lucide-react": "^0.397.0",
    "next-seo": "^6.1.0",
    "next-themes": "0.3.0",
    "next-translate": "^2.4.1",
    "next-use-theme": "^1.0.0",
    "react-day-picker": "^9.1.3",
    "react-error-boundary": "^4.0.13",
    "react-hook-form": "^7.52.0",
    "react-i18next": "^15.0.2",
    "react-qr-code": "^2.0.12",
    "react-resizable-panels": "^2.0.19",
    "react-router-dom": "^6.26.2",
    "react-tabs": "^6.0.2",
    "react-use-localstorage": "^3.5.3",
    "reactjs-popup": "^2.0.6",
    "recharts": "^2.12.7",
    "rollup-plugin-polyfill": "^4.2.0",
    "sonner": "^1.5.0",
    "tailwind-merge": "^2.5.2",
    "tailwindcss-animate": "^1.0.7",
    "three": "^0.169.0",
    "tweetnacl": "^1.0.3",
    "vaul": "^1.0.0",
    "vercel": "^37.6.0",
    "vite": "^5.4.8",
    "web-vitals": "^4.2.3",
    "winston": "^3.15.0",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@chromatic-com/storybook": "2.0.2",
    "@hookstate/devtools": "^4.0.1",
    "@storybook/addon-actions": "^8.3.0",
    "@storybook/addon-essentials": "^8.3.4",
    "@storybook/addon-interactions": "^8.3.0",
    "@storybook/addon-links": "^8.3.0",
    "@storybook/addon-onboarding": "^8.3.4",
    "@storybook/blocks": "^8.3.4",
    "@storybook/builder-vite": "^8.3.4",
    "@storybook/react": "^8.3.4",
    "@storybook/react-vite": "^8.3.0",
    "@storybook/test": "^8.3.4",
    "@storybook/vue3": "^8.3.4",
    "@storybook/vue3-vite": "^8.3.4",
    "@testing-library/jest-dom": "^6.5.0",
    "@testing-library/react": "^14.3.1",
    "@testing-library/user-event": "^14.5.1",
    "@ton-community/sandbox": "^0.11.0",
    "@ton-community/test-utils": "^0.0.2",
    "@types/aria-query": "^5.0.4",
    "@types/body-parser": "^1.19.5",
    "@types/connect": "^3.4.38",
    "@types/core-js": "^2.5.8",
    "@types/crypto-js": "^4.2.2",
    "@types/d3-path": "^3.1.0",
    "@types/d3-shape": "^3.1.6",
    "@types/escodegen": "^0.0.10",
    "@types/http-errors": "^2.0.4",
    "@types/jest": "^29.5.12",
    "@types/parse-json": "^4.0.2",
    "@types/prop-types": "^15.7.12",
    "@types/qs": "^6.9.15",
    "@types/react": "^18.3.10",
    "@types/react-dom": "^18.3.0",
    "@types/react-transition-group": "^4.4.11",
    "@types/semver": "^7.5.8",
    "@types/three": "^0.169.0",
    "@types/winston": "^2.4.4",
    "@typescript-eslint/eslint-plugin": "^8.8.0",
    "@typescript-eslint/parser": "^8.8.0",
    "@vitejs/plugin-react-swc": "^3.7.1",
    "autoprefixer": "^10.4.20",
    "babel-loader": "^9.2.1",
    "eslint": "^8.57.1",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-react": "^7.33.2",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-react-refresh": "^0.4.12",
    "eslint-plugin-storybook": "^0.9.0",
    "globals": "^15.9.0",
    "husky": "^9.1.6",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "lint-staged": "^15.2.5",
    "postcss": "^8.4.47",
    "prettier": "^3.2.5",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "rollup-plugin-analyzer": "^4.0.0",
    "rollup-plugin-visualizer": "^5.12.0",
    "storybook": "^8.3.4",
    "tailwindcss": "^3.4.13",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.1",
    "ts-node": "^10.9.2",
    "typescript": "^4.9.5",
    "vite-bundle-analyzer": "^0.10.6",
    "vite-plugin-dts": "^4.2.1",
    "vite-plugin-eslint": "^1.8.1",
    "vite-plugin-top-level-await": "^1.4.4",
    "vite-plugin-wasm": "^3.3.0",
    "vite-tsconfig-paths": "^5.0.1"
  },
  "resolutions": {
    "@types/react": "^18.3.5",
    "@types/react-dom": "^18.3.0"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "lint-staged": {
    "*.{ts,tsx}": [
      "eslint --fix",
      "prettier --write"
    ]
  },
  "types": "node"
}

--------------------------------------------------------------------------------

Index: 9
File: /Users/cryptskii/client/components.json

{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "app/globals.css",
    "baseColor": "stone",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  }
}
--------------------------------------------------------------------------------

Index: 10
File: /Users/cryptskii/client/tsconfig.json

{
  "compilerOptions": {
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "node",
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "allowJs": true,
    "forceConsistentCasingInFileNames": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "incremental": true,
    "types": [
      "node",
      "vite/client"
    ],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@components/*": ["./src/components/*"],
      "@utils/*": ["./src/utils/*"]
    }
  },
  "include": [
    "src",
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules",
    ".next",
    "dist",
    "build"
  ]
}

--------------------------------------------------------------------------------

Index: 11
File: /Users/cryptskii/client/eslint.config.js

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

--------------------------------------------------------------------------------

Index: 12
File: /Users/cryptskii/client/vite.config.ts

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react-swc'
import { resolve } from 'path'
import { visualizer } from 'rollup-plugin-visualizer'
import wasm from 'vite-plugin-wasm'
import topLevelAwait from 'vite-plugin-top-level-await'

const isAnalyze = process.env.ANALYZE === '1'

export default defineConfig({
  plugins: [
    react(),
    wasm(),
    topLevelAwait(),
    isAnalyze && visualizer({
      open: true,
      gzipSize: true,
      brotliSize: true,
    }),
  ].filter(Boolean),
  build: {
    target: 'esnext',
    minify: 'esbuild',
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
        },
      },
    },
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
      '@components': resolve(__dirname, 'src/components'),
      '@utils': resolve(__dirname, 'src/utils'),
      '@wasm': resolve(__dirname, 'src/pkg'),
    },
  },
  optimizeDeps: {
    include: ['react', 'react-dom'],
  },
  esbuild: {
    logOverride: { 'this-is-undefined-in-esm': 'silent' }
  },
});
--------------------------------------------------------------------------------

Index: 13
File: /Users/cryptskii/client/tonconnect-manifest.json

{
  "url": "https://overpass-channels-czhd-git-crypskii-brandons-projects-d6012021.vercel.app",
  "name": "Overpass Channels",
  "iconUrl": "https://overpass-channels-czhd-git-crypskii-brandons-projects-d6012021.vercel.app/logo.png",
  "termsOfUseUrl": "https://overpass-channels-czhd-git-crypskii-brandons-projects-d6012021.vercel.app/terms-of-use.html",
  "privacyPolicyUrl": "https://overpass-channels-czhd-git-crypskii-brandons-projects-d6012021.vercel.app/privacy-policy.html"
}

--------------------------------------------------------------------------------

Index: 14
File: /Users/cryptskii/client/chromatic.config.json

{
  "onlyChanged": true,
  "projectId": "Project:66fa4412c51040890b8828d8",
  "storybookBaseDir": "client",
  "zip": true
}

--------------------------------------------------------------------------------

Index: 15
File: /Users/cryptskii/client/jest.config.ts

module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'jsdom',
  transform: {
    '^.+\\.tsx?$': [
      'ts-jest',
      {
        tsconfig: 'tsconfig.json',
        diagnostics: true
      }
    ]
  },
  setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'], // Setup file
  moduleNameMapper: {
    '\\.(css|less|scss|sass)$': 'identity-obj-proxy'
  },
  silent: true
};

--------------------------------------------------------------------------------

Index: 16
File: /Users/cryptskii/client/app/globals.css

@import 'tailwindcss/base';
@import 'tailwindcss/components';
@import 'tailwindcss/utilities';

@layer base {
  :root {
    --background: 120 100% 10%;
    --foreground: 120 100% 80%;

    --card: 120 100% 15%;
    --card-foreground: 120 100% 80%;

    --popover: 120 100% 15%;
    --popover-foreground: 120 100% 80%;

    --primary: 120 100% 50%;
    --primary-foreground: 120 100% 10%;

    --secondary: 120 100% 20%;
    --secondary-foreground: 120 100% 80%;

    --muted: 120 100% 20%;
    --muted-foreground: 120 100% 60%;

    --accent: 120 100% 30%;
    --accent-foreground: 120 100% 90%;

    --destructive: 0 100% 50%;
    --destructive-foreground: 120 100% 90%;

    --border: 120 100% 30%;
    --input: 120 100% 20%;
    --ring: 120 100% 50%;

    --radius: 0.25rem;
  }

  .dark {
    --background: 120 100% 5%;
    --foreground: 120 100% 90%;

    --card: 120 100% 10%;
    --card-foreground: 120 100% 90%;

    --popover: 120 100% 10%;
    --popover-foreground: 120 100% 90%;

    --primary: 120 100% 60%;
    --primary-foreground: 120 100% 5%;

    --secondary: 120 100% 15%;
    --secondary-foreground: 120 100% 90%;

    --muted: 120 100% 15%;
    --muted-foreground: 120 100% 70%;

    --accent: 120 100% 25%;
    --accent-foreground: 120 100% 95%;

    --destructive: 0 100% 40%;
    --destructive-foreground: 120 100% 95%;

    --border: 120 100% 25%;
    --input: 120 100% 15%;
    --ring: 120 100% 60%;
  }
}

@layer base {
  * {
    border-color: var(--border);
  }
  body {
    background-color: var(--background);
    color: var(--foreground);
    font-family: 'Courier New', monospace;
  }
  @keyframes scanline {
    0% {
      background-position: 0 0;
    }
    100% {
      background-position: 0 100%;
    }
  }
  body::after {
    content: "";
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: linear-gradient(
      to bottom,
      rgba(18, 16, 16, 0) 50%,
      rgba(0, 255, 0, 0.1) 50%
    );
    background-size: 100% 4px;
    pointer-events: none;
    animation: scanline 10s linear infinite;
  }
}
--------------------------------------------------------------------------------

Index: 17
File: /Users/cryptskii/client/www/index.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sparse Merkle Tree Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            text-align: center;
        }
        .input-group {
            margin-bottom: 10px;
        }
        label {
            display: inline-block;
            width: 100px;
        }
        input[type="text"] {
            width: 300px;
        }
        button {
            margin-top: 10px;
        }
        #output {
            margin-top: 20px;
            border: 1px solid #ccc;
            padding: 10px;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <h1>Sparse Merkle Tree Demo</h1>
    <div class="input-group">
        <label for="key">Key:</label>
        <input type="text" id="key" placeholder="32-byte hex string">
    </div>
    <div class="input-group">
        <label for="value">Value:</label>
        <input type="text" id="value" placeholder="32-byte hex string">
    </div>
    <button id="insert">Insert</button>
    <button id="get">Get</button>
    <button id="getRoot">Get Root</button>
    <button id="generateProof">Generate Proof</button>
    <button id="verifyProof">Verify Proof</button>
    <div id="output"></div>
    <script src="./index.js"></script>
</body>
</html>

--------------------------------------------------------------------------------

Index: 18
File: /Users/cryptskii/client/www/index.js

import init, {
    init_panic_hook,
    create_smt,
    insert,
    get,
    get_root,
    generate_proof,
    verify_proof,
  } from "../pkg/sparse_merkle_tree_wasm.js";
  
  let smt;
  
  async function run() {
    await init();
    init_panic_hook();
    smt = create_smt();
  
    document.getElementById("insert").addEventListener("click", handleInsert);
    document.getElementById("get").addEventListener("click", handleGet);
    document.getElementById("getRoot").addEventListener("click", handleGetRoot);
    document.getElementById("generateProof").addEventListener("click", handleGenerateProof);
    document.getElementById("verifyProof").addEventListener("click", handleVerifyProof);
  }
  
  function handleInsert() {
    const key = hexToUint8Array(document.getElementById("key").value);
    const value = hexToUint8Array(document.getElementById("value").value);
    try {
      insert(smt, key, value);
      setOutput("Value inserted successfully");
    } catch (error) {
      setOutput(`Error: ${error}`);
    }
  }
  
  function handleGet() {
    const key = hexToUint8Array(document.getElementById("key").value);
    try {
      const result = get(smt, key);
      setOutput(`Value: ${uint8ArrayToHex(new Uint8Array(result))}`);
    } catch (error) {
      setOutput(`Error: ${error}`);
    }
  }
  
  function handleGetRoot() {
    try {
      const root = get_root(smt);
      setOutput(`Root: ${root}`);
    } catch (error) {
      setOutput(`Error: ${error}`);
    }
  }
  
  function handleGenerateProof() {
    const key = hexToUint8Array(document.getElementById("key").value);
    try {
      const proof = generate_proof(smt, key);
      setOutput(`Proof: ${JSON.stringify(proof)}`);
    } catch (error) {
      setOutput(`Error: ${error}`);
    }
  }
  
  function handleVerifyProof() {
    const key = hexToUint8Array(document.getElementById("key").value);
    const value = hexToUint8Array(document.getElementById("value").value);
    const proofStr = prompt("Enter the proof (JSON array of hex strings):");
    const proof = JSON.parse(proofStr);
    try {
      const isValid = verify_proof(smt, key, value, proof);
      setOutput(`Proof is ${isValid ? "valid" : "invalid"}`);
    } catch (error) {
      setOutput(`Error: ${error}`);
    }
  }
  
  function setOutput(message) {
    document.getElementById("output").textContent = message;
  }
  
  function hexToUint8Array(hex) {
    return new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
  }
  
  function uint8ArrayToHex(uint8Array) {
    return Array.from(uint8Array)
      .map(b => b.toString(16).padStart(2, "0"))
      .join("");
  }
  
  run();
  
--------------------------------------------------------------------------------

Index: 19
File: /Users/cryptskii/client/www/webpack.config.js

const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const webpack = require('webpack');
const WasmPackPlugin = require("@wasm-tool/wasm-pack-plugin");

module.exports = {
    entry: './index.js',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'index.js',
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: 'index.html'
        }),
        new WasmPackPlugin({
            crateDirectory: path.resolve(__dirname, "..")
        }),
        new webpack.ProvidePlugin({
            TextDecoder: ['text-encoding', 'TextDecoder'],
            TextEncoder: ['text-encoding', 'TextEncoder']
        })
    ],
    mode: 'development',
    experiments: {
        asyncWebAssembly: true
   }
};

--------------------------------------------------------------------------------

Index: 20
File: /Users/cryptskii/client/public/privacy-policy.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Privacy Policy</title>
</head>
<body>
    <h1>Privacy Policy</h1>
    <p>This Privacy Policy explains how Overpass Channels collects, uses, and shares your information when you use our application.</p>

    <h2>1. Information We Collect</h2>
    <p>Overpass Channels does not collect any personally identifiable information (PII) such as names, emails, or physical addresses. However, we may collect certain data automatically through the use of decentralized services, such as wallet addresses and transaction data.</p>

    <h2>2. Use of Information</h2>
    <p>The information we collect is used solely to facilitate the functionality of our app, such as processing transactions or interacting with smart contracts. We do not sell or share your information with third parties for marketing purposes.</p>

    <h2>3. Data Security</h2>
    <p>We implement reasonable security measures to protect your information. However, we cannot guarantee the security of data transmitted over the internet, and users are responsible for securing their private keys and wallet credentials.</p>

    <h2>4. Third-Party Services</h2>
    <p>Our app may contain links to third-party services or integrate with decentralized applications. We are not responsible for the privacy practices or content of these third parties.</p>

    <h2>5. Cookies</h2>
    <p>Overpass Channels does not use cookies or other tracking mechanisms. However, third-party services integrated with our app may use cookies, and you are encouraged to review their privacy policies.</p>

    <h2>6. Changes to Privacy Policy</h2>
    <p>We may update this Privacy Policy periodically. Any changes will be posted on this page, and your continued use of the app constitutes acceptance of the updated terms.</p>

    <h2>7. Contact Information</h2>
    <p>If you have any questions about this Privacy Policy, please contact us at support@overpasschannels.com.</p>

    <p>Effective Date: [07/10/2024]</p>
</body>
</html>

--------------------------------------------------------------------------------

Index: 21
File: /Users/cryptskii/client/public/api.ts

// ./src/public/api.ts

import { TonClient } from '@ton/ton';
import { Address, Contract } from '@ton/core';

export class TonConnectBase {
  client: TonClient;

  constructor(client: TonClient) {
    this.client = client;
  }

  async getAccount(address: string) {
    const contract = this.client.provider(Address.parse(address));
    return this.client.open(contract as unknown as Contract);
  }

  async getAccountState(address: string) {
    return this.getAccount(address);
  }

  async getAccountStateWithProof(address: string) {
    return this.getAccount(address);
  }

  async getAccountStateWithProofAndBocCache(address: string) {
    return this.getAccount(address);
  }
}

export class TonConnectWrapper extends TonConnectBase {
  // No need to redefine the methods, as they are inherited from TonConnectBase.
}

export class TonConnect extends TonConnectBase {
  // Inherits everything from TonConnectBase, no need to redefine the methods here.
}       

export class BlockchainApi {
    private client: TonClient;
    constructor(client: TonClient) {
      this.client = client;
    }
  
    async getAccount(address: Address): Promise<any> {
      try {
        const account = await this.fetchAccountFromBlockchain(address);
        return account;
      } catch (error) {
        if (error instanceof Error) {
          throw new Error(`Failed to retrieve account for address ${address}: ${error.message}`);
        } else {
          throw new Error(`Failed to retrieve account for address ${address}: Unknown error`);
        }
      }
    }
  
    async fetchAccountFromBlockchain(address: Address): Promise<any> {
      const contract = { address } as Contract;
      const account = this.client.open(contract);
      if (!account) {
        throw new Error(`Account not found for address ${address}`);
      }
      return account;
    }
  }

export class BlockchainApiWrapper {
    private blockchainApi: BlockchainApi;

    constructor(client: TonClient) {
        this.blockchainApi = new BlockchainApi(client);
    }

    async getAccount(address: Address): Promise<any> {
        try {
            const account = await this.blockchainApi.getAccount(address);
            return account;
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to retrieve account for address ${address}: ${error.message}`);
            } else {
                throw new Error(`Failed to retrieve account for address ${address}: Unknown error`);
            }
        }
    }
}   
--------------------------------------------------------------------------------

Index: 22
File: /Users/cryptskii/client/public/terms-of-use.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terms of Use</title>
</head>
<body>
    <h1>Terms of Use</h1>
    <p>Welcome to Overpass Channels. By accessing or using our services, you agree to comply with and be bound by the following terms and conditions.</p>

    <h2>1. Acceptance of Terms</h2>
    <p>By using the Overpass Channels application, you agree to the terms outlined in this document. If you do not agree to these terms, please refrain from using the app.</p>

    <h2>2. Use of Service</h2>
    <p>Our application allows users to perform operations on smart contracts and access decentralized features. You agree to use the service for lawful purposes only and are responsible for all content and actions that occur under your account.</p>

    <h2>3. User Responsibilities</h2>
    <p>As a user, you are responsible for safeguarding your private keys, wallet addresses, and any other sensitive information. Overpass Channels is not responsible for lost or compromised credentials.</p>

    <h2>4. Intellectual Property</h2>
    <p>All content, features, and functionality on the app are the property of Overpass Channels and are protected by intellectual property laws. You may not reproduce, modify, or distribute any content without permission.</p>

    <h2>5. Disclaimer of Warranties</h2>
    <p>The service is provided "as is" without warranty of any kind. Overpass Channels does not guarantee the service will be error-free, secure, or available at all times.</p>

    <h2>6. Limitation of Liability</h2>
    <p>To the maximum extent permitted by law, Overpass Channels will not be liable for any damages, including, but not limited to, direct, indirect, incidental, or consequential damages arising from your use of the service.</p>

    <h2>7. Modifications to Terms</h2>
    <p>Overpass Channels reserves the right to update or modify these terms at any time without prior notice. Your continued use of the app constitutes acceptance of the new terms.</p>

    <h2>8. Contact Information</h2>
    <p>If you have any questions regarding these Terms of Use, please contact us at support@overpasschannels.com.</p>

    <p>Effective Date: [07/10/2024]</p>
</body>
</html>

--------------------------------------------------------------------------------

Index: 23
File: /Users/cryptskii/client/public/manifest.json

{
  "name": "Overpass Channels",
  "short_name": "Overpass",
  "description": "A decentralized application for Overpass Channels",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#000000",
  "theme_color": "#000000",
  "icons": [
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ],
  "orientation": "portrait",
  "scope": "/",
  "lang": "en-US",
  "dir": "ltr",
  "prefer_related_applications": false,
  "related_applications": [],
  "categories": ["social", "communication"],
  "shortcuts": [
    {
      "name": "Open Channels",
      "short_name": "Channels",
      "description": "View your channels",
      "url": "/channels",
      "icons": [{ "src": "/icons/channels.png", "sizes": "192x192" }]
    },
    {
      "name": "New Message",
      "short_name": "Message",
      "description": "Compose a new message",
      "url": "/compose",
      "icons": [{ "src": "/icons/compose.png", "sizes": "192x192" }]
    }
  ],
  "screenshots": [
    {
      "src": "/screenshots/home.png",
      "sizes": "1280x720",
      "type": "image/png"
    },
    {
      "src": "/screenshots/channels.png",
      "sizes": "1280x720",
      "type": "image/png"
    }
  ],
  "iarc_rating_id": "e84b072d-71b3-4d3e-86ae-31a8ce4e53b7",
  "share_target": {
    "action": "/share-target",
    "method": "POST",
    "enctype": "multipart/form-data",
    "params": {
      "title": "title",
      "text": "text",
      "url": "url",
      "files": [
        {
          "name": "media",
          "accept": ["image/*", "video/*"]
        }
      ]
    }
  }
}

--------------------------------------------------------------------------------

Index: 24
File: /Users/cryptskii/client/public/tonconnect-manifest.json

{
  "url": "https://overpass-channels-czhd-git-crypskii-brandons-projects-d6012021.vercel.app",
  "name": "Overpass Channels",
  "iconUrl": "https://overpass-channels-czhd-git-crypskii-brandons-projects-d6012021.vercel.app/logo.png",
  "termsOfUseUrl": "https://overpass-channels-czhd-git-crypskii-brandons-projects-d6012021.vercel.app/terms-of-use.html",
  "privacyPolicyUrl": "https://overpass-channels-czhd-git-crypskii-brandons-projects-d6012021.vercel.app/privacy-policy.html"
}

--------------------------------------------------------------------------------

Index: 25
File: /Users/cryptskii/client/public/styles/singleWalletModal.css

.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: none;
    justify-content: center;
    align-items: center;
  }
  
  .modal.show {
    display: flex;
  }
  
  .modal-content {
    background-color: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    width: 300px;
    text-align: center;
  }
  
--------------------------------------------------------------------------------

Index: 26
File: /Users/cryptskii/client/public/styles/PipBoyWalletDashboard.css

/* ./src/styles/PipBoyWalletDashboard.css */

@import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

:root {
  --pip-boy-green: #3bff82;
  --pip-boy-dark-green: #1a4c33;
  --pip-boy-bg: #001a0e;
}

body {
  background-color: #000;
  color: var(--pip-boy-green);
  font-family: 'VT323', monospace;
}

.pip-boy-container {
  max-width: 800px;
  margin: 20px auto;
  padding: 20px;
  background-color: var(--pip-boy-bg);
  border: 4px solid var(--pip-boy-green);
  border-radius: 10px;
  box-shadow: 0 0 20px var(--pip-boy-green);
}

.pip-boy-screen {
  position: relative;
  overflow: hidden;
}

.scanlines::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(
    to bottom,
    transparent 50%,
    rgba(0, 0, 0, 0.1) 51%
  );
  background-size: 100% 4px;
  animation: scanlines 1s steps(60) infinite;
  pointer-events: none;
}

@keyframes scanlines {
  0% {
    background-position: 0 0;
  }
  100% {
    background-position: 0 100%;
  }
}

.pip-boy-header {
  text-align: center;
  margin-bottom: 20px;
}

.pip-boy-header h1 {
  font-size: 2.5em;
  margin: 0;
  text-shadow: 0 0 10px var(--pip-boy-green);
}

.pip-boy-nav {
  display: flex;
  justify-content: space-around;
  margin-bottom: 20px;
}

.pip-boy-nav button {
  background-color: var(--pip-boy-dark-green);
  color: var(--pip-boy-green);
  border: 2px solid var(--pip-boy-green);
  padding: 10px 20px;
  font-family: 'VT323', monospace;
  font-size: 1.2em;
  cursor: pointer;
  transition: all 0.3s ease;
}

.pip-boy-nav button:hover,
.pip-boy-nav button.active {
  background-color: var(--pip-boy-green);
  color: var(--pip-boy-bg);
}

.pip-boy-content {
  padding: 20px;
  border: 2px solid var(--pip-boy-green);
  min-height: 300px;
}

.balances-tab ul {
  list-style-type: none;
  padding: 0;
}

.balances-tab li {
  margin-bottom: 10px;
  font-size: 1.2em;
}

.balance {
  float: right;
}

.pip-boy-button {
  background-color: var(--pip-boy-dark-green);
  color: var(--pip-boy-green);
  border: 2px solid var(--pip-boy-green);
  padding: 10px 20px;
  font-family: 'VT323', monospace;
  font-size: 1.2em;
  cursor: pointer;
  transition: all 0.3s ease;
  margin: 5px;
}

.pip-boy-button:hover {
  background-color: var(--pip-boy-green);
  color: var(--pip-boy-bg);
}

.assign-buttons,
.transaction-buttons {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.pip-boy-footer {
  text-align: center;
  margin-top: 20px;
  font-size: 1.2em;
}

/* Add a glowing effect to simulate CRT phosphor */
@keyframes glow {
  0% {
    text-shadow: 0 0 5px var(--pip-boy-green);
  }
  50% {
    text-shadow: 0 0 20px var(--pip-boy-green), 0 0 30px var(--pip-boy-green);
  }
  100% {
    text-shadow: 0 0 5px var(--pip-body-green);
  }
}

.pip-boy-header h1,
.pip-boy-content h2 {
  animation: glow 2s ease-in-out infinite;
}
--------------------------------------------------------------------------------

Index: 27
File: /Users/cryptskii/client/public/styles/styles.css

/* client/src/styles/styles.css */

body {
  background-color: #f0f0f0;
}

.container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
}

.title {
  font-size: 2rem;
  margin-bottom: 2rem;
}

.connect-button {
  padding: 1rem 2rem;
  border-radius: 0.5rem;
  background-color: #0072ce;
  color: white;
  font-size: 1.2rem;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.connect-button:hover {
  background-color: #005a9e;
}

.connect-button:active {
  background-color: #003c6e;
}

.connect-button:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}

.connect-button:disabled:hover {
  background-color: #cccccc;
}

.connect-button:disabled:active {
  background-color: #cccccc;
}    

.connect-button-loading {
  background-color: #cccccc;
  cursor: not-allowed;
}

.connect-button-loading:hover {
  background-color: #cccccc;
}    

#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}    

.connect-button-container {
  margin-top: 2rem;
  display: flex;
  justify-content: center;
  align-items: center;
}

.connect-button-container button {
  margin-right: 1rem;
}    

.connect-button-container button:last-child {
  margin-right: 0;
}       
--------------------------------------------------------------------------------

Index: 28
File: /Users/cryptskii/client/public/styles/Dashboard.css

/* src/styles/Dashboard.css */

.dashboard {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    font-family: 'Arial', sans-serif;
  }
  
  .dashboard-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 30px;
  }
  
  .dashboard-header h1 {
    font-size: 2.5rem;
    color: #333;
  }
  
  .dashboard-content {
    display: grid;
    gap: 30px;
  }
  
  .dashboard-summary {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
  }
  
  .summary-card {
    background-color: #f0f4f8;
    border-radius: 10px;
    padding: 20px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  }
  
  .summary-card h2 {
    font-size: 1.2rem;
    color: #555;
    margin-bottom: 10px;
  }
  
  .summary-card .balance,
  .summary-card .count {
    font-size: 2rem;
    font-weight: bold;
    color: #2c3e50;
  }
  
  .dashboard-actions {
    background-color: #fff;
    border-radius: 10px;
    padding: 20px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  }
  
  .dashboard-actions h2 {
    font-size: 1.5rem;
    color: #333;
    margin-bottom: 20px;
  }
  
  .action-buttons {
    display: flex;
    gap: 15px;
  }
  
  .action-button {
    padding: 10px 20px;
    background-color: #3498db;
    color: #fff;
    border: none;
    border-radius: 5px;
    font-size: 1rem;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }
  
  .action-button:hover {
    background-color: #2980b9;
  }
  
  .dashboard-recent-activity {
    background-color: #fff;
    border-radius: 10px;
    padding: 20px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  }
  
  .dashboard-recent-activity h2 {
    font-size: 1.5rem;
    color: #333;
    margin-bottom: 20px;
  }
  
  .activity-list {
    list-style-type: none;
    padding: 0;
  }
  
  .activity-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 0;
    border-bottom: 1px solid #eee;
  }
  
  .activity-item:last-child {
    border-bottom: none;
  }
  
  .activity-type {
    font-weight: bold;
    color: #2c3e50;
  }
  
  .activity-date {
    color: #7f8c8d;
    font-size: 0.9rem;
  }
  
  @media (max-width: 768px) {
    .dashboard-header {
      flex-direction: column;
      align-items: flex-start;
    }
  
    .dashboard-header h1 {
      margin-bottom: 15px;
    }
  
    .action-buttons {
      flex-direction: column;
    }
  
    .action-button {
      width: 100%;
    }
  }
--------------------------------------------------------------------------------

Index: 29
File: /Users/cryptskii/client/public/styles/App.css

/* ./styles/App.css */

/* @tailwind base; */
/* @tailwind components; */
/* @tailwind utilities; */

.App {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}

.app-header {
  padding: 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: #0072ce;
  color: white;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.app-header button {
  background-color: white;
  color: #0072ce;
  padding: 10px 20px;
  border-radius: 4px;
  border: none;
  cursor: pointer;
  font-weight: bold;
}

.app-header button:hover {
  background-color: #005a9e;
}

.nav {
  display: flex;
  gap: 15px;
  padding: 10px 20px;
  background-color: #f5f5f5;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.nav a {
  text-decoration: none;
  color: #0072ce;
  font-weight: bold;
  padding: 10px;
  border-radius: 4px;
  transition: background-color 0.3s, color 0.3s;
}

.nav a:hover {
  background-color: #0072ce;
  color: white;
}

.nav a.active {
  background-color: #005a9e;
  color: white;
}
--------------------------------------------------------------------------------

Index: 30
File: /Users/cryptskii/client/api/blockchain_api.ts

// ./api/blockchain_api.ts  


--------------------------------------------------------------------------------

Index: 31
File: /Users/cryptskii/client/src/App.tsx

// ./App.tsx

import React, { useEffect, useState } from 'react';
import { Outlet, useNavigate } from 'react-router-dom';
import { TonConnectUIProvider, TonConnectButton, useTonConnectUI } from '@tonconnect/ui-react';
import logoImage from './assets/images/OP_logo_Pip2.png';
import './styles/App.css';
import { useTonConnect } from './hooks/useTonConnect';
import { ErrorBoundary } from 'react-error-boundary';
import { useTheme } from './hooks/useTheme';
import LoadingSpinner from './components/LoadingSpinner';
import { ThemeProvider } from 'next-themes';

const App: React.FC = () => {
  const { walletInfo, isLoading, error } = useTonConnect();
  const [tonConnectUI] = useTonConnectUI();
  const navigate = useNavigate();
  const { theme, toggleTheme } = useTheme();
  const [isInitialized, setIsInitialized] = useState(false);

  const connected = !!walletInfo;
  const account = walletInfo;

  useEffect(() => {
    const initializeApp = async () => {
      try {
        // Simulating an asynchronous initialization process
        await new Promise(resolve => setTimeout(resolve, 1000));
        setIsInitialized(true);
      } catch (error) {
        console.error('Failed to initialize app:', error);
        // Handle initialization error
      }
    };

    initializeApp();
  }, []);

  useEffect(() => {
    document.title = connected ? 'PipBoy Wallet' : 'PipBoy Wallet - Not Connected';

    const favicon = document.querySelector('link[rel="icon"]') as HTMLLinkElement | null;
    if (favicon) {
      favicon.href = connected ? '/logo.png' : '/logo-not-connected.png';
    }

    document.body.style.backgroundColor = theme === 'dark' ? '#052401' : '#FFFFFF';

    return () => {
      document.body.style.backgroundColor = '';
    };
  }, [connected, theme]);

  const handleConnect = async () => {
    try {
      await tonConnectUI.connectWallet();
    } catch (error) {
      console.error('Failed to connect wallet:', error);
      // Handle connection error
    }
  };

  const handleNavigate = () => {
    if (connected) {
      navigate('/dashboard');
    } else {
      navigate('/');
    }
  };

  if (!isInitialized || isLoading) {
    return <LoadingSpinner />;
  }

  if (error) {
    return <div>Error: {error}</div>;
  }

  return (
    <ErrorBoundary fallbackRender={({ error }) => <div>Error: {error.message}</div>}>
      <ThemeProvider>
        <TonConnectUIProvider manifestUrl="https://overpass-channels-czhd-git-crypskii-brandons-projects-d6012021.vercel.app/tonconnect-manifest.json">
          <div className={`App ${theme}`}>
            <header className="App-header">
              <img src={logoImage} className="App-logo" alt="logo" style={{ width: '40px', height: 'auto' }} />
              <h1>PipBoy Wallet</h1>
              <TonConnectButton />
              <div className="App-buttons">
                {!connected ? (
                  <button onClick={handleConnect}>Connect</button>
                ) : (
                  <button onClick={handleNavigate}>Go to Dashboard</button>
                )}
                <button onClick={toggleTheme}>Toggle Theme</button>
              </div>
              <div className="App-status">
                <p>Connected: {connected ? 'Yes' : 'No'}</p>
                <p>Address: {account?.address || 'N/A'}</p>
              </div>
            </header>
            <div className="App-content">
              <Outlet />
            </div>
          </div>
        </TonConnectUIProvider>
      </ThemeProvider>
    </ErrorBoundary>
  );
};

export default App;

--------------------------------------------------------------------------------

Index: 32
File: /Users/cryptskii/client/src/main.tsx

// ./main.tsx

import { createRoot } from 'react-dom/client';
import { ErrorBoundary } from 'react-error-boundary';
import { TonConnectUIProvider, THEME, TonConnectButton } from '@tonconnect/ui-react';
import './index.css';
import '@hookstate/devtools';
import { Buffer } from 'buffer';
import React, { useEffect } from 'react';
import { Outlet, Link, BrowserRouter as Router } from 'react-router-dom';
import logoImage from './assets/images/OP_logo_Pip2.png';
import { useTonConnect } from './hooks/useTonConnect';
import './styles/App.css';
import { getHttpEndpoint } from '@orbs-network/ton-access';

// Make Buffer available globally
window.Buffer = Buffer;

// Error handling component
const ErrorFallback = ({ error }: { error: Error }) => (
  <div role="alert">
    <p>Something went wrong:</p>
    <pre>{error.message}</pre>
  </div>
);

// Main application component
const App: React.FC = () => {
  const { tonConnectUI, walletInfo, error } = useTonConnect();

  const connected = !!walletInfo;
  const address = walletInfo?.address;

  // Fetch TON balance when connected
  useEffect(() => {
    const fetchTonBalance = async () => {
      if (connected && address) {
        try {
          const endpoint = await getHttpEndpoint();
          const response = await fetch(`${endpoint}/v2/address/getBalance?address=${address}`);
          const data = await response.json();
          console.log(`Balance for ${address}:`, data.balance);
        } catch (err) {
          console.error('Failed to fetch balance:', err);
        }
      }
    };

    fetchTonBalance();
  }, [connected, address]);

  // Side effects for document title, favicon, and body styles
  useEffect(() => {
    document.title = connected ? 'PipBoy Wallet' : 'PipBoy Wallet - Not Connected';

    const favicon = document.querySelector('link[rel="icon"]') as HTMLLinkElement | null;
    if (favicon) {
      favicon.href = connected ? '/logo.png' : '/logo-not-connected.png';
    }

    document.body.style.backgroundColor = connected ? '#052401' : '#000000';

    // Cleanup if necessary
    return () => {
      // Reset styles or perform cleanup
    };
  }, [connected]);

  const appStyles: React.CSSProperties = {
    backgroundColor: connected ? '#052401' : '#000000',
    color: connected ? '#fff' : '#000',
    fontFamily: 'Arial, sans-serif',
    margin: 0,
    padding: 0,
    minHeight: '100vh',
  };

  const logoStyles: React.CSSProperties = {
    width: '150px',
    height: 'auto',
    maxWidth: '100%',
  };

  const handleConnect = () => {
    tonConnectUI.connectWallet();
  };

  if (error) {
    return <div>Error: {error}</div>;
  }

  return (
    <div style={appStyles}>
      <header className="App-header">
        <img src={logoImage} className="App-logo" alt="logo" style={logoStyles} />
        <h1>PipBoy Wallet</h1>
        <TonConnectButton />
        <nav>
          <ul>
            <li><Link to="/">Home</Link></li>
            <li><Link to="/pipboy">PipBoy</Link></li>
            <li><Link to="/wallet">Wallet</Link></li>
            <li><Link to="/settings">Settings</Link></li>
          </ul>
        </nav>
        <div className="App-buttons">
          {!connected && (
            <button onClick={handleConnect}>Connect</button>
          )}
        </div>
        <div className="App-status">
          <p>Connected: {connected ? 'Yes' : 'No'}</p>
          <p>Address: {address || 'N/A'}</p>
          {error && <p>Error: {error}</p>}
        </div>
      </header>
      <div className="App-content">
        <Outlet />
      </div>
    </div>
  );
};

// Define the Main component
const Main = () => {
  return (
    <ErrorBoundary FallbackComponent={ErrorFallback}>
      <TonConnectUIProvider
        manifestUrl="https://overpass-channels-czhd-git-crypskii-brandons-projects-d6012021.vercel.app/tonconnect-manifest.json"
        uiPreferences={{ theme: THEME.DARK }}
      >
        <Router>
          <App />
        </Router>
      </TonConnectUIProvider>
    </ErrorBoundary>
  );
};

// Set up the root and render the app
const rootElement = document.getElementById('root') || document.createElement('div');
if (!rootElement.id) {
  rootElement.id = 'root';
  document.body.appendChild(rootElement);
}
const root = createRoot(rootElement);
root.render(<Main />);

// Initialize the app
export const initApp = () => {
  setupErrorHandling();
  initializeAnalytics();
  setupAPIClient();
};

// Set up the API client without using the global window object
export const setupAPIClient = () => {
  const API_BASE_URL = process.env.REACT_APP_API_BASE_URL;

  const client = {
    get: async (endpoint: string, params: Record<string, string> = {}) => {
      const url = new URL(`${API_BASE_URL}${endpoint}`);
      Object.keys(params).forEach((key) => url.searchParams.append(key, params[key]));

      try {
        const response = await fetch(url.toString(), {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${localStorage.getItem('authToken')}`,
          },
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
      } catch (error) {
        console.error('API request failed:', error);
        throw error;
      }
    },
    post: async (endpoint: string, data: Record<string, any> = {}) => {
      try {
        const response = await fetch(`${API_BASE_URL}${endpoint}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${localStorage.getItem('authToken')}`,
          },
          body: JSON.stringify(data),
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
      } catch (error) {
        console.error('API request failed:', error);
        throw error;
      }
    },
    // Additional PUT, DELETE methods here...
  };

  console.log('API client initialized');
  return client; // Return the client for use, instead of attaching it to window
};

// Set up error handling with a sanitized log
export const setupErrorHandling = (): void => {
  const logError = (message: string, error: any) => {
    const sanitizedError = {
      message: error.message,
      name: error.name,
      stack: error.stack ? error.stack.split('\n').slice(0, 3).join('\n') : undefined,
    };
    console.error(message, JSON.stringify(sanitizedError));
  };

  window.addEventListener('error', (event) => {
    logError('Uncaught error:', event.error);
  });

  window.addEventListener('unhandledrejection', (event) => {
    logError('Unhandled promise rejection:', event.reason);
  });
};

// Initialize analytics without using global window properties
export const initializeAnalytics = (): void => {
  const analyticsTracker = {
    pageView: (pageName: string) => {
      console.log(`Page view: ${pageName}`);
    },
    event: (
      category: string,
      action: string,
      label: string | null = null,
      value: number | null = null
    ) => {
      console.log(`Event: ${category} - ${action} - ${label} - ${value}`);
    },
    timing: (category: string, variable: string, time: number) => {
      console.log(`Timing: ${category} - ${variable} - ${time}ms`);
    },
  };

  analyticsTracker.pageView(window.location.pathname);

  const pushState = history.pushState;
  history.pushState = function (...args: [any, string, string | URL | null | undefined]) {
    const result = pushState.apply(this, args);
    analyticsTracker.pageView(args[1]);
    return result;
  };

  window.addEventListener('popstate', () => {
    analyticsTracker.pageView(window.location.pathname);
  });

  console.log('Analytics initialized');
};

export default App;

--------------------------------------------------------------------------------

Index: 33
File: /Users/cryptskii/client/src/index.css

@import 'tailwindcss/base';
@import 'tailwindcss/components';
@import 'tailwindcss/utilities';

@layer base {
  :root {
    --background: 120 100% 10%;
    --foreground: 120 100% 80%;

    --card: 120 100% 15%;
    --card-foreground: 120 100% 80%;

    --popover: 120 100% 15%;
    --popover-foreground: 120 100% 80%;

    --primary: 120 100% 50%;
    --primary-foreground: 120 100% 10%;

    --secondary: 120 100% 20%;
    --secondary-foreground: 120 100% 80%;

    --muted: 120 100% 20%;
    --muted-foreground: 120 100% 60%;

    --accent: 120 100% 30%;
    --accent-foreground: 120 100% 90%;

    --destructive: 0 100% 50%;
    --destructive-foreground: 120 100% 90%;

    --border: 120 100% 30%;
    --input: 120 100% 20%;
    --ring: 120 100% 50%;

    --radius: 0.25rem;
  }

  .dark {
    --background: 120 100% 5%;
    --foreground: 120 100% 90%;

    --card: 120 100% 10%;
    --card-foreground: 120 100% 90%;

    --popover: 120 100% 10%;
    --popover-foreground: 120 100% 90%;

    --primary: 120 100% 60%;
    --primary-foreground: 120 100% 5%;

    --secondary: 120 100% 15%;
    --secondary-foreground: 120 100% 90%;

    --muted: 120 100% 15%;
    --muted-foreground: 120 100% 70%;

    --accent: 120 100% 25%;
    --accent-foreground: 120 100% 95%;

    --destructive: 0 100% 40%;
    --destructive-foreground: 120 100% 95%;

    --border: 120 100% 25%;
    --input: 120 100% 15%;
    --ring: 120 100% 60%;
  }
}

@layer base {
  * {
    border-color: var(--border);
  }
  body {
    background-color: var(--background);
    color: var(--foreground);
    font-family: 'Courier New', monospace;
  }
  @keyframes scanline {
    0% {
      background-position: 0 0;
    }
    100% {
      background-position: 0 100%;
    }
  }
  body::after {
    content: "";
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: linear-gradient(
      to bottom,
      rgba(18, 16, 16, 0) 50%,
      rgba(0, 255, 0, 0.1) 50%
    );
    background-size: 100% 4px;
    pointer-events: none;
    animation: scanline 10s linear infinite;
  }
}
--------------------------------------------------------------------------------

Index: 34
File: /Users/cryptskii/client/src/vite-env.d.ts

/// <reference types="vite/client" />

// Environment Variables Interface for Vite
interface ImportMetaEnv {
  VITE_APP_NAME: string
  VITE_APP_VERSION: string
  VITE_APP_DESCRIPTION: string
  VITE_APP_REPOSITORY: string
  VITE_APP_GITHUB_URL: string
  VITE_APP_TWITTER_URL: string
  VITE_APP_DISCORD_URL: string
  VITE_APP_WEBSITE_URL: string
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}

// Image Module Declarations
declare module '*.svg' {
  const content: string
  export default content
}

declare module '*.png' {
  const content: string
  export default content
}

declare module '*.jpg' {
  const content: string
  export default content
}

declare module '*.jpeg' {
  const content: string
  export default content
}

declare module '*.gif' {
  const content: string
  export default content
}

declare module '*.webp' {
  const content: string
  export default content
}

declare module '*.ico' {
  const content: string
  export default content
}

declare module '*.bmp' {
  const content: string
  export default content
}

// CSS/SCSS/SASS Module Declarations
declare module '*.module.css' {
  const classes: { [key: string]: string }
  export default classes
}

declare module '*.module.scss' {
  const classes: { [key: string]: string }
  export default classes
}

declare module '*.module.sass' {
  const classes: { [key: string]: string }
  export default classes
}

--------------------------------------------------------------------------------

Index: 35
File: /Users/cryptskii/client/src/tonconnect-manifest.json

{
  "url": "https://overpass-channels-czhd-git-crypskii-brandons-projects-d6012021.vercel.app",
  "name": "Overpass Channels",
  "iconUrl": "/logo.png",
  "termsOfUseUrl": "/terms-of-use",
  "privacyPolicyUrl": "/privacy-policy.html",
  "description": "Overpass Channels"
}

--------------------------------------------------------------------------------

Index: 36
File: /Users/cryptskii/client/src/wrappers/ton_interactions.ts

// ./wrappers/ton_interactions.ts

import { Address, TonClient, TupleItem, Cell } from '@ton/ton'
import { ChannelStateUpdate } from '../optypes/ton_interface'
import { ChannelState } from '../blueprint/ChannelState'
import { generateProof, updateSparseMerkleTree } from '../wasm/rust_modules'

export class TonInteractions {
  constructor(private client: TonClient) {
    // Remove init() call as there's no default export
  }

  async getChannelState(channelAddress: Address): Promise<ChannelState> {
    const channelState = await this.client.callGetMethod(channelAddress, 'get_channel_state', [])
    return JSON.parse(channelState.stack.readString()) as ChannelState
  }

  async getChannelStateUpdate(channelAddress: Address): Promise<ChannelStateUpdate> {
    const channelStateUpdate = await this.client.callGetMethod(
      channelAddress,
      'get_channel_state_update',
      []
    )
    return JSON.parse(channelStateUpdate.stack.readString()) as ChannelStateUpdate
  }

  async getChannelStateExt(channelAddress: Address): Promise<ChannelState> {
    const channelState = await this.client.callGetMethod(
      channelAddress,
      'get_channel_state_ext',
      []
    )
    return JSON.parse(channelState.stack.readString()) as ChannelState
  }

  async getChannelStateUpdateExt(channelAddress: Address): Promise<ChannelStateUpdate> {
    const channelStateUpdate = await this.client.callGetMethod(
      channelAddress,
      'get_channel_state_update_ext',
      []
    )
    return JSON.parse(channelStateUpdate.stack.readString()) as ChannelStateUpdate
  }

  async generateZkProof(input: string): Promise<string> {
    return generateProof(input)
  }

  async updateSparseMerkleTree(root: string, key: string, value: string): Promise<string> {
    return updateSparseMerkleTree(root, key, value)
  }

  async submitProofToTON(proof: string, channelAddress: Address): Promise<void> {
    // Convert the proof string to a TupleItem
    const proofCell = Cell.fromBoc(Buffer.from(proof, 'hex'))[0]
    const proofTupleItem: TupleItem = { type: 'cell', cell: proofCell }

    // Submit the proof to the TON blockchain
    await this.client.callGetMethod(channelAddress, 'submit_proof', [proofTupleItem])
  }
}

--------------------------------------------------------------------------------

Index: 37
File: /Users/cryptskii/client/src/wrappers/ChannelContract.ts

import { Address, TonClient, TonClientParameters, beginCell } from '@ton/ton'
import { ChannelState } from '../blueprint/ChannelState'
import { ChannelStateUpdate } from '../optypes/ton_interface'
import * as wasm from '../wasm/channel_operations.js'

export class ChannelContract {
  constructor(
    private readonly address: Address,
    private readonly clientParameters: TonClientParameters
  ) {}

  getAddress(): Address {
    return this.address
  }

  static createFromAddress(
    address: Address,
    clientParameters: TonClientParameters
  ): ChannelContract {
    return new ChannelContract(address, clientParameters)
  }

  async sendWithdraw(amount: bigint): Promise<string> {
    const payload = beginCell().storeUint(0x5fcc3d14, 32).storeCoins(amount).endCell()

    return payload.toBoc().toString('base64')
  }

  async getChannelState(): Promise<ChannelState> {
    const result = await this.client.callGetMethod(this.address, 'get_channel_state', [])
    return this.parseChannelState(result.stack)
  }

  async getChannelStateUpdate(): Promise<ChannelStateUpdate> {
    const result = await this.client.callGetMethod(this.address, 'get_channel_state_update', [])
    return this.parseChannelStateUpdate(result.stack)
  }

  async getChannelStateExt(): Promise<ChannelState> {
    const result = await this.client.callGetMethod(this.address, 'get_channel_state_ext', [])
    return this.parseChannelState(result.stack)
  }

  async getChannelStateUpdateExt(): Promise<ChannelStateUpdate> {
    const result = await this.client.callGetMethod(this.address, 'get_channel_state_update_ext', [])
    return this.parseChannelStateUpdate(result.stack)
  }

  private parseChannelState(stack: any): ChannelState {
    const parsedState = wasm.parse_channel_state(stack)
    return new ChannelState(
      parsedState.address,
      parsedState.balance.toString(),
      parsedState.seqno,
      parsedState.state,
      parsedState.nonce,
      parsedState.merkle_root,
      new Uint8Array(parsedState.merkle_root)
    )
  }

  private parseChannelStateUpdate(stack: any): ChannelStateUpdate {
    const parsedUpdate = wasm.parse_channel_state_update(stack)
    return {
      newState: parsedUpdate.new_state,
      channelId: parsedUpdate.channel_id,
      timestamp: Number(parsedUpdate.timestamp),
      updatedBy: parsedUpdate.updated_by,
    }
  }

  private get client(): TonClient {
    return new TonClient(this.clientParameters)
  }
}

--------------------------------------------------------------------------------

Index: 38
File: /Users/cryptskii/client/src/wrappers/wrapper.ts

import { Address, Contract } from '@ton/core'
import { TonClient } from '@ton/ton'
import { updateSparseMerkleTree } from '../wasm/rust_modules'
import { generateZkSnarkProof } from '../utils/zkproofs'

export class TonConnectBase {
  client: TonClient
  constructor(client: TonClient) {
    this.client = client
    init() // Initialize WebAssembly module
  }

  async getAccount(address: string) {
    const contract = this.client.provider(Address.parse(address))
    const account = this.client.open(contract as unknown as Contract)
    return account
  }

  async getAccountState(address: string) {
    const contract = this.client.provider(Address.parse(address))
    const accountState = this.client.open(contract as unknown as Contract)
    return accountState
  }

  async getAccountStateWithProof(address: string) {
    const contract = this.client.provider(Address.parse(address))
    const accountState = this.client.open(contract as unknown as Contract)
    const proof = await generateZkSnarkProof(accountState, {})
    return { accountState, proof }
  }

  async getAccountStateWithProofAndBocCache(address: string) {
    const contract = this.client.provider(Address.parse(address))
    const accountState = this.client.open(contract as unknown as Contract)
    const proof = await generateZkSnarkProof(accountState, {})
    const updatedTree = await updateSparseMerkleTree(accountState, {})
    return { accountState, proof, updatedTree }
  }
}

export class TonConnectWrapper {
  client: TonClient
  constructor(client: TonClient) {
    this.client = client
    init() // Initialize WebAssembly module
  }

  async getAccount(address: string) {
    const contract = this.client.provider(Address.parse(address))
    const account = this.client.open(contract as unknown as Contract)
    return account
  }

  async getAccountState(address: string) {
    const contract = this.client.provider(Address.parse(address))
    const accountState = this.client.open(contract as unknown as Contract)
    return accountState
  }

  async getAccountStateWithProof(address: string) {
    const contract = this.client.provider(Address.parse(address))
    const accountState = this.client.open(contract as unknown as Contract)
    const proof = await generateZkSnarkProof(accountState, {})
    return { accountState, proof }
  }

  async getAccountStateWithProofAndBocCache(address: string) {
    const contract = this.client.provider(Address.parse(address))
    const accountState = this.client.open(contract as unknown as Contract)
    const proof = await generateZkSnarkProof(accountState, {})
    const updatedTree = await updateSparseMerkleTree(accountState, {})
    return { accountState, proof, updatedTree }
  }
}

export class TonConnect extends TonConnectBase {
  client: TonClient
  constructor(client: TonClient) {
    super(client)
    this.client = client
  }

  async getAccount(address: string) {
    const contract = this.client.provider(Address.parse(address))
    const account = this.client.open(contract as unknown as Contract)
    return account
  }

  async getAccountState(address: string) {
    const contract = this.client.provider(Address.parse(address))
    const accountState = this.client.open(contract as unknown as Contract)
    return accountState
  }

  async getAccountStateWithProof(address: string) {
    const contract = this.client.provider(Address.parse(address))
    const accountState = this.client.open(contract as unknown as Contract)
    const proof = await generateZkSnarkProof(accountState, {})
    return { accountState, proof }
  }

  async getAccountStateWithProofAndBocCache(address: string) {
    const contract = this.client.provider(Address.parse(address))
    const accountState = this.client.open(contract as unknown as Contract)
    const proof = await generateZkSnarkProof(accountState, {})
    const updatedTree = await updateSparseMerkleTree(accountState, {})
    return { accountState, proof, updatedTree }
  }
}

function init() {
  throw new Error('Function not implemented.')
}

--------------------------------------------------------------------------------

Index: 39
File: /Users/cryptskii/client/src/optypes/ton_interface.ts

// src/types/ton_interface.ts

/**
 * Represents the state of a channel.
 */
export interface ChannelState {
  id: string
  status: 'active' | 'closed' | 'pending'
  // Add other relevant fields here
}

/**
 * Represents an update to a channel's state.
 */
export interface ChannelStateUpdate {
  channelId: string
  newState: ChannelState
  timestamp: number
  updatedBy: string
  metadata?: {
    reason?: string
    additionalInfo?: any
  }
}

/**
 * Input structure for TonModule operations.
 */
export interface TonModuleInput {
  op: number
  channelId: number
  channelState: ChannelState | null
  channelStateUpdate: ChannelStateUpdate | null
  globalRootState: ChannelState | null
  ownerAddress: string | null
  seqno: number | null
  currentTime: number | null
}

/**
 * Output structure for TonModule operations.
 */
export interface TonModuleOutput {
  op: number
  channelId: number
  channelState: ChannelState | null
  channelStateUpdate: ChannelStateUpdate | null
  globalRootState: ChannelState | null
  ownerAddress: string | null
  seqno: number | null
  currentTime: number | null
}

/**
 * Represents the state managed by TonModule.
 */
export interface TonModuleState {
  channelState: ChannelState | null
  channelStateUpdate: ChannelStateUpdate | null
  globalRootState: ChannelState | null
  ownerAddress: string | null
  seqno: number | null
  currentTime: number | null
}

/**
 * Interface defining the operations available in TonModule.
 */
export interface TonInterface {
  /**
   * Runs a TonModule operation.
   * @param input - The input data for the operation.
   * @returns A promise resolving to the operation's output.
   */
  run: (input: TonModuleInput) => Promise<TonModuleOutput>

  /**
   * Retrieves the account state for a given address.
   * @param address - The address to retrieve the state for.
   * @returns A promise that resolves when the operation is complete.
   */
  getAccountState: (address: string) => Promise<void>

  /**
   * Performs a simple transfer operation.
   * @param mnemonic - The mnemonic phrase for authentication.
   * @param destination - The destination address.
   * @param amount - The amount to transfer.
   * @param seqno - The sequence number for the transaction.
   * @returns A promise that resolves when the transfer is complete.
   */
  simpleTransfer: (
    mnemonic: string[],
    destination: string,
    amount: number,
    seqno: number
  ) => Promise<void>

  /**
   * Updates the state of a specific channel.
   * @param channelId - The ID of the channel to update.
   * @param newState - The new state to set for the channel.
   * @param newSeqno - The new sequence number.
   * @returns A promise that resolves when the state update is complete.
   */
  updateState: (channelId: number, newState: ChannelState, newSeqno: number) => Promise<void>
}

--------------------------------------------------------------------------------

Index: 40
File: /Users/cryptskii/client/src/optypes/extendedTonConnectUI.ts

import {
  TonConnectUI,
  SendTransactionRequest as TonConnectSendTransactionRequest,
  ActionConfiguration as TonConnectActionConfiguration,
} from '@tonconnect/ui-react'
import { OverpassChannels } from '../blueprint/OverpassChannels'
import { Address } from '@ton/core'

export interface ExtendedTonConnectUI extends TonConnectUI {
  tonModule: OverpassChannels
  tonContract: { address: Address }
  getBalance: (address: string) => Promise<string>
  sendTransaction: (
    tx: SendTransactionRequest,
    options?: ActionConfiguration
  ) => Promise<SendTransactionResponse>
}

export interface SendTransactionResponse {
  hash: string
  boc: string
}

export interface Hash {
  hash: string
}

export interface SendTransactionRequest extends Omit<TonConnectSendTransactionRequest, 'from'> {
  from: string
  messages: {
    payload: string
    address: string
    amount: string
    body: string
  }[]
}

export interface ActionConfiguration extends TonConnectActionConfiguration {
  onSuccess?: (response: SendTransactionResponse) => void
  onError?: (error: Error) => void
}

--------------------------------------------------------------------------------

Index: 41
File: /Users/cryptskii/client/src/types/AddressOP.ts

import { Base58, Base64, Hex } from '../utils/encoding.ts';
import { ValidationError } from '../errors/ValidationError';

interface AddressOP {
    toString(): string;
    toHex(): string;
    toBase64(): string;
    toBase64url(): string;
    toBase58(): string;
}

class OverpassChannelIdentifier implements AddressOP {
    private readonly address: string;

    constructor(address: string) {
        if (!this.isValidAddress(address)) {
            throw new ValidationError('Invalid Overpass Channel Identifier address');
        }
        this.address = address;
    }

    private isValidAddress(address: string): boolean {
        // Implement address validation logic here
        // This is a placeholder and should be replaced with actual validation
        return address.length === 32 && /^[A-Za-z0-9]+$/.test(address);
    }

    toString(): string {
        return this.address;
    }

    toHex(): string {
        try {
            return Hex.encode(this.address);
        } catch (error) {
            throw new Error(`Failed to convert address to hex: ${error.message}`);
        }
    }

    toBase64(): string {
        try {
            return Base64.encode(this.address);
        } catch (error) {
            throw new Error(`Failed to convert address to base64: ${error.message}`);
        }
    }

    toBase64url(): string {
        try {
            return Base64.encodeUrl(this.address);
        } catch (error) {
            throw new Error(`Failed to convert address to base64url: ${error.message}`);
        }
    }

    toBase58(): string {
        try {
            return Base58.encode(this.address);
        } catch (error) {
            throw new Error(`Failed to convert address to base58: ${error.message}`);
        }
    }
}

export { AddressOP, OverpassChannelIdentifier };

--------------------------------------------------------------------------------

Index: 42
File: /Users/cryptskii/client/src/context/ThemeContext.tsx

// ./context/ThemeContext.tsx
import { createContext } from 'react';

export const ThemeContext = createContext({
  theme: 'light',
  toggleTheme: () => {},
});

--------------------------------------------------------------------------------

Index: 43
File: /Users/cryptskii/client/src/wasm/wasm_module.js

// ./src/wasm/wasm_module.js

import { beginCell, Cell } from '@ton/core';
import { ChannelState } from '../blueprint/ChannelState';
import { GlobalRoot } from '../blueprint/GlobalRoot';
import { StorageNode } from '../blueprint/StorageNodeState';
import { ChannelStateUpdate } from '../blueprint/ChannelStateUpdate';

import * as snarkjs from 'snarkjs';
import { poseidon } from 'circomlibjs';
import { serializeBoc, deserializeBoc } from './boc_utils';

// Function to generate a zk-SNARK proof
export async function generateProof(publicInputs, privateInputs) {
  // Implement proof generation using snarkjs
  const { proof, publicSignals } = await snarkjs.groth16.fullProve(
    privateInputs,
    'circuit.wasm',
    'circuit_final.zkey'
  );
  return proof;
}

// Function to create a hash cell from data
export function createHashCell(data) {
  let bufferData;
  if (typeof data === 'string') {
    bufferData = new TextEncoder().encode(data);
  } else if (data instanceof Uint8Array) {
    bufferData = data;
  } else {
    throw new Error('Unsupported data type for createHashCell');
  }
  return beginCell().storeBuffer(bufferData).endCell();
}

// Function to deserialize a channel state
export function deserializeChannelState(serializedState) {
  const cells = ChannelState.fromBoc(serializedState);
  if (cells.length === 0) {
    throw new Error('Failed to deserialize ChannelState');
  }
  return cells[0];
}

// Function to serialize a channel state
export function serializeChannelState(newState) {
  return newState.toBoc();
}

// Function to deserialize a channel state update
export function deserializeChannelStateUpdate(serializedState) {
  const cells = ChannelStateUpdate.fromBoc(serializedState);
  if (cells.length === 0) {
    throw new Error('Failed to deserialize ChannelStateUpdate');
  }
  return cells[0];
}

// Function to generate a Merkle proof
export async function generateMerkleProof(fieldElements) {
  // Implement Merkle proof generation logic
  // Placeholder implementation for demonstration purposes
  const proof = {
    siblings: [], // Array of sibling hashes
    path: [],     // Path to the leaf node
  };
  // Actual implementation would involve constructing the Merkle tree and generating the proof
  return proof;
}

// Function to verify a Merkle proof
export async function verifyMerkleProof(fieldElements, merkleProof, merkleRoot) {
  // Implement Merkle proof verification logic
  // Placeholder implementation for demonstration purposes
  const isValid = true;
  // Actual implementation would involve hashing the fieldElements and traversing the Merkle tree using the proof
  return isValid;
}

// Function to convert BOC to field elements
export async function convertBocToFieldElements(serializedState) {
  const deserializedState = deserializeBoc(serializedState);
  // Convert deserialized state to field elements (big integers)
  const fieldElements = deserializedState.map((cell) => BigInt(cell.hash()));
  return fieldElements;
}

// Function to generate a zk-SNARK proof with public and private inputs
export async function generateZkSnarkProof(publicInputs, privateInputs) {
  return await generateProof(publicInputs, privateInputs);
}

// Function to verify a zk-SNARK proof
export async function verifyZkSnarkProof(proof, publicInputs) {
  const verificationKey = await snarkjs.zKey.exportVerificationKey('circuit_final.zkey');
  const isValid = await snarkjs.groth16.verify(verificationKey, publicInputs, proof);
  return isValid;
}

// Function to update a Sparse Merkle Tree (SMT)
export async function updateSMT(tree, key, value) {
  // Implement SMT update logic
  // Placeholder implementation for demonstration purposes
  tree.update(key, value);
  return tree;
}

// Function to get the root of a Sparse Merkle Tree (SMT)
export async function getSMTRoot(tree) {
  // Return the root hash of the SMT
  return tree.getRoot();
}

// Function to get the state of a storage node
export async function getStorageNodeState(nodeId) {
  // Retrieve the state of the storage node from storage
  // Placeholder implementation for demonstration purposes
  const state = {
    nodeId,
    data: {},
  };
  return state;
}

// Function to update the state of a storage node
export async function updateStorageNodeState(nodeId, newState) {
  // Update the storage node state in storage
  // Placeholder implementation for demonstration purposes
  // Actual implementation would involve writing to a database or state store
  return true;
}

// Function to get the global root state
export async function getGlobalRootState() {
  // Retrieve the global root state from storage
  // Placeholder implementation for demonstration purposes
  const globalRoot = {
    rootHash: '0x...',
  };
  return globalRoot;
}

// Function to update the global root state
export async function updateGlobalRootState(newState) {
  // Update the global root state in storage
  // Placeholder implementation for demonstration purposes
  // Actual implementation would involve writing to a database or state store
  return true;
}

// Function to submit data to the TON blockchain
export async function submitToTONBlockchain(data) {
  try {
    // Implement submission logic using TON SDK or API
    // Placeholder implementation for demonstration purposes
    console.log('Submitting data to TON blockchain:', data);
    // Actual implementation would involve sending a transaction
    return true;
  } catch (error) {
    console.error('Error submitting to TON blockchain:', error);
    throw error;
  }
}

// Function to create a channel state update hash cell
export function createChannelStateUpdateHashCell(channelStateUpdateCell) {
  return beginCell().storeRef(channelStateUpdateCell).endCell();
}

// Function to get the wallet contract state
export async function getWalletContractState(walletContractAddress) {
  // Implement logic to retrieve the wallet contract state
  // Placeholder implementation for demonstration purposes
  const state = {
    address: walletContractAddress,
    balance: '1000', // Example balance
    code: '0x...',   // Smart contract code
    data: '0x...',   // Smart contract data
  };
  return state;
}

// Function to update the wallet contract state
export async function updateWalletContractState(walletContractAddress, newState) {
  // Implement logic to update the wallet contract state
  // Placeholder implementation for demonstration purposes
  // Actual implementation would involve sending a transaction to update the contract
  return true;
}

// Function to get the wallet address
export async function getWalletAddress(walletContractAddress) {
  // Return the wallet address as a Uint8Array
  const addressBytes = new TextEncoder().encode(walletContractAddress);
  return addressBytes;
}

--------------------------------------------------------------------------------

Index: 44
File: /Users/cryptskii/client/src/wasm/wasm_binding_p2.ts

import { TonClient, WalletContractV4 } from '@ton/ton'
import { internal, Address } from '@ton/core'
import { getHttpEndpoint } from '@orbs-network/ton-access'
import { mnemonicToPrivateKey } from '@ton/crypto'
import { ChannelState } from '../blueprint/ChannelState'

// Import the Wasm module
import * as wasm from './rust_modules.js' // Ensure this path is correct

// Define the MerkleProof interface
interface MerkleProof {
  siblings: Uint8Array[]
  path: number[]
}

// Function to submit a transaction to the TON blockchain
export async function submitToTONBlockchain(data: any): Promise<string> {
  try {
    // Initialize TON client
    const endpoint = await getHttpEndpoint()
    const client = new TonClient({ endpoint })

    // Prepare the message
    const message = internal({
      to: Address.parse(data.address),
      value: data.amount,
      body: data.payload,
    })

    // Sign the message
    const privateKey = await mnemonicToPrivateKey(data.mnemonic)
    const walletContract = WalletContractV4.create({
      workchain: 0,
      publicKey: privateKey.publicKey,
    })
    const sender = client.open(walletContract)
    const seqno = await sender.getSeqno()

    const transfer = walletContract.createTransfer({
      secretKey: privateKey.secretKey,
      messages: [message],
      seqno,
    })

    // Send the message
    await sender.send(transfer)

    // Return the transaction hash
    return transfer.hash().toString('hex')
  } catch (error) {
    console.error('Error submitting to TON blockchain:', error)
    throw error
  }
}

export async function deserializeChannelState(arg0: Buffer | Uint8Array): Promise<ChannelState> {
  const result = await wasm.deserialize_channel_state(arg0)
  return result as ChannelState
}

export async function serializeChannelState(newState: ChannelState): Promise<Uint8Array> {
  const result = await wasm.serialize_channel_state(newState)
  return result
}

export async function convertBocToFieldElements(
  serializedState: Uint8Array
): Promise<Uint8Array[]> {
  const result = await wasm.convert_boc_to_field_elements(serializedState)
  return result
}

export async function generateMerkleProof(fieldElements: Uint8Array[]): Promise<MerkleProof> {
  const result = await wasm.generate_merkle_proof(fieldElements)
  return result as MerkleProof
}

export async function verifyMerkleProof(
  fieldElements: Uint8Array[],
  merkleProof: MerkleProof,
  root: Uint8Array
): Promise<boolean> {
  const result = await wasm.verify_merkle_proof(fieldElements, merkleProof, root)
  return result as boolean
}

--------------------------------------------------------------------------------

Index: 45
File: /Users/cryptskii/client/src/wasm/wasm_crypto.js

// ./src/wasm/wasm_crypto.js

import { beginCell, Cell } from '@ton/core';
import * as wasm from './wasm_module'; // Adjusted the import to an existing module

export async function bocToFieldElements(serializedState) {
    return await wasm.bocToFieldElements(serializedState);
}

export async function generateZkSnarkProof(publicInputs, privateInputs) {
    return await wasm.generateZkSnarkProof(publicInputs, privateInputs);
}

export async function verifyZkSnarkProof(proof, publicInputs) {
    return await wasm.verifyZkSnarkProof(proof, publicInputs);
}

export async function updateSparseMerkleTree(tree, key, value) {
    return await wasm.updateSparseMerkleTree(tree, key, value);
}

export async function computeMerkleRoot(tree) {
    return await wasm.computeMerkleRoot(tree);
}

--------------------------------------------------------------------------------

Index: 46
File: /Users/cryptskii/client/src/wasm/wasm_merkle.js

// ./src/wasm/wasm_merkle.js

import { beginCell, Cell } from '@ton/core';
import * as wasmModule from './wasm_module';

// Function to generate a Merkle proof
export async function generateProof(fieldElements) {
  return await wasmModule.generateMerkleProof(fieldElements);
}

// Function to verify a Merkle proof
export async function verifyProof(fieldElements, merkleProof, merkleRoot) {
  return await wasmModule.verifyMerkleProof(fieldElements, merkleProof, merkleRoot);
}

// Function to update a Sparse Merkle Tree (SMT)
export async function updateSMT(tree, key, value) {
  return await wasmModule.updateSMT(tree, key, value);
}

// Function to get the root of a Sparse Merkle Tree (SMT)
export async function getSMTRoot(tree) {
  return await wasmModule.getSMTRoot(tree);
}

// Function to get the state of a storage node
export async function getStorageNodeState(nodeId) {
  return await wasmModule.getStorageNodeState(nodeId);
}

// Function to update the state of a storage node
export async function updateStorageNodeState(nodeId, newState) {
  return await wasmModule.updateStorageNodeState(nodeId, newState);
}

// Function to get the global root state
export async function getGlobalRootState() {
  return await wasmModule.getGlobalRootState();
}

// Function to update the global root state
export async function updateGlobalRootState(newState) {
  return await wasmModule.updateGlobalRootState(newState);
}

// Function to get the wallet contract state
export async function getWalletContractState(walletContractAddress) {
  return await wasmModule.getWalletContractState(walletContractAddress);
}

// Function to update the wallet contract state
export async function updateWalletContractState(walletContractAddress, newState) {
  return await wasmModule.updateWalletContractState(walletContractAddress, newState);
}

// Function to get the wallet address
export async function getWalletAddress(walletContractAddress) {
  return await wasmModule.getWalletAddress(walletContractAddress);
}

--------------------------------------------------------------------------------

Index: 47
File: /Users/cryptskii/client/src/wasm/wasm_create_cell_from_proof.js

// ./wasm/wasm_create_cell_from_proof.js

import { beginCell, Cell } from '@ton/ton';

export async function createCellFromProofAndRoot(proof, root) {
    const cell = beginCell();
    cell.storeBuffer(Buffer.from(proof, 'base64'));
    cell.storeBuffer(Buffer.from(root, 'base64'));
    return cell.endCell();
}   

export function deserializeChannelStateUpdate(serializedState) {
    return ChannelStateUpdate.read(serializedState);
}

export function serializeChannelStateUpdate(newState) {
    return newState.write();
}

export function deserializeChannelState(serializedState) {
    return ChannelState.read(serializedState);
}

export function serializeChannelState(newState) {
    return newState.write();
}

export async function generateMerkleProof(fieldElements) {
    return await wasmMerkle.generateProof(fieldElements);
}

export async function verifyMerkleProof(fieldElements, merkleProof, merkleRoot, Cell, value, proof) {
    return await wasmMerkle.verifyProof(fieldElements, merkleProof, merkleRoot);
}

export async function convertBocToFieldElements(serializedState) {
    return await wasmCrypto.bocToFieldElements(serializedState);
}

export async function generateZkSnarkProof(publicInputs, privateInputs) {
    return await wasmZkSnark.generateProof(publicInputs, privateInputs);
}

export async function verifyZkSnarkProof(proof, publicInputs) {
    return await wasmZkSnark.verifyProof(proof, publicInputs);
}

export async function updateSparseMerkleTree(tree, key, value) {
    return await wasmMerkle.updateSMT(tree, key, value);
}

export async function getSparseMerkleTreeRoot(tree) {
    return await wasmMerkle.getSMTRoot(tree);
}

export async function getStorageNodeState(nodeId) {
    return await wasmMerkle.getStorageNodeState(nodeId);
}   

export function init() {
  throw new Error('Function not implemented.');
}

--------------------------------------------------------------------------------

Index: 48
File: /Users/cryptskii/client/src/wasm/wasm_wallet_contract.js

// ./wasm/wasm_wallet_contract.js

import { beginCell } from '@ton/ton';
import { ChannelState } from '../blueprint/ChannelState';
import { GlobalRoot } from '../blueprint/GlobalRoot';
import { StorageNode } from '../blueprint/StorageNodeState';
import * as wasmMerkle from './wasm_merkle';
import * as wasmCrypto from './wasm_crypto';
import * as wasmZkSnark from './wasm_zksnark';

// Function to get public key
export async function getPublicKey() {
    try {
        const publicKey = await wasmCrypto.generatePublicKey()
        return publicKey
    } catch (error) {
        console.error('Error generating public key:', error)
        throw error
    }
}

// Function to get secret key
export async function getSecretKey() {
    try {
        const secretKey = await wasmCrypto.generateSecretKey()
        return secretKey
    } catch (error) {
        console.error('Error generating secret key:', error)
        throw error
    }
}

export async function generateProof(fieldElements, channelId, p0) {
    return await wasmZkSnark.generateProof(fieldElements);
}

export async function updateMerkleTree(root, key, value) {
    return await wasmMerkle.updateSMT(root, key, value);
}

export async function getMerkleTreeRoot(root) {
    return await wasmMerkle.getSMTRoot(root);
}

export async function getStorageNodeState(nodeId) {
    return await wasmMerkle.getStorageNodeState(nodeId);
}

export async function updateStorageNodeState(nodeId, newState) {
    return await wasmMerkle.updateStorageNodeState(nodeId, newState);
}

export async function getGlobalRootState() {
    return await wasmMerkle.getGlobalRootState();
}

export async function updateGlobalRootState(newState) {
    return await wasmMerkle.updateGlobalRootState(newState);
}

export async function submitToTONBlockchain(data) {
  try {
    const provider = await TonProvider.getProvider();
    const wallet = await provider.getWallet();
    
    const message = {
      address: data.contractAddress,
      amount: data.amount,
      payload: data.payload
    };

    const transaction = await wallet.transfer(message);
    const result = await transaction.send();

    return {
      transactionId: result.transactionId,
      status: result.status
    };
    } catch (error) {
        console.error('Error submitting to TON blockchain:', error);
        throw new Error('Failed to submit to TON blockchain');
    }
}
export function createChannelStateUpdateHashCell(channelStateUpdateCell) {
    return beginCell().storeRef(channelStateUpdateCell).endCell();
}

export function deserializeChannelStateUpdate(serializedState) {
    return ChannelStateUpdate.read(serializedState);
}

export function serializeChannelStateUpdate(newState) {
    return newState.write();
}

export function deserializeChannelState(serializedState) {
    return ChannelState.read(serializedState);
}

export function serializeChannelState(newState) {
    return newState.write();
}

export async function generateMerkleProof(fieldElements) {
    return await wasmMerkle.generateMerkleProof(fieldElements);
}

export async function verifyMerkleProof(fieldElements, merkleProof, merkleRoot, Cell, value, proof) {
    return await wasmMerkle.verifyMerkleProof(fieldElements, merkleProof, merkleRoot);
}

export async function convertBocToFieldElements(serializedState) {
    return await wasmCrypto.bocToFieldElements(serializedState);
}

export async function generateZkSnarkProof(publicInputs, privateInputs) {
    return await wasmZkSnark.generateProof(publicInputs, privateInputs);
}

export async function verifyZkSnarkProof(proof, publicInputs) {
    return await wasmZkSnark.verifyProof(proof, publicInputs);
}

export async function updateSparseMerkleTree(tree, key, value) {
    return await wasmMerkle.updateSMT(tree, key, value);
}

export async function getSparseMerkleTreeRoot(tree) {
    return await wasmMerkle.getSMTRoot(tree);
}

export async function init() {
  try {
    await wasmCrypto.init();
    await wasmMerkle.init();
    await wasmZkSnark.init();
    console.log('WASM modules initialized successfully');
  } catch (error) {
    console.error('Failed to initialize WASM modules:', error);
    throw new Error('Failed to initialize WASM modules');
  }
}
--------------------------------------------------------------------------------

Index: 49
File: /Users/cryptskii/client/src/wasm/storage_node_ops.js

// ./wasm/storage_node_ops.js

import { beginCell } from '@ton/core';
import { ChannelState } from '../blueprint/ChannelState';
import { StorageNode } from '../blueprint/StorageNodeState';

import * as wasmMerkle from './wasm_merkle';
import * as wasmCrypto from './wasm_crypto';
import * as wasmZkSnark from './wasm_zksnark';

// Note: Removed import of GlobalRoot since it's not exported by '../blueprint/GlobalRoot'

export async function generateProof(fieldElements) {
    return await wasmZkSnark.generateProof(fieldElements);
}

export function createHashCell(data) {
    return beginCell().storeBuffer(Buffer.from(data)).endCell();
}

export function deserializeChannelState(serializedState) {
    return ChannelState.read(serializedState);
}

export function serializeChannelState(newState) {
    return newState.write();
}

export async function generateMerkleProof(fieldElements) {
    return await wasmMerkle.generateProof(fieldElements);
}

export async function verifyMerkleProof(fieldElements, merkleProof, merkleRoot) {
    return await wasmMerkle.verifyProof(fieldElements, merkleProof, merkleRoot);
}

export async function convertBocToFieldElements(serializedState) {
    return await wasmCrypto.bocToFieldElements(serializedState);
}

export async function generateZkSnarkProof(publicInputs, privateInputs) {
    return await wasmZkSnark.generateProof(publicInputs, privateInputs);
}

export async function verifyZkSnarkProof(proof, publicInputs) {
    return await wasmZkSnark.verifyProof(proof, publicInputs);
}

export async function updateSparseMerkleTree(tree, key, value) {
    return await wasmMerkle.updateSMT(tree, key, value);
}

export async function getSparseMerkleTreeRoot(tree) {
    return await wasmMerkle.getSMTRoot(tree);
}

export async function getStorageNodeState(nodeId) {
    return await wasmMerkle.getStorageNodeState(nodeId);
}

export async function updateStorageNodeState(nodeId, newState) {
    return await wasmMerkle.updateStorageNodeState(nodeId, newState);
}

export async function getGlobalRootState() {
    return await wasmMerkle.getGlobalRootState();
}

export async function updateGlobalRootState(newState) {
    return await wasmMerkle.updateGlobalRootState(newState);
}

export async function submitToTONBlockchain(data) {
    try {
        // Implement the actual submission logic here
        console.log('Data successfully submitted to TON blockchain');
        return true;
    } catch (error) {
        console.error('Error submitting to TON blockchain:', error);
        throw error;
    }
}

export function createChannelStateUpdateHashCell(channelStateUpdateCell) {
    return beginCell().storeRef(channelStateUpdateCell).endCell();
}

--------------------------------------------------------------------------------

Index: 50
File: /Users/cryptskii/client/src/wasm/rust_modules.js

// ./wasm/rust_modules.js

import { beginCell } from '@ton/core';
import { ChannelState } from '../blueprint/ChannelState';
import { StorageNode } from '../blueprint/StorageNodeState';

import * as wasmMerkle from './wasm_merkle';
import * as wasmZkSnark from './wasm_zksnark';
import * as wasmModule from './wasm_module';

export async function generateProof(fieldElements, channelId, p0) {
    return await wasmZkSnark.generateProof(fieldElements);
}

export async function updateMerkleTree(root, key, value) {
    return await wasmMerkle.updateSMT(root, key, value);
}

export async function getMerkleTreeRoot(root) {
    return await wasmMerkle.getSMTRoot(root);
}

export async function getStorageNodeState(nodeId) {
    return await wasmMerkle.getStorageNodeState(nodeId);
}

export async function updateStorageNodeState(nodeId, newState) {
    return await wasmMerkle.updateStorageNodeState(nodeId, newState);
}

export async function getGlobalRootState() {
    return await wasmMerkle.getGlobalRootState();
}

export async function updateGlobalRootState(newState) {
    return await wasmMerkle.updateGlobalRootState(newState);
}

export async function submitToTONBlockchain(data) {
    console.log('Data successfully submitted to TON blockchain');
    return true;
}

export function createChannelStateUpdateHashCell(channelStateUpdateCell) {
    return beginCell().storeRef(channelStateUpdateCell).endCell();
}

export async function updateSparseMerkleTree(tree, key, value) {
    return await wasmMerkle.updateSMT(tree, key, value);
}

export async function verifyZkSnarkProof(proof, publicInputs) {
    return await wasmZkSnark.verifyProof(proof, publicInputs);
}

export async function computeMerkleRoot(tree) {
    return await wasmMerkle.getSMTRoot(tree);
}

export async function deserialize_channel_state(arg0) {
    return await wasmModule.deserializeChannelState(arg0);
}

export async function serialize_channel_state(newState) {
    return await wasmModule.serializeChannelState(newState);
}

export async function convert_boc_to_field_elements(serializedState) {
    return await wasmModule.convertBocToFieldElements(serializedState);
}

export async function generateProof(fieldElements) {
    return await wasmZkSnark.generateProof(fieldElements);
}

export async function updateSparseMerkleTree(root, key, value) {
    return await wasmMerkle.updateSMT(root, key, value);
}

export async function getSparseMerkleTreeRoot(tree) {
    return await wasmMerkle.getSMTRoot(tree);
}

export async function getStorageNodeState(nodeId) {
    return await wasmMerkle.getStorageNodeState(nodeId);
}

export async function updateStorageNodeState(nodeId, newState) {
    return await wasmMerkle.updateStorageNodeState(nodeId, newState);
}

export async function getGlobalRootState() {
    return await wasmMerkle.getGlobalRootState();
}

export async function updateGlobalRootState(newState) {
    return await wasmMerkle.updateGlobalRootState(newState);
}

export async function submitToTONBlockchain(data) {
    console.log('Data successfully submitted to TON blockchain');
    return true;
}

export function createChannelStateUpdateHashCell(channelStateUpdateCell) {
    return beginCell().storeRef(channelStateUpdateCell).endCell();
}

export async function updateSparseMerkleTree(tree, key, value) {
    return await wasmMerkle.updateSMT(tree, key, value);
}

export async function verifyZkSnarkProof(proof, publicInputs) {
    return await wasmZkSnark.verifyProof(proof, publicInputs);
}

export async function computeMerkleRoot(tree) {
    return await wasmMerkle.getSMTRoot(tree);
}

export async function deserialize_channel_state(arg0) {
    return await wasmModule.deserializeChannelState(arg0);
}

export async function serialize_channel_state(newState) {
    return await wasmModule.serializeChannelState(newState);
}

export async function convert_boc_to_field_elements(serializedState) {
    return await wasmModule.convertBocToFieldElements(serializedState);
}

export async function generate_merkle_proof(fieldElements) {
    return await wasmModule.generateMerkleProof(fieldElements);
}

export async function verify_merkle_proof(fieldElements, merkleProof, root) {
    return await wasmModule.verifyMerkleProof(fieldElements, merkleProof, root);
}   

export function init() {
  throw new Error('Function not implemented.');
}


--------------------------------------------------------------------------------

Index: 51
File: /Users/cryptskii/client/src/wasm/wasm_zksnark.js

// ./src/wasm/wasm_zksnark.js

import { beginCell, Cell } from '@ton/ton';
import * as wasm from './wasm_module'; // Adjusted the import to an existing module

export async function generateProof(publicInputs, privateInputs) {
    return await wasm.generateZkSnarkProof(publicInputs, privateInputs);
}

export async function verifyProof(proof, publicInputs) {
    return await wasm.verifyZkSnarkProof(proof, publicInputs);
}

export async function generateProofWithInputs(publicInputs, privateInputs, inputs) {
    return await wasm.generateProofWithInputs(publicInputs, privateInputs, inputs);
}

export async function verifyProofWithInputs(proof, publicInputs, inputs) {
    return await wasm.verifyProofWithInputs(proof, publicInputs, inputs);
}

export async function generateProofWithInputsAndWitness(publicInputs, privateInputs, inputs, witness) {
    return await wasm.generateProofWithInputsAndWitness(publicInputs, privateInputs, inputs, witness);
}

export async function verifyProofWithInputsAndWitness(proof, publicInputs, inputs, witness) {
    return await wasm.verifyProofWithInputsAndWitness(proof, publicInputs, inputs, witness);
}

export function submitToTONBlockchain(data) {
    throw new Error('Function not implemented.');
}

export function init() {
    throw new Error('Function not implemented.');
}

--------------------------------------------------------------------------------

Index: 52
File: /Users/cryptskii/client/src/wasm/channel_operations.js

// ./client/src/wasm/channel_operations.js

import { Cell, beginCell } from '@ton/ton';
import { ChannelState } from '../blueprint/ChannelState';
import { ChannelStateUpdate } from '../optypes/ton_interface';
import * as wasm from './wasm_module';

export function parse_channel_state(stack) {
    return {
        address: stack[0],
        balance: stack[1],
        seqno: stack[2],
        state: stack[3],
        nonce: stack[4],
        merkle_root: stack[5]
    };
}

export function parse_channel_state_update(stack) {
    return {
        address: stack[0],
        balance: stack[1],
        seqno: stack[2],
        state: stack[3],
        nonce: stack[4],
        merkle_root: stack[5],
        merkle_proof: stack[6],
        proof: stack[7],
        p0: stack[8],
        p1: stack[9],
        p2: stack[10],
        p3: stack[11],
        p4: stack[12],
        p5: stack[13],
        p6: stack[14],
        p7: stack[15],
        p8: stack[16],
        p9: stack[17],
        p10: stack[18],
        p11: stack[19],
        p12: stack[20],
        p13: stack[21],
        p14: stack[22],
        p15: stack[23],
        p16: stack[24],
        p17: stack[25],
        p18: stack[26],
        p19: stack[27],
        p20: stack[28],
        p21: stack[29],
        p22: stack[30],
        p23: stack[31],
        p24: stack[32],
        p25: stack[33],
        p26: stack[34],
        p27: stack[35],
        p28: stack[36],
        p29: stack[37],
        p30: stack[38],
        updated_by: stack[39],
        new_state: stack[40],
        channel_id: stack[41],
        timestamp: stack[42]
    };
}

// Function to create a new channel
export async function createChannel(
    walletContract,
    channelId,
    initialBalance
) {
    const channelState = new ChannelState(
        channelId,
        initialBalance,
        new Date().getTime()
    );
    const channelStateUpdate = new ChannelStateUpdate(
        channelState,
        walletContract.address,
        channelState.address,
        channelState.balance,
        channelState.seqno,
        channelState.state,
        channelState.nonce,
        channelState.merkleRoot,
        channelState.merkleProof,
        channelState.proof,
        channelState.p0,
        channelState.p1,
        channelState.p2,
        channelState.p3,
        channelState.p4,
        channelState.p5,
        channelState.p6,
        channelState.p7,
        channelState.p8,
        channelState.p9,
        channelState.p10,
        channelState.p11,
        channelState.p12,
        channelState.p13,
        channelState.p14,
        channelState.p15,
        channelState.p16,
        channelState.p17,
        channelState.p18,
        channelState.p19,
        channelState.p20,
        channelState.p21,
        channelState.p22,
        channelState.p23,
        channelState.p24,
        channelState.p25,
        channelState.p26,
        channelState.p27,
        channelState.p28,
        channelState.p29,
        walletContract.address,
        new Date().getTime(),
        '0'
    );
    
    const channelStateCell = beginCell()
        .store(storeChannelState(channelState))
        .store(storeChannelStateUpdate(channelStateUpdate))
        .endCell();

    // Create a new channel state update hash cell using Rust-compiled Wasm function
    const channelStateUpdateHashCell = wasm.createHashCell(channelStateUpdate.toBoc());
    const channelStateUpdateHashCellHash = channelStateUpdateHashCell.hash();
    const channelStateUpdateHashCellHashCell = wasm.createHashCell(channelStateUpdateHashCellHash);

    return channelStateUpdateHashCellHashCell;
}

// Helper function to store ChannelStateUpdate in a Cell
function storeChannelStateUpdate(state) {
    return beginCell()
        .store(state.address)
        .store(state.balance)
        .store(state.seqno)
        .store(state.state)
        .store(state.nonce)
        .store(state.merkle_root)
        .store(state.merkle_proof)
        .store(state.proof)
        .store(state.p0)
        .store(state.p1)
        .store(state.p2)
        .store(state.p3)
        .store(state.p4)
        .store(state.p5)
        .store(state.p6)
        .store(state.p7)
        .store(state.p8)
        .store(state.p9)
        .store(state.p10)
        .store(state.p11)
        .store(state.p12)
        .store(state.p13)
        .store(state.p14)
        .store(state.p15)
        .store(state.p16)
        .store(state.p17)
        .store(state.p18)
        .store(state.p19)
        .store(state.p20)
        .store(state.p21)
        .store(state.p22)
        .store(state.p23)
        .store(state.p24)
        .store(state.p25)
        .store(state.p26)
        .store(state.p27)
        .store(state.p28)
        .store(state.p29)
        .store(state.p30)
        .store(state.updated_by)
        .store(state.new_state)
        .store(state.channel_id)
        .store(state.timestamp)
        .endCell();
}
--------------------------------------------------------------------------------

Index: 53
File: /Users/cryptskii/client/src/tests/setupTests.ts

// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom'

--------------------------------------------------------------------------------

Index: 54
File: /Users/cryptskii/client/src/utils/helpers.ts

/**
 * Checks if an object is empty.
 * @param obj - The object to check.
 * @returns True if the object is null, undefined, or has no own properties; false otherwise.
 */
export const isEmpty = (obj: any) => {
  if (obj === null || obj === undefined) {
    return true
  }
  return Object.keys(obj).length === 0
}
export const isNotEmpty = (obj: any) => {
  if (obj === null || obj === undefined) {
    return false
  }
  return Object.keys(obj).length > 0
}
export const isNull = (obj: any) => {
  if (obj === null || obj === undefined) {
    return true
  }
  return false
}

--------------------------------------------------------------------------------

Index: 55
File: /Users/cryptskii/client/src/utils/delay.ts

export function delay(ms: number): Promise<void> {
  return new Promise<void>((resolve) =>
    setTimeout(() => {
      resolve()
    }, ms)
  )
}

--------------------------------------------------------------------------------

Index: 56
File: /Users/cryptskii/client/src/utils/enhancedGroupManager.ts

// enhancedGroupManager.ts

import { useState } from 'react'

type GroupType = 'Checking' | 'Savings' | 'Custom'

interface Channel {
  id: number
  balance: number
}

interface GroupBalances {
  checking: number
  savings: number
  custom: number
}

const useEnhancedGroupManager = () => {
  const [groups, setGroups] = useState<{ [key in GroupType]: Channel[] }>({
    Checking: [],
    Savings: [],
    Custom: [],
  })

  const assignChannelToGroup = (channelId: number, balance: number, groupType: GroupType) => {
    setGroups((prevGroups) => ({
      ...prevGroups,
      [groupType]: [...prevGroups[groupType], { id: channelId, balance }],
    }))
  }

  const getGroupBalances = (): GroupBalances => {
    return {
      checking: calculateGroupBalance('Checking'),
      savings: calculateGroupBalance('Savings'),
      custom: calculateGroupBalance('Custom'),
    }
  }

  const calculateGroupBalance = (groupType: GroupType): number => {
    return groups[groupType].reduce((total, channel) => total + channel.balance, 0)
  }

  const initiateTransaction = (amount: number, fromGroup: GroupType): boolean => {
    const groupBalance = calculateGroupBalance(fromGroup)

    if (groupBalance < amount) {
      console.error(`Insufficient funds in ${fromGroup}`)
      return false
    }

    setGroups((prevGroups) => {
      const updatedChannels = prevGroups[fromGroup].map((channel) => {
        if (amount > 0) {
          const deduction = Math.min(channel.balance, amount)
          amount -= deduction
          return { ...channel, balance: channel.balance - deduction }
        }
        return channel
      })

      return {
        ...prevGroups,
        [fromGroup]: updatedChannels,
      }
    })

    return true
  }

  const getChannelsInGroup = (groupType: GroupType): Channel[] => {
    return groups[groupType]
  }

  const moveChannel = (channelId: number, fromGroup: GroupType, toGroup: GroupType) => {
    setGroups((prevGroups) => {
      const channelIndex = prevGroups[fromGroup].findIndex((channel) => channel.id === channelId)
      if (channelIndex === -1) {
        console.error(`Channel ${channelId} not found in ${fromGroup}`)
        return prevGroups
      }

      const [movedChannel] = prevGroups[fromGroup].splice(channelIndex, 1)
      prevGroups[toGroup].push(movedChannel)

      return { ...prevGroups }
    })
  }

  return {
    assignChannelToGroup,
    getGroupBalances,
    initiateTransaction,
    getChannelsInGroup,
    moveChannel,
  }
}

export default useEnhancedGroupManager

--------------------------------------------------------------------------------

Index: 57
File: /Users/cryptskii/client/src/utils/web-3-Utils.ts

import { ExtendedTonConnectUI } from '../optypes/extendedTonConnectUI'
import { ITonConnect } from '@tonconnect/sdk'
import * as rustModules from '../wasm/rust_modules'

let wasmModule: any

export async function initializeWasmModule(): Promise<void> {
  if (!wasmModule) {
    wasmModule = rustModules.init()
  }
}

export async function getTonConnectUI(): Promise<ExtendedTonConnectUI | null> {
  if (!window.tonConnectUI) {
    console.error('TonConnectUI not initialized')
    return null
  } else {
    return window.tonConnectUI
  }
}

export async function getTonConnect(): Promise<ITonConnect | null> {
  if (!window.tonConnectUI) {
    console.error('TonConnectUI not initialized')
    return null
  } else {
    return window.tonConnectUI.connector
  }
}

export async function generateZkSnarkProof(input: string): Promise<string> {
  await initializeWasmModule()
  return wasmModule.generate_zksnark_proof(input)
}

export async function updateMerkleTree(root: string, key: string, value: string): Promise<string> {
  await initializeWasmModule()
  return wasmModule.updateSparseMerkleTree(root, key, value)
}

export async function submitProofToTON(proof: string): Promise<void> {
  const tonConnect = await getTonConnect()
  if (tonConnect) {
    try {
      const response = await fetch('/api/submit-proof', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ proof }),
      })

      if (!response.ok) {
        throw new Error('Failed to submit proof')
      }

      console.log('Proof submission initiated')
    } catch (error) {
      console.error('Error initiating proof submission:', error)
    }
  } else {
    console.error('Unable to connect to TON')
  }
}

declare global {
  interface Window {
    tonConnectUI: ExtendedTonConnectUI
  }
}

--------------------------------------------------------------------------------

Index: 58
File: /Users/cryptskii/client/src/utils/logger.ts

// ./src/utils/logger.ts

import winston from 'winston'

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(winston.format.timestamp(), winston.format.json()),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ],
})

export function logError(message: string, error: Error) {
  logger.error(message, { error: error.stack })
}

export function logInfo(message: string, meta?: object) {
  logger.info(message, meta)
}

export function logWarn(message: string, meta?: object) {
  logger.warn(message, meta)
}

export function logDebug(message: string, meta?: object) {
  logger.debug(message, meta)
}

export default logger

--------------------------------------------------------------------------------

Index: 59
File: /Users/cryptskii/client/src/utils/overpass_client.ts

import axios from 'axios'

// You could add appropriate TypeScript interfaces for the response format based on Overpass API documentation
export interface OverpassResponse {
  // Add necessary fields that you'd expect in the Overpass response
  elements: Array<any>
}

export class OverpassClient {
  private baseUrl: string

  constructor(baseUrl: string = 'https://overpass-api.de/api/interpreter') {
    this.baseUrl = baseUrl
  }

  // Generic query function for Overpass API
  async query(overpassQuery: string): Promise<OverpassResponse> {
    try {
      const response = await axios.post(this.baseUrl, `data=${encodeURIComponent(overpassQuery)}`, {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
      })
      return response.data
    } catch (error) {
      if (axios.isAxiosError(error)) {
        console.error(`Overpass API request failed: ${error.message}`, error.response?.data)
        throw new Error(`Overpass API request failed: ${error.message}`)
      }
      console.error('Unexpected error during Overpass API request:', error)
      throw error
    }
  }

  // Helper function to generate bounding box query
  private createBoundingBoxQuery(
    type: string,
    south: number,
    west: number,
    north: number,
    east: number
  ): string {
    return `
      [out:json];
      (
        ${type}(${south},${west},${north},${east});
      );
      out body;
      >;
      out skel qt;
    `
  }

  // Fetch nodes within the bounding box
  async getNodesInBoundingBox(
    south: number,
    west: number,
    north: number,
    east: number
  ): Promise<OverpassResponse> {
    const query = this.createBoundingBoxQuery('node', south, west, north, east)
    return this.query(query)
  }

  // Fetch ways within the bounding box
  async getWaysInBoundingBox(
    south: number,
    west: number,
    north: number,
    east: number
  ): Promise<OverpassResponse> {
    const query = this.createBoundingBoxQuery('way', south, west, north, east)
    return this.query(query)
  }

  // Fetch relations within the bounding box
  async getRelationsInBoundingBox(
    south: number,
    west: number,
    north: number,
    east: number
  ): Promise<OverpassResponse> {
    const query = this.createBoundingBoxQuery('relation', south, west, north, east)
    return this.query(query)
  }
}

--------------------------------------------------------------------------------

Index: 60
File: /Users/cryptskii/client/src/utils/zkproofs.ts

// ./src/utils/zkproofs.ts

import * as wasmModule from '../wasm/wasm_module'

// Function to generate a zk-SNARK proof
export async function generateProof(fieldElements: bigint[]): Promise<any> {
  return await wasmModule.generateProof(fieldElements, fieldElements)
}

// Function to update the Merkle Tree
export async function updateMerkleTree(tree: any, key: any, value: any): Promise<void> {
  await wasmModule.updateSMT(tree, key, value)
}

// Function to get the root of the Merkle Tree
export async function getMerkleTreeRoot(tree: any): Promise<any> {
  return await wasmModule.getSMTRoot(tree)
}

// Function to get the state of a storage node
export async function getStorageNodeState(nodeId: string): Promise<any> {
  return await wasmModule.getStorageNodeState(nodeId)
}

// Function to update the state of a storage node
export async function updateStorageNodeState(nodeId: string, newState: any): Promise<void> {
  await wasmModule.updateStorageNodeState(nodeId, newState)
}

// Function to get the wallet address
export async function getWalletAddress(walletContractAddress: string): Promise<Uint8Array> {
  const result = await wasmModule.getWalletAddress(walletContractAddress)
  if (!(result instanceof Uint8Array)) {
    throw new Error('Expected Uint8Array but received another type')
  }
  return result
}

// Function to get the state of a wallet contract
export async function getWalletContractState(walletContractAddress: string): Promise<any> {
  const result = await wasmModule.getWalletContractState(walletContractAddress)
  return result
}

// Function to update the state of a wallet contract
export async function updateWalletContractState(
  walletContractAddress: string,
  newState: any
): Promise<void> {
  await wasmModule.updateWalletContractState(walletContractAddress, newState)
}

// Function to get the state hash of a storage node
export async function getStorageNodeStateHash(nodeId: string): Promise<any> {
  return await wasmModule.getStorageNodeState(nodeId)
}

// Function to submit data to the TON blockchain
export async function submitToTONBlockchain(data: any): Promise<void> {
  await wasmModule.submitToTONBlockchain(data)
}

// Function to create a channel state update hash cell
export function createChannelStateUpdateHashCell(channelStateUpdateCell: any): any {
  return wasmModule.createChannelStateUpdateHashCell(channelStateUpdateCell)
}

// Function to generate a zk-SNARK proof with public and private inputs
export async function generateZkSnarkProof(publicInputs: any, privateInputs: any): Promise<any> {
  return await wasmModule.generateZkSnarkProof(publicInputs, privateInputs)
}

// Function to verify a zk-SNARK proof
export async function verifyZkSnarkProof(proof: any, publicInputs: any): Promise<boolean> {
  return await wasmModule.verifyZkSnarkProof(proof, publicInputs)
}

// Function to update the sparse Merkle tree
export async function updateSparseMerkleTree(tree: any, key: any, value: any): Promise<void> {
  await wasmModule.updateSMT(tree, key, value)
}

// Function to get the root of a sparse Merkle tree
export async function getSparseMerkleTreeRoot(tree: any): Promise<any> {
  return await wasmModule.getSMTRoot(tree)
}

--------------------------------------------------------------------------------

Index: 61
File: /Users/cryptskii/client/src/utils/formatters.ts

// ./src/utils/formatters.ts

import { Address, Cell, Message, fromNano } from '@ton/core'

export const formatAddress = (address: Address) => {
  return address.toString({ testOnly: true })
}

export const formatBalance = (balance: bigint) => {
  return fromNano(balance).toString()
}

export const getBalance = async (client: any, address: Address): Promise<string> => {
  const rawBalance = await client.getBalance(address)
  return formatBalance(rawBalance)
}

export const formatCell = (cell: Cell) => {
  return cell.toBoc({ idx: false }).toString('base64')
}

export const formatCellMessage = (cellMessage: Message) => {
  return cellMessage.body.toBoc({ idx: false }).toString('base64')
}

export const formatInternalMessage = (internalMessage: Message) => {
  return internalMessage.body.toBoc({ idx: false }).toString('base64')
}

export const formatMessage = (message: Message) => {
  return formatCellMessage(message)
}

export const formatTransaction = (transaction: Cell) => {
  return transaction.toBoc({ idx: false }).toString('base64')
}

export const formatTransactionMessage = (transactionMessage: Message) => {
  return transactionMessage.body.toBoc({ idx: false }).toString('base64')
}

export const formatTransactionMessageBody = (transactionMessage: Message) => {
  const body = transactionMessage.body.beginParse()
  const info = body.loadUint(32)
  const value = body.loadCoins()
  const mode = body.loadUint(8)
  const bounce = body.loadBit()
  const stateInit = body.loadMaybeRef()
  const bodyCell = body.loadMaybeRef()
  return {
    info,
    value: value.toString(),
    mode,
    bounce,
    stateInit: stateInit ? stateInit.toString() : null,
    bodyCell: bodyCell ? bodyCell.toString() : null,
  }
}

export const formatTransactionMessageBodyToJson = (transactionMessage: Message) => {
  const body = transactionMessage.body.beginParse()
  const info = body.loadUint(32)
  const value = body.loadCoins()
  const mode = body.loadUint(8)
  const bounce = body.loadBit()
  const stateInit = body.loadMaybeRef()
  const bodyCell = body.loadMaybeRef()
  return {
    info,
    value: value.toString(),
    mode,
    bounce,
    stateInit: stateInit ? stateInit.toString() : null,
    bodyCell: bodyCell ? bodyCell.toString() : null,
  }
}

export const formatTransactionMessageBodyToString = (transactionMessage: Message) => {
  const body = transactionMessage.body.beginParse()
  const info = body.loadUint(32)
  const value = body.loadCoins()
  const mode = body.loadUint(8)
  const bounce = body.loadBit()
  const stateInit = body.loadMaybeRef()
  const bodyCell = body.loadMaybeRef()
  return JSON.stringify({
    info,
    value: value.toString(),
    mode,
    bounce,
    stateInit: stateInit ? stateInit.toString() : null,
    bodyCell: bodyCell ? bodyCell.toString() : null,
  })
}

--------------------------------------------------------------------------------

Index: 62
File: /Users/cryptskii/client/src/utils/theme.ts

// ./src/utils/theme.ts

import { useEffect } from 'react'
import { useTheme } from 'next-themes'
import { useRouter } from 'next/router'
import { useTranslation } from 'react-i18next'

export function initializeTheme() {
  const router = useRouter()
  const { i18n } = useTranslation()
  const { setTheme } = useTheme()

  useEffect(() => {
    const handleRouteChange = () => {
      const theme = i18n.resolvedLanguage === 'en' ? 'light' : 'dark'
      setTheme(theme)
    }

    router.events.on('routeChangeComplete', handleRouteChange)

    return () => {
      router.events.off('routeChangeComplete', handleRouteChange)
    }
  }, [router, i18n, setTheme])
}

export default {
  initializeTheme,
}

--------------------------------------------------------------------------------

Index: 63
File: /Users/cryptskii/client/src/utils/encoding.ts

    // ./utils/encoding.ts

import * as ImportedBase58 from 'base58-js';
import * as ImportedBase64 from 'base64-js';
import * as ImportedHex from 'hex-js';  
    
    export const encode = (data: Uint8Array): string => {
    return ImportedBase64.encode(data);
    };

    export const decode = (data: string): Uint8Array => {
    return ImportedBase64.decode(data);
    };

    export const encodeHex = (data: Uint8Array): string => {
    return ImportedHex.encode(data);
    };

    export const decodeHex = (data: string): Uint8Array => {
    return ImportedHex.decode(data);
    };

    export const encodeBase58 = (data: Uint8Array): string => {
    return ImportedBase58.encode(data);
    };

    export const decodeBase58 = (data: string): Uint8Array => {
    return ImportedBase58.decode(data);
    };  

    export const encodeBase64 = (data: Uint8Array): string => {
        return ImportedBase64.encode(data);
    };

    export const decodeBase64 = (data: string): Uint8Array => {
        return ImportedBase64.decode(data);
    };  

    export const encodeBase64Url = (data: Uint8Array): string => {
        return ImportedBase64.encodeUrl(data);
    };

    export const decodeBase64Url = (data: string): Uint8Array => {
        return ImportedBase64.decodeUrl(data);
    };      

    export { ImportedBase58 as Base58, ImportedBase64 as Base64, ImportedHex as Hex };

--------------------------------------------------------------------------------

Index: 64
File: /Users/cryptskii/client/src/utils/ton-connect.ts

import { TonClient } from '@ton/ton'
import { Address } from '@ton/core'

export class OverpassChannels {
  constructor(private client: TonClient) {}

  async getChannelState(channelAddress: Address): Promise<string> {
    const channelState = await this.client.callGetMethod(channelAddress, 'get_channel_state', [])
    return channelState.stack.readString()
  }
}

const client = new TonClient({
  endpoint: 'https://toncenter.com/api/v2/jsonRPC',
})

const overpassChannels = new OverpassChannels(client)

async function main() {
  const channelAddress = Address.parse('EQCDZ-8459-8459-8459-84598459845984598459845984598459')
  const channelState = await overpassChannels.getChannelState(channelAddress)
  console.log(channelState)
}

main()

--------------------------------------------------------------------------------

Index: 65
File: /Users/cryptskii/client/src/utils/utils.tsx

export const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms))

--------------------------------------------------------------------------------

Index: 66
File: /Users/cryptskii/client/src/utils/addressUtils.ts

// src/utils/addressUtils.ts

import { Address } from '@ton/core'
import { Buffer } from 'buffer' // Ensure Buffer is available

/**
 * Parses a TON address string into an Address instance.
 * @param address - The TON address string to parse.
 * @returns An Address instance.
 * @throws Error if the address format is invalid.
 */
export const parseAddress = (address: string): Address => {
  try {
    const [workchainStr, hash] = address.split(':')
    const workchain = parseInt(workchainStr, 10)
    if (isNaN(workchain)) {
      throw new Error('Invalid workchain in address')
    }
    if (!hash || hash.length !== 64) {
      // assuming hash is a 32-byte hex string
      throw new Error('Invalid hash in address')
    }
    // Convert hash string to Buffer
    const hashBuffer = Buffer.from(hash, 'hex')
    return new Address(workchain, hashBuffer)
  } catch (error) {
    throw new Error('Invalid channel address format')
  }
}

--------------------------------------------------------------------------------

Index: 67
File: /Users/cryptskii/client/src/styles/singleWalletModal.css

.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: none;
    justify-content: center;
    align-items: center;
  }
  
  .modal.show {
    display: flex;
  }
  
  .modal-content {
    background-color: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    width: 300px;
    text-align: center;
  }
  
--------------------------------------------------------------------------------

Index: 68
File: /Users/cryptskii/client/src/styles/PipBoyWalletDashboard.css

/* ./src/styles/PipBoyWalletDashboard.css */

@import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

:root {
  --pip-boy-green: #3bff82;
  --pip-boy-dark-green: #1a4c33;
  --pip-boy-bg: #001a0e;
}

body {
  background-color: #000;
  color: var(--pip-boy-green);
  font-family: 'VT323', monospace;
}

.pip-boy-container {
  max-width: 800px;
  margin: 20px auto;
  padding: 20px;
  background-color: var(--pip-boy-bg);
  border: 4px solid var(--pip-boy-green);
  border-radius: 10px;
  box-shadow: 0 0 20px var(--pip-boy-green);
}

.pip-boy-screen {
  position: relative;
  overflow: hidden;
}

.scanlines::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(
    to bottom,
    transparent 50%,
    rgba(0, 0, 0, 0.1) 51%
  );
  background-size: 100% 4px;
  animation: scanlines 1s steps(60) infinite;
  pointer-events: none;
}

@keyframes scanlines {
  0% {
    background-position: 0 0;
  }
  100% {
    background-position: 0 100%;
  }
}

.pip-boy-header {
  text-align: center;
  margin-bottom: 20px;
}

.pip-boy-header h1 {
  font-size: 2.5em;
  margin: 0;
  text-shadow: 0 0 10px var(--pip-boy-green);
}

.pip-boy-nav {
  display: flex;
  justify-content: space-around;
  margin-bottom: 20px;
}

.pip-boy-nav button {
  background-color: var(--pip-boy-dark-green);
  color: var(--pip-boy-green);
  border: 2px solid var(--pip-boy-green);
  padding: 10px 20px;
  font-family: 'VT323', monospace;
  font-size: 1.2em;
  cursor: pointer;
  transition: all 0.3s ease;
}

.pip-boy-nav button:hover,
.pip-boy-nav button.active {
  background-color: var(--pip-boy-green);
  color: var(--pip-boy-bg);
}

.pip-boy-content {
  padding: 20px;
  border: 2px solid var(--pip-boy-green);
  min-height: 300px;
}

.balances-tab ul {
  list-style-type: none;
  padding: 0;
}

.balances-tab li {
  margin-bottom: 10px;
  font-size: 1.2em;
}

.balance {
  float: right;
}

.pip-boy-button {
  background-color: var(--pip-boy-dark-green);
  color: var(--pip-boy-green);
  border: 2px solid var(--pip-boy-green);
  padding: 10px 20px;
  font-family: 'VT323', monospace;
  font-size: 1.2em;
  cursor: pointer;
  transition: all 0.3s ease;
  margin: 5px;
}

.pip-boy-button:hover {
  background-color: var(--pip-boy-green);
  color: var(--pip-boy-bg);
}

.assign-buttons,
.transaction-buttons {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.pip-boy-footer {
  text-align: center;
  margin-top: 20px;
  font-size: 1.2em;
}

/* Add a glowing effect to simulate CRT phosphor */
@keyframes glow {
  0% {
    text-shadow: 0 0 5px var(--pip-boy-green);
  }
  50% {
    text-shadow: 0 0 20px var(--pip-boy-green), 0 0 30px var(--pip-boy-green);
  }
  100% {
    text-shadow: 0 0 5px var(--pip-body-green);
  }
}

.pip-boy-header h1,
.pip-boy-content h2 {
  animation: glow 2s ease-in-out infinite;
}
--------------------------------------------------------------------------------

Index: 69
File: /Users/cryptskii/client/src/styles/styles.css

/* client/src/styles/styles.css */

body {
  background-color: #f0f0f0;
}

.container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
}

.title {
  font-size: 2rem;
  margin-bottom: 2rem;
}

.connect-button {
  padding: 1rem 2rem;
  border-radius: 0.5rem;
  background-color: #0072ce;
  color: white;
  font-size: 1.2rem;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.connect-button:hover {
  background-color: #005a9e;
}

.connect-button:active {
  background-color: #003c6e;
}

.connect-button:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}

.connect-button:disabled:hover {
  background-color: #cccccc;
}

.connect-button:disabled:active {
  background-color: #cccccc;
}    

.connect-button-loading {
  background-color: #cccccc;
  cursor: not-allowed;
}

.connect-button-loading:hover {
  background-color: #cccccc;
}    

#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}    

.connect-button-container {
  margin-top: 2rem;
  display: flex;
  justify-content: center;
  align-items: center;
}

.connect-button-container button {
  margin-right: 1rem;
}    

.connect-button-container button:last-child {
  margin-right: 0;
}       
--------------------------------------------------------------------------------

Index: 70
File: /Users/cryptskii/client/src/styles/Dashboard.css

/* src/styles/Dashboard.css */

.dashboard {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    font-family: 'Arial', sans-serif;
  }
  
  .dashboard-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 30px;
  }
  
  .dashboard-header h1 {
    font-size: 2.5rem;
    color: #333;
  }
  
  .dashboard-content {
    display: grid;
    gap: 30px;
  }
  
  .dashboard-summary {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
  }
  
  .summary-card {
    background-color: #f0f4f8;
    border-radius: 10px;
    padding: 20px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  }
  
  .summary-card h2 {
    font-size: 1.2rem;
    color: #555;
    margin-bottom: 10px;
  }
  
  .summary-card .balance,
  .summary-card .count {
    font-size: 2rem;
    font-weight: bold;
    color: #2c3e50;
  }
  
  .dashboard-actions {
    background-color: #fff;
    border-radius: 10px;
    padding: 20px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  }
  
  .dashboard-actions h2 {
    font-size: 1.5rem;
    color: #333;
    margin-bottom: 20px;
  }
  
  .action-buttons {
    display: flex;
    gap: 15px;
  }
  
  .action-button {
    padding: 10px 20px;
    background-color: #3498db;
    color: #fff;
    border: none;
    border-radius: 5px;
    font-size: 1rem;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }
  
  .action-button:hover {
    background-color: #2980b9;
  }
  
  .dashboard-recent-activity {
    background-color: #fff;
    border-radius: 10px;
    padding: 20px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  }
  
  .dashboard-recent-activity h2 {
    font-size: 1.5rem;
    color: #333;
    margin-bottom: 20px;
  }
  
  .activity-list {
    list-style-type: none;
    padding: 0;
  }
  
  .activity-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 0;
    border-bottom: 1px solid #eee;
  }
  
  .activity-item:last-child {
    border-bottom: none;
  }
  
  .activity-type {
    font-weight: bold;
    color: #2c3e50;
  }
  
  .activity-date {
    color: #7f8c8d;
    font-size: 0.9rem;
  }
  
  @media (max-width: 768px) {
    .dashboard-header {
      flex-direction: column;
      align-items: flex-start;
    }
  
    .dashboard-header h1 {
      margin-bottom: 15px;
    }
  
    .action-buttons {
      flex-direction: column;
    }
  
    .action-button {
      width: 100%;
    }
  }
--------------------------------------------------------------------------------

Index: 71
File: /Users/cryptskii/client/src/styles/App.css

/* @tailwind base; */
/* @tailwind components; */
/* @tailwind utilities; */

.App {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}

.app-header {
  padding: 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: #0072ce;
  color: white;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.app-header button {
  background-color: white;
  color: #0072ce;
  padding: 10px 20px;
  border-radius: 4px;
  border: none;
  cursor: pointer;
  font-weight: bold;
}

.app-header button:hover {
  background-color: #005a9e;
}

--------------------------------------------------------------------------------

Index: 72
File: /Users/cryptskii/client/src/components/Settings.tsx

/**
 * This component displays the settings page, allowing the user to connect and disconnect their wallet, and view their wallet address and balance.
 */
// ./src/components/Settings.tsx
// This is a component that displays the settings page. It allows the user to connect and disconnect their wallet. It also displays the user's wallet address and balance.

import React, { useState, useEffect } from 'react'
import { useTonConnectUI } from '@tonconnect/ui-react'
import { useTonConnect } from '../hooks/useTonConnect'

const Settings: React.FC = () => {
  const [] = useTonConnectUI()
  const [] = useState(false)
  const [, setWalletAddress] = useState('')
  const [, setWalletBalance] = useState('')
  const [] = useState('')
  const [] = useState(false)

  const { tonConnectUI: tonConnect } = useTonConnect()

  useEffect(() => {
    if (tonConnect && 'tonModule' in tonConnect && 'tonContract' in tonConnect) {
      ;(tonConnect as any).tonModule.on('state', handleTonModuleState)
    }
  }, [tonConnect])

  const handleTonModuleState = (state: any) => {
    console.log('Ton module state:', state)
    console.log('Ton module state channelState:', state.channelState)
    console.log('Ton module state channelStateUpdate:', state.channelStateUpdate)
    console.log('Ton module state globalRootState:', state.globalRootState)
    console.log('Ton module state ownerAddress:', state.ownerAddress)
    console.log('Ton module state seqno:', state.seqno)
    console.log('Ton module state currentTime:', state.currentTime)
  }

  const handleConnectWallet = async () => {
    if (tonConnect && 'tonModule' in tonConnect && 'tonContract' in tonConnect) {
      const newWalletAddress = await (tonConnect as any).tonModule.getAccountState(
        (tonConnect as any).tonContract
      )
      setWalletAddress(newWalletAddress)
    }
  }

  const handleGetBalance = async () => {
    if (tonConnect && 'tonModule' in tonConnect && 'tonContract' in tonConnect) {
      const newWalletBalance = await (tonConnect as any).tonModule.getBalance(
        (tonConnect as any).tonContract
      )
      setWalletBalance(newWalletBalance)
    }
  }

  return (
    <div>
      <h1>Settings</h1>
      <button onClick={handleConnectWallet}>Connect Wallet</button>
      <button onClick={handleGetBalance}>Get Balance</button>
    </div>
  )
}

export default Settings

--------------------------------------------------------------------------------

Index: 73
File: /Users/cryptskii/client/src/components/Dashboard.tsx

// ./src/components/Dashboard.tsx/
// This is a component that fetches and displays dashboard data. It uses the FetchDashboardData class from the api/blockchain_api module to fetch data from a blockchain API. The component uses the useState hook to manage the dashboard data state. It also uses the useEffect hook to fetch the dashboard data when the component mounts. The fetchData function is called when the component mounts and when the data is fetched successfully. The component renders a loading spinner while the data is being fetched, and an error message if an error occurs. If the data is successfully fetched, it renders the dashboard data in a table format.

import React, { useState, useEffect } from 'react'
import { FetchDashboardData } from '../api/blockchain_api'

interface DashboardData {
  salesData: { month: string; revenue: number }[]
  totalRevenue: number
  newCustomers: number
  activeUsers: number
}

const Dashboard: React.FC = () => {
  const [dashboardData, setDashboardData] = useState<DashboardData | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const fetchData = async () => {
      try {
        const data = await new FetchDashboardData().fetchData()
        if (data !== undefined) {
          setDashboardData(data as DashboardData)
          setLoading(false)
          setError(null)
          console.log('Dashboard data fetched successfully')
          console.log('Dashboard data:', data)
          console.log('Dashboard data type:', typeof data)
          if (typeof data === 'object' && data !== null) {
            console.log('Dashboard data keys:', Object.keys(data))
            console.log('Dashboard data values:', Object.values(data))
            console.log('Dashboard data entries:', Object.entries(data))
            console.log('Dashboard data length:', Object.keys(data).length)
            console.log('Dashboard data keys:', Object.keys(data))
          }
        } else {
          setError('No data received from the server')
        }
      } catch (error) {
        setError('Failed to fetch dashboard data')
        console.error('Error fetching dashboard data:', error)
      } finally {
        setLoading(false)
      }
    }
    fetchData()
  }, [])

  if (loading) {
    return <div>Loading...</div>
  }

  if (error) {
    return <div>Error: {error}</div>
  }

  if (!dashboardData) {
    return <div>No data available</div>
  }

  return (
    <div>
      <h1>Dashboard</h1>
      <div>
        <h2>Sales Data</h2>
        <ul>
          {dashboardData.salesData.map((item) => (
            <li key={item.month}>
              {item.month}: ${item.revenue}
            </li>
          ))}
        </ul>
      </div>
      <div>
        <h2>Total Revenue: ${dashboardData.totalRevenue}</h2>
        <h2>New Customers: {dashboardData.newCustomers}</h2>
        <h2>Active Users: {dashboardData.activeUsers}</h2>
      </div>
    </div>
  )
}

export default Dashboard

--------------------------------------------------------------------------------

Index: 74
File: /Users/cryptskii/client/src/components/Transactions.tsx

// ./components/Transactions.tsx

import { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { useTonWallet } from '@tonconnect/ui-react'

export function Transaction() {
  const navigate = useNavigate()
  const wallet = useTonWallet()
  const [showBalance, setShowBalance] = useState(false)
  const [] = useState('')
  const [] = useState('')

  const connectWallet = () => {
    if (wallet && 'connector' in wallet && wallet.connector) {
      ;(wallet.connector as any).connect()
    }
  }

  const disconnectWallet = () => {
    if (wallet && 'connector' in wallet && wallet.connector) {
      ;(wallet.connector as any).disconnect()
    }
  }

  return (
    <div>
      <button onClick={connectWallet}>Connect Wallet</button>
      <button onClick={disconnectWallet}>Disconnect Wallet</button>
      <button onClick={() => setShowBalance(!showBalance)}>
        {showBalance ? 'Hide Balance' : 'Show Balance'}
      </button>
      {showBalance && (
        <div>
          <p>
            Balance:{' '}
            {wallet ? ((wallet.account as any).balance?.toString() ?? 'N/A') : 'Loading...'}
          </p>
        </div>
      )}
      <button onClick={() => navigate('/create-channel')}>Create Channel</button>
      <button onClick={() => navigate('/join-channel')}>Join Channel</button>
      <button onClick={() => navigate('/channels')}>Channels</button>
      <button onClick={() => navigate('/channel-state')}>Channel State</button>
    </div>
  )
}

export default Transaction

--------------------------------------------------------------------------------

Index: 75
File: /Users/cryptskii/client/src/components/Channels.tsx

import React, { useEffect, useState } from 'react';
import { FolderEdit, ArrowRightLeft, FolderUp, PenTool, UserCog } from 'lucide-react';
import { Link } from 'react-router-dom';
import init, { TonInterface } from '../wasm/pkg'; // Adjust the import path based on the wasm-pack output

interface ShortcutBoxProps {
  path: string;
  title: string;
  icon: React.ReactNode;
  onClick?: () => void; // Added to handle clicks for Wasm interactions
}

const ShortcutBox: React.FC<ShortcutBoxProps> = ({ path, title, icon, onClick }) => (
  <Link
    to={path}
    onClick={onClick}
    className="p-4 border rounded-lg flex flex-col items-center justify-center"
  >
    {icon}
    <span className="mt-2">{title}</span>
  </Link>
);

const Channel: React.FC = () => {
  const [tonInterface, setTonInterface] = useState<TonInterface | null>(null);

  useEffect(() => {
    const initWasm = async () => {
      await init(); // Initialize Wasm module
      const instance = await TonInterface.new();
      setTonInterface(instance);
    };
    initWasm();
  }, []);

  const handleCreateChannel = async () => {
    if (!tonInterface) return;
    try {
      const channelState = await tonInterface.get_channel_state(1); // Example channel ID
      console.log('Channel State:', channelState);
    } catch (error) {
      console.error('Error creating channel:', error);
    }
  };

  const quickActions = [
    {
      path: '/channels/create',
      title: 'Create Channel',
      icon: <FolderEdit />,
      onClick: handleCreateChannel,
    },
    { path: '/channels/join', title: 'Join Channel', icon: <FolderEdit /> },
    { path: '/channels/deposit', title: 'Deposit', icon: <FolderEdit /> },
    { path: '/channels/withdraw', title: 'Withdraw', icon: <FolderEdit /> },
    { path: '/channels/close', title: 'Close Channel', icon: <FolderEdit /> },
  ];

  const channelActions = [
    { path: '/channels', title: 'Channels', icon: <FolderEdit /> },
    { path: '/transactions', title: 'Transactions', icon: <ArrowRightLeft /> },
    { path: '/accounts', title: 'Accounts', icon: <FolderUp /> },
    { path: '/contracts', title: 'Contracts', icon: <PenTool /> },
    { path: '/settings', title: 'Settings', icon: <UserCog /> },
  ];

  return (
    <div className="flex flex-col items-center justify-center min-h-screen py-8">
      <section className="mb-8">
        <h2 className="text-2xl font-bold mb-6">Quick Actions</h2>
        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
          {quickActions.map((action, index) => (
            <ShortcutBox key={index} {...action} />
          ))}
        </div>
      </section>

      <section>
        <h2 className="text-2xl font-bold mb-6">Channels</h2>
        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
          {channelActions.map((action, index) => (
            <ShortcutBox key={index} {...action} />
          ))}
        </div>
      </section>
    </div>
  );
};

export default Channel;

--------------------------------------------------------------------------------

Index: 76
File: /Users/cryptskii/client/src/components/NodeComponent.tsx

import React, { useState, useEffect } from "react";
import ReactDOM from "react-dom";

interface StorageNode {
  send_state_update: (node: StorageNode) => Promise<void>;
}

interface Wasm {
  StorageNode: new (id: string, root: string) => StorageNode;
  epidemic_synchronization_task: (node: StorageNode, allNodes: StorageNode[]) => Promise<void>;
}

declare const wasm: Wasm;

const NodeComponent: React.FC = () => {
    const [node, setNode] = useState<StorageNode | null>(null);
    const [merkleRoot, setMerkleRoot] = useState<string>("");
  
    useEffect(() => {
      const initializeNode = async () => {
        const nodeA = new wasm.StorageNode("Node_A", "Root_A");
        setNode(nodeA);
        setMerkleRoot("Root_A");
      };
      initializeNode();
    }, []);
  
    const handleUpdate = async () => {
      if (node) {
        await node.send_state_update(node);
        setMerkleRoot("Updated_Root");
      }
    };
  
    const handleSync = async () => {
      if (node) {
        const allNodes = [node]; // Example, replace with actual nodes
        await wasm.epidemic_synchronization_task(node, allNodes);
      }
    };
  
    return (
      <div>
        <h3>Node ID: Node_A</h3>
        <p>Merkle Root: {merkleRoot}</p>
        <button onClick={handleUpdate}>Update State</button>
        <button onClick={handleSync}>Start Synchronization</button>
      </div>
    );
  };

ReactDOM.render(
  <React.StrictMode>
    <NodeComponent />
  </React.StrictMode>,
  document.getElementById("root")
);

export default NodeComponent;
--------------------------------------------------------------------------------

Index: 77
File: /Users/cryptskii/client/src/components/PlanetaryNavigation.tsx

import { useState, useEffect } from 'react'
import { Address } from '@ton/core'
import { TonClient } from '@ton/ton'
import { BlockchainApiWrapper } from '../api/api'
import {
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuTrigger,
  NavigationMenuContent,
  NavigationMenuLink,
} from './ui/navigation-menu'
import { Menubar, MenubarTrigger, MenubarContent, MenubarItem } from './ui/menubar'
import { MenubarMenu } from '@radix-ui/react-menubar'

export function PipBoyWalletDashboard() {
  const [balances, setBalances] = useState({ checking: '0', savings: '0', custom: '0' })
  const [isDisabled, setIsDisabled] = useState(false)
  const [buttonText, setButtonText] = useState('REFRESH BALANCES')
  const [isLoading, setIsLoading] = useState(false)
  const [systemStatus, setSystemStatus] = useState('OPTIMAL')

  const client = new TonClient({ endpoint: 'https://toncenter.com/api/v2/jsonRPC' })
  const blockchainApi = new BlockchainApiWrapper(client)

  useEffect(() => {
    fetchBalances()
  }, [])

  const fetchBalances = async () => {
    setIsLoading(true)
    try {
      const checkingAddress = Address.parse('EQD...') // Replace with actual addresses
      const savingsAddress = Address.parse('EQD...')
      const customAddress = Address.parse('EQD...')

      const [checkingState, savingsState, customState] = await Promise.all([
        blockchainApi.getAccount(checkingAddress),
        blockchainApi.getAccount(savingsAddress),
        blockchainApi.getAccount(customAddress),
      ])

      setBalances({
        checking: checkingState.balance.toString(),
        savings: savingsState.balance.toString(),
        custom: customState.balance.toString(),
      })

      setSystemStatus('OPTIMAL')
    } catch (error) {
      console.error('Failed to fetch balances:', error)
      setSystemStatus('ERROR')
    } finally {
      setIsLoading(false)
    }
  }

  const handleRefresh = () => {
    setIsDisabled(true)
    setButtonText('REFRESHING...')
    fetchBalances().then(() => {
      setIsDisabled(false)
      setButtonText('REFRESH BALANCES')
    })
  }

  return (
    <div className="container mx-auto p-4">
      <Menubar>
        <MenubarMenu>
          <MenubarTrigger>File</MenubarTrigger>
          <MenubarContent>
            <MenubarItem>New Channel</MenubarItem>
            <MenubarItem>Close Channel</MenubarItem>
          </MenubarContent>
        </MenubarMenu>
        <MenubarMenu>
          <MenubarTrigger>Edit</MenubarTrigger>
          <MenubarContent>
            <MenubarItem>Rename Channel</MenubarItem>
            <MenubarItem>Change Address</MenubarItem>
          </MenubarContent>
        </MenubarMenu>
      </Menubar>

      <NavigationMenu>
        <NavigationMenuList>
          <NavigationMenuItem>
            <NavigationMenuTrigger>Channels</NavigationMenuTrigger>
            <NavigationMenuContent>
              <NavigationMenuLink href="/channels/checking">Checking</NavigationMenuLink>
              <NavigationMenuLink href="/channels/savings">Savings</NavigationMenuLink>
              <NavigationMenuLink href="/channels/custom">Custom</NavigationMenuLink>
            </NavigationMenuContent>
          </NavigationMenuItem>
        </NavigationMenuList>
      </NavigationMenu>

      <header className="text-center mb-8">
        <h1 className="text-4xl font-bold">VAULT-TEC OVERPASS</h1>
        <p className="text-xl">CHANNEL MANAGEMENT SYSTEM</p>
      </header>

      <main className="bg-card text-card-foreground p-6 rounded-lg shadow-lg">
        <h2 className="text-2xl font-bold mb-4">CHANNEL BALANCES</h2>
        <ul className="space-y-2">
          <li className="flex justify-between">
            <span className="uppercase">checking:</span>
            <span className="font-bold">{balances.checking} CAPS</span>
          </li>
          <li className="flex justify-between">
            <span className="uppercase">savings:</span>
            <span className="font-bold">{balances.savings} CAPS</span>
          </li>
          <li className="flex justify-between">
            <span className="uppercase">custom:</span>
            <span className="font-bold">{balances.custom} CAPS</span>
          </li>
        </ul>
        <button
          onClick={handleRefresh}
          disabled={isDisabled}
          className="mt-4 bg-accent text-accent-foreground px-4 py-2 rounded hover:bg-opacity-80 disabled:opacity-50"
        >
          {buttonText}
        </button>
        {isLoading && <div data-testid="loading-indicator">Loading...</div>}
      </main>

      <footer className="text-center mt-8">
        <p>VAULT-TEC CHANNEL STATUS: {systemStatus}</p>
      </footer>
    </div>
  )
}

export default PipBoyWalletDashboard

--------------------------------------------------------------------------------

Index: 78
File: /Users/cryptskii/client/src/components/Shortcutbox.tsx

import React from 'react'
import { Link } from 'react-router-dom'
import {
  ArrowRightLeft,
  FolderUp,
  ImagePlus,
  PenTool,
  FolderEdit,
  UserCog,
  Send,
  FileCode,
} from 'lucide-react'

// Interface for shortcut box props
interface ShortcutBoxProps {
  href: string
  title: string
  icon: React.ReactNode
}

// Component that represents an individual shortcut box
const ShortcutBox: React.FC<ShortcutBoxProps> = ({ href, title, icon }) => (
  <Link
    to={href}
    className="flex flex-col items-center justify-center h-32 rounded-lg shadow-md hover:bg-gray-200 transition-colors"
  >
    <div className="text-3xl mb-2">{icon}</div>
    <span className="text-lg font-semibold text-center">{title}</span>
  </Link>
)

// Container component for rendering multiple shortcut boxes
const ShortcutBoxContainer: React.FC = () => {
  // Array of shortcuts with href, title, and icon
  const shortcuts = [
    { href: '/channels', title: 'Channels', icon: <FolderEdit /> },
    { href: '/transfer', title: 'Transfer', icon: <ArrowRightLeft /> },
    { href: '/upload', title: 'Upload', icon: <FolderUp /> },
    { href: '/create-image', title: 'Create Image', icon: <ImagePlus /> },
    { href: '/edit', title: 'Edit', icon: <PenTool /> },
    { href: '/user-settings', title: 'User Settings', icon: <UserCog /> },
    { href: '/send', title: 'Send', icon: <Send /> },
    { href: '/code', title: 'Code', icon: <FileCode /> },
  ]

  return (
    <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
      {shortcuts.map((shortcut) => (
        <ShortcutBox key={shortcut.href} {...shortcut} />
      ))}
    </div>
  )
}

export default ShortcutBoxContainer

--------------------------------------------------------------------------------

Index: 79
File: /Users/cryptskii/client/src/components/MainLayout.tsx

import { useNavigate } from 'react-router-dom';
import { useState, useEffect, JSXElementConstructor, ReactElement, ReactNode } from 'react';
import { useTonConnect } from '../hooks/useTonConnect';
import ShortcutBoxContainer from './Shortcutbox';
import { TonClient, Address } from '@ton/ton';

function useWalletBalance(address: string | undefined) {
  const [balance, setBalance] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    async function fetchBalance() {
      if (!address) {
        setBalance(null);
        setIsLoading(false);
        return;
      }

      setIsLoading(true);
      try {
        const client = new TonClient({
          endpoint: 'https://toncenter.com/api/v2/jsonRPC',
        });
        const parsedAddress = Address.parse(address);
        const accountInfo = await client.getBalance(parsedAddress);
        const balanceInNanotons = accountInfo.toString();
        const balanceInTons = parseFloat(balanceInNanotons) / 1e9;
        setBalance(balanceInTons.toFixed(2));
      } catch (err) {
        setError(err instanceof Error ? err : new Error('An error occurred while fetching balance'));
      } finally {
        setIsLoading(false);
      }
    }

    fetchBalance();
  }, [address]);

  return { balance, isLoading, error };
}

export function MainLayout() {
  const navigate = useNavigate();
  const { tonConnectUI, walletInfo, isLoading: isConnecting } = useTonConnect();
  const [showBalance, setShowBalance] = useState(false);
  const {
    balance,
    isLoading: isBalanceLoading,
    error: balanceError,
  } = useWalletBalance(walletInfo?.address);

  useEffect(() => {
    if (balanceError) {
      console.error('Failed to fetch wallet balance', balanceError);
    }
  }, [balanceError]);

  const handleDisconnect = async () => {
    try {
      await tonConnectUI?.disconnect();
    } catch (error) {
      console.error('Failed to disconnect wallet', error);
    }
  };

  const handleConnect = async () => {
    try {
      await tonConnectUI?.connectWallet();
    } catch (error) {
      console.error('Failed to connect wallet', error);
    }
  };

  const connected = !!walletInfo;

  const renderNavButton = (
    route: string,
    label:
      | string
      | number
      | boolean
      | ReactElement<any, string | JSXElementConstructor<any>>
      | Iterable<ReactNode>
      | null
      | undefined
  ) => (
    <button
      className="text-green-500 hover:text-green-300 transition-colors duration-200"
      onClick={() => navigate(route)}
    >
      [{label}]
    </button>
  );

  const ROUTES = {
    Home: '/',
    Transactions: '/transactions',
    Blocks: '/blocks',
    Wallet: '/wallet',
    Settings: '/settings',
    // Add other routes as needed
  };

  return (
    <div className="flex flex-col h-screen bg-black text-green-500 font-mono">
      <header className="bg-green-900 text-green-500 p-4 border-b-2 border-green-500">
        <div className="flex justify-between items-center">
          <nav className="flex items-center space-x-4">
            {Object.entries(ROUTES).map(([key, route]) => renderNavButton(route as string, key))}
          </nav>
          <div className="flex items-center gap-4">
            {connected ? (
              <>
                <button
                  className="text-green-500 hover:text-green-300 transition-colors duration-200"
                  onClick={handleDisconnect}
                >
                  [DISCONNECT]
                </button>
                <button
                  className="text-green-500 hover:text-green-300 transition-colors duration-200"
                  onClick={() => setShowBalance(!showBalance)}
                >
                  {showBalance ? `[HIDE BALANCE]` : `[SHOW BALANCE]`}
                </button>
              </>
            ) : (
              <button
                className="text-green-500 hover:text-green-300 transition-colors duration-200"
                onClick={handleConnect}
                disabled={isConnecting}
              >
                {isConnecting ? '[CONNECTING...]' : '[CONNECT WALLET]'}
              </button>
            )}
          </div>
          {connected && (
            <div className="flex items-center gap-4">
              <div className="flex items-center gap-2">
                <img
                  src="https://avatars.githubusercontent.com/u/10198965?v=4"
                  alt="TonConnect Logo"
                  className="w-8 h-8 rounded-full border-2 border-green-500"
                />
                <span className="text-green-500">
                  {walletInfo?.address
                    ? walletInfo.address.slice(0, 6) + '...' + walletInfo.address.slice(-4)
                    : ''}
                </span>
              </div>
              <div className="flex items-center gap-2">
                <span className="text-green-500">Balance:</span>
                <span className="text-green-500">
                  {showBalance
                    ? isBalanceLoading
                      ? 'Loading...'
                      : balanceError
                        ? 'Error'
                        : balance
                    : '******'}
                </span>
              </div>
            </div>
          )}
        </div>
      </header>

      <main className="flex-grow overflow-auto">
        <div className="container mx-auto py-8">
          <h2 className="text-2xl font-bold mb-6 text-center text-green-500">QUICK ACTIONS</h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
            <ShortcutBoxContainer />
          </div>
        </div>
      </main>

      <footer className="bg-green-900 text-green-500 p-4 border-t-2 border-green-500">
        <div className="container mx-auto text-center">
          <p>© {new Date().getFullYear()} TON Explorer. All rights reserved.</p>
        </div>
      </footer>
    </div>
  );
}
export default MainLayout;
--------------------------------------------------------------------------------

Index: 80
File: /Users/cryptskii/client/src/components/OrbitalControls.tsx

// ./src/components/OrbitalControls.tsx
// This component is a custom implementation of the OrbitControls class from the Three.js library. It extends the EventDispatcher class to handle events and provides methods for controlling the camera orbit. It also includes a custom event type for the OrbitControlsEventMap. The OrbitControls class is used to control the camera orbit in a 3D scene.

import * as THREE from 'three'
import { EventDispatcher } from 'three'

// Define an event map to explicitly specify the events for OrbitControls
interface OrbitControlsEventMap {
  change: OrbitControlsEvent
  start: OrbitControlsEvent
  end: OrbitControlsEvent
}

// Define the OrbitControlsEvent interface
interface OrbitControlsEvent extends THREE.Event {
  type: keyof OrbitControlsEventMap
  target: any
}

export class OrbitControls extends EventDispatcher<OrbitControlsEventMap> {
  camera: THREE.PerspectiveCamera
  domElement: HTMLElement
  enabled: boolean = true
  target: THREE.Vector3 = new THREE.Vector3()
  object: THREE.PerspectiveCamera
  minDistance: number = 0
  maxDistance: number = Infinity
  minZoom: number = 0
  maxZoom: number = Infinity
  minPolarAngle: number = 0
  maxPolarAngle: number = Math.PI
  minAzimuthAngle: number = -Infinity
  maxAzimuthAngle: number = Infinity
  enableDamping: boolean = false
  dampingFactor: number = 0.25
  enableZoom: boolean = true
  zoomSpeed: number = 1.0
  enableRotate: boolean = true
  rotateSpeed: number = 1.0
  enablePan: boolean = true
  keyPanSpeed: number = 7.0
  autoRotate: boolean = false
  autoRotateSpeed: number = 2.0
  enableKeys: boolean = true
  keys: { LEFT: string; UP: string; RIGHT: string; BOTTOM: string; SHIFT: string }
  mouseButtons: { LEFT: THREE.MOUSE; MIDDLE: THREE.MOUSE; RIGHT: THREE.MOUSE }
  touches: { ONE: THREE.TOUCH; TWO: THREE.TOUCH }
  position0: THREE.Vector3
  zoom0: number
  spherical: THREE.Spherical
  private changeEvent: OrbitControlsEvent
  constructor(camera: THREE.PerspectiveCamera, domElement: HTMLElement) {
    super()
    this.camera = camera
    this.domElement = domElement
    this.object = camera

    // Initialize properties
    this.keys = {
      LEFT: 'ArrowLeft',
      UP: 'ArrowUp',
      RIGHT: 'ArrowRight',
      BOTTOM: 'ArrowDown',
      SHIFT: 'ShiftLeft',
    }
    this.mouseButtons = {
      LEFT: THREE.MOUSE.ROTATE,
      MIDDLE: THREE.MOUSE.DOLLY,
      RIGHT: THREE.MOUSE.PAN,
    }
    this.touches = {
      ONE: THREE.TOUCH.ROTATE,
      TWO: THREE.TOUCH.DOLLY_PAN,
    }
    this.position0 = this.object.position.clone()
    this.zoom0 = this.object.zoom
    this.spherical = new THREE.Spherical()
    this.changeEvent = { type: 'change', target: this }

    // Bind methods
    this.getPolarAngle = this.getPolarAngle.bind(this)
    this.getAzimuthalAngle = this.getAzimuthalAngle.bind(this)
    this.reset = this.reset.bind(this)
    this.update = this.update.bind(this)
    this.handleAutoRotate = this.handleAutoRotate.bind(this)
    this.keysCheck = this.keysCheck.bind(this)
    this.pan = this.pan.bind(this)
    this.rotate = this.rotate.bind(this)
    this.zoom = this.zoom.bind(this)
    this.damping = this.damping.bind(this)
  }

  getPolarAngle() {
    return this.spherical.phi
  }

  getAzimuthalAngle() {
    return this.spherical.theta
  }

  reset() {
    this.target.copy(this.target)
    this.object.position.copy(this.position0)
    this.object.zoom = this.zoom0
    this.object.updateProjectionMatrix()
  }

  update() {
    if (!this.enabled) return
    if (this.autoRotate) this.handleAutoRotate()
    if (this.enableKeys) this.keysCheck()
    if (this.enableDamping) this.damping()
    if (this.enableRotate) this.rotate()
    if (this.enableZoom) this.zoom()
    if (this.enablePan) this.pan()
    this.dispatchEvent(this.changeEvent) // Dispatch the event correctly
  }

  handleAutoRotate() {
    if (!this.autoRotate) return
    this.object.position.x -= this.autoRotateSpeed
    this.object.updateProjectionMatrix()
  }

  keysCheck() {
    if (!this.enabled || !this.enableKeys) return
    this.object.position.x -= this.keyPanSpeed
    this.object.updateProjectionMatrix()
    this.dispatchEvent(this.changeEvent)
  }

  pan() {
    if (!this.enabled || !this.enablePan) return
    this.object.position.x -= this.keyPanSpeed
    this.object.updateProjectionMatrix()
    this.dispatchEvent(this.changeEvent)
  }

  rotate() {
    if (!this.enabled || !this.enableRotate) return
    this.object.updateProjectionMatrix()
    this.dispatchEvent(this.changeEvent)
  }

  zoom() {
    if (!this.enabled || !this.enableZoom) return
    this.object.updateProjectionMatrix()
    this.dispatchEvent(this.changeEvent)
  }

  damping() {
    if (!this.enabled || !this.enableDamping) return
    this.object.updateProjectionMatrix()
    this.dispatchEvent(this.changeEvent)
  }
}

--------------------------------------------------------------------------------

Index: 81
File: /Users/cryptskii/client/src/components/ResultContainer.tsx

import { useState, useEffect } from 'react'
import { Address } from '@ton/core'
import { TonClient } from '@ton/ton'
import { BlockchainApiWrapper } from '../api/api'
import {
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuTrigger,
  NavigationMenuContent,
  NavigationMenuLink,
} from './ui/navigation-menu'
import {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
} from '@radix-ui/react-menubar'
export function PipBoyWalletDashboard() {
  const [balances, setBalances] = useState({ checking: '0', savings: '0', custom: '0' })
  const [isDisabled, setIsDisabled] = useState(false)
  const [buttonText, setButtonText] = useState('REFRESH BALANCES')
  const [isLoading, setIsLoading] = useState(false)
  const [systemStatus, setSystemStatus] = useState('OPTIMAL')

  const client = new TonClient({ endpoint: 'https://toncenter.com/api/v2/jsonRPC' })
  const blockchainApi = new BlockchainApiWrapper(client)

  useEffect(() => {
    fetchBalances()
  }, [])

  const fetchBalances = async () => {
    setIsLoading(true)
    try {
      const checkingAddress = Address.parse('EQD...') // Replace with actual addresses
      const savingsAddress = Address.parse('EQD...')
      const customAddress = Address.parse('EQD...')

      const [checkingState, savingsState, customState] = await Promise.all([
        blockchainApi.getAccount(checkingAddress),
        blockchainApi.getAccount(savingsAddress),
        blockchainApi.getAccount(customAddress),
      ])

      setBalances({
        checking: checkingState.balance.toString(),
        savings: savingsState.balance.toString(),
        custom: customState.balance.toString(),
      })

      setSystemStatus('OPTIMAL')
    } catch (error) {
      console.error('Failed to fetch balances:', error)
      setSystemStatus('ERROR')
    } finally {
      setIsLoading(false)
    }
  }

  const handleRefresh = () => {
    setIsDisabled(true)
    setButtonText('REFRESHING...')
    fetchBalances().then(() => {
      setIsDisabled(false)
      setButtonText('REFRESH BALANCES')
    })
  }

  return (
    <div className="container mx-auto p-4">
      <Menubar>
        <MenubarMenu>
          <MenubarTrigger>File</MenubarTrigger>
          <MenubarContent>
            <MenubarItem>New Channel</MenubarItem>
            <MenubarItem>Close Channel</MenubarItem>
          </MenubarContent>
        </MenubarMenu>
        <MenubarMenu>
          <MenubarTrigger>Edit</MenubarTrigger>
          <MenubarContent>
            <MenubarItem>Rename Channel</MenubarItem>
            <MenubarItem>Change Address</MenubarItem>
          </MenubarContent>
        </MenubarMenu>
      </Menubar>

      <NavigationMenu>
        <NavigationMenuList>
          <NavigationMenuItem>
            <NavigationMenuTrigger>Channels</NavigationMenuTrigger>
            <NavigationMenuContent>
              <NavigationMenuLink href="/channels/checking">Checking</NavigationMenuLink>
              <NavigationMenuLink href="/channels/savings">Savings</NavigationMenuLink>
              <NavigationMenuLink href="/channels/custom">Custom</NavigationMenuLink>
            </NavigationMenuContent>
          </NavigationMenuItem>
        </NavigationMenuList>
      </NavigationMenu>

      <header className="text-center mb-8">
        <h1 className="text-4xl font-bold">VAULT-TEC OVERPASS</h1>
        <p className="text-xl">CHANNEL MANAGEMENT SYSTEM</p>
      </header>

      <main className="bg-card text-card-foreground p-6 rounded-lg shadow-lg">
        <h2 className="text-2xl font-bold mb-4">CHANNEL BALANCES</h2>
        <ul className="space-y-2">
          <li className="flex justify-between">
            <span className="uppercase">checking:</span>
            <span className="font-bold">{balances.checking} CAPS</span>
          </li>
          <li className="flex justify-between">
            <span className="uppercase">savings:</span>
            <span className="font-bold">{balances.savings} CAPS</span>
          </li>
          <li className="flex justify-between">
            <span className="uppercase">custom:</span>
            <span className="font-bold">{balances.custom} CAPS</span>
          </li>
        </ul>
        <button
          onClick={handleRefresh}
          disabled={isDisabled}
          className="mt-4 bg-accent text-accent-foreground px-4 py-2 rounded hover:bg-opacity-80 disabled:opacity-50"
        >
          {buttonText}
        </button>
        {isLoading && <div data-testid="loading-indicator">Loading...</div>}
      </main>

      <footer className="text-center mt-8">
        <p>VAULT-TEC CHANNEL STATUS: {systemStatus}</p>
      </footer>
    </div>
  )
}

export default PipBoyWalletDashboard

--------------------------------------------------------------------------------

Index: 82
File: /Users/cryptskii/client/src/components/LoadingSpinner.tsx

// ./src/components/LoadingSpinner.tsx

import React from "react";
import { useTheme } from '../hooks/useTheme';

const LoadingSpinner: React.FC = () => {
    const { theme } = useTheme();
    return (
        <div className={`loading-spinner ${theme}`}>
            <div className="spinner"></div>
        </div>
    );
};

export default LoadingSpinner;
--------------------------------------------------------------------------------

Index: 83
File: /Users/cryptskii/client/src/components/Accounts.tsx

import { useTonWallet } from '@tonconnect/ui-react'
import { Address } from '@ton/core'
import { useQuery } from '@tanstack/react-query'
import { TonClient } from '@ton/ton' // Import TonClient from the 'ton' package
import { formatBalance } from '../utils/formatters'

export default function Accounts() {
  const wallet = useTonWallet() // Access connected wallet details

  // Initialize TonClient with the appropriate endpoint
  const tonClient = new TonClient({ endpoint: 'https://toncenter.com/api/v2/jsonRPC' })

  // Query to fetch the wallet balance
  const {
    data: balance,
    isLoading,
    error,
  } = useQuery({
    enabled: !!wallet, // Enable query only if wallet is connected
    queryKey: ['balance', wallet?.account.address || ''], // Use the address as the query key
    queryFn: async () => {
      if (!wallet?.account.address) return null
      const balance = await tonClient.getBalance(Address.parse(wallet.account.address))
      return balance.toString() // Return balance as string for display
    },
  })

  // Log any errors that occur during the balance fetch
  if (error) {
    console.error(error)
  }

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-r from-blue-500 to-purple-600">
      <div className="bg-white p-8 rounded-lg shadow-xl">
        <h1 className="text-4xl font-bold mb-6 text-center text-gray-800">Account Details</h1>
        {wallet && wallet.account.address ? (
          <div className="space-y-4">
            {/* Address Section */}
            <div className="bg-gray-100 p-4 rounded-md">
              <h2 className="text-xl font-semibold mb-2 text-gray-700">Address</h2>
              <p className="text-sm text-gray-600 break-all">{wallet.account.address}</p>
            </div>
            {/* Balance Section */}
            <div className="bg-gray-100 p-4 rounded-md">
              <h2 className="text-xl font-semibold mb-2 text-gray-700">Balance</h2>
              {isLoading ? (
                <p className="text-sm text-gray-600">Loading...</p>
              ) : balance ? (
                <p className="text-sm text-gray-600">{formatBalance(BigInt(balance))} TON</p>
              ) : (
                <p className="text-sm text-gray-600">Unable to fetch balance</p>
              )}
            </div>
          </div>
        ) : (
          <p className="text-center text-gray-600">
            Please connect your wallet to view account details.
          </p>
        )}
      </div>
    </div>
  )
}

--------------------------------------------------------------------------------

Index: 84
File: /Users/cryptskii/client/src/components/Header.tsx

// ./src/components/Header.tsx
// This is a component that displays the header of the application. It includes a button to navigate to the home page, a button to navigate to the transactions page, and a button to navigate to the accounts page. It also includes a button to connect to the TonConnect wallet and a button to disconnect from the TonConnect wallet. The component uses the useNavigate hook from React Router to navigate to different pages within the application. The useTonConnect hook is used to access the TonConnect wallet and the channelAddress and channelState variables. The showBalance state variable is used to control whether the balance should be displayed or not.

import { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { useTonConnect } from '../hooks/useTonConnect'

const Header = () => {
  const navigate = useNavigate()
  const [showBalance, setShowBalance] = useState(false)
  const { tonConnectUI, channelAddress, channelState } = useTonConnect()

  const connected = tonConnectUI?.connected || false
  const address = channelAddress?.toString() || ''
  const balance = channelState?.balance || 0
  const disconnect = () => tonConnectUI?.disconnect()

  return (
    <header className="flex justify-between items-center p-4 bg-gray-800 text-white">
      <div className="flex items-center">
        <button className="text-white hover:text-gray-300" onClick={() => navigate('/')}>
          Home
        </button>
        <button
          className="text-white hover:text-gray-300"
          onClick={() => navigate('/transactions')}
        >
          Transactions
        </button>
        <button className="text-white hover:text-gray-300" onClick={() => navigate('/accounts')}>
          Accounts
        </button>
        <button className="text-white hover:text-gray-300" onClick={() => navigate('/contracts')}>
          Contracts
        </button>
        <button className="text-white hover:text-gray-300" onClick={() => navigate('/settings')}>
          Settings
        </button>
      </div>
      <div className="flex items-center gap-4">
        <button className="text-white hover:text-gray-300" onClick={() => disconnect()}>
          Disconnect
        </button>
        <button
          className="text-white hover:text-gray-300"
          onClick={() => setShowBalance(!showBalance)}
        >
          {showBalance ? `Hide Balance` : `Show Balance`}
        </button>
      </div>
      {connected && (
        <div className="flex items-center gap-4">
          <div className="flex items-center gap-2">
            <img
              src="https://avatars.githubusercontent.com/u/10198965?v=4"
              alt="TonConnect Logo"
              className="w-8 h-8 rounded-full"
            />
            <span className="text-white">{address}</span>
          </div>
          <div className="flex items-center gap-2">
            <span className="text-white">Balance:</span>
            <span className="text-white">{showBalance ? balance : 'Hidden'}</span>
          </div>
        </div>
      )}
    </header>
  )
}
export default Header

--------------------------------------------------------------------------------

Index: 85
File: /Users/cryptskii/client/src/components/MouseAnimation.tsx

//  src/components/MouseAnimation.tsx
// This component is a React component that animates a mouse cursor based on the user's mouse position. It uses the Framer Motion library to create a smooth animation effect. The component renders a div element with a background color and a border radius. The div element is animated using the motion.div component from Framer Motion. The animation is controlled by the mouseX and mouseY state variables, which are updated based on the user's mouse position. The animation is triggered when the mouse enters the div element. The component also includes a function to reset the animation when the mouse leaves the div element.

import { useState, useCallback } from 'react'
import { motion } from 'framer-motion'

const zigzagKeyframes = [
  { x: 0, y: 0 },
  { x: 0, y: 50 },
  { x: 50, y: 0 },
  { x: 0, y: 0 },
]

const Option = {
  div: motion.div,
}

function RunningMouse({ index }: { index: number }) {
  const [] = useState(false)
  const [isMouseOver] = useState(false)
  const [mouseType, setMouseType] = useState('🐂')

  useCallback(() => {
    if (isMouseOver) {
      setMouseType('🐁')
    } else {
      setMouseType('🐂')
    }
  }, [isMouseOver])

  const generateOffscreenPoint = useCallback(() => {
    const side = Math.floor(Math.random() * 4)
    switch (side) {
      case 0: // Top
        return { x: Math.random() * window.innerWidth, y: -50 }
      case 1: // Right
        return { x: window.innerWidth + 50, y: Math.random() * window.innerHeight }
      case 2: // Bottom
        return { x: Math.random() * window.innerWidth, y: window.innerHeight + 50 }
      case 3: // Left
        return { x: -50, y: Math.random() * window.innerHeight }
    }
    return { x: 0, y: 0 }
  }, [])

  const startPoint = generateOffscreenPoint()

  return (
    <Option.div
      key={index}
      initial={{ x: startPoint.x, y: startPoint.y, opacity: 0 }}
      animate={{
        x: zigzagKeyframes.map((k) => k.x),
        y: zigzagKeyframes.map((k) => k.y),
        opacity: [0, 1, 1, 1, 1, 1, 0],
      }}
      transition={{ duration: 3, ease: 'linear' }}
      className="absolute text-2xl"
    >
      {mouseType}
    </Option.div>
  )
}

export function MouseAnimation() {
  const [isAnimating, setIsAnimating] = useState(false)

  return (
    <div className="fixed bottom-4 right-4 z-50">
      <div
        className="cursor-pointer text-2xl"
        onMouseEnter={() => setIsAnimating(true)}
        onMouseLeave={() => setIsAnimating(false)}
      >
        🐁
      </div>
      {isAnimating && (
        <div className="fixed inset-0 pointer-events-none">
          {[...Array(30)].map((_, index) => (
            <RunningMouse key={index} index={index} />
          ))}
        </div>
      )}
    </div>
  )
}

--------------------------------------------------------------------------------

Index: 86
File: /Users/cryptskii/client/src/components/NavigationLinks.tsx

import {
  Home,
  FolderUp,
  ImagePlus,
  Wallet,
  PenTool,
  FolderEdit,
  UserCog,
  Send,
  FileCode,
  ArrowLeftRight,
} from 'lucide-react'
import { Link } from 'react-router-dom'
import { cn } from '../lib/utils'
import { useState, useEffect } from 'react'
import { useLocation } from 'react-router-dom'
import { ErrorBoundary, FallbackProps } from 'react-error-boundary'
interface NavigationLinksProps {
  currentRoute: string
}

interface LinkItem {
  to?: string
  icon: React.ElementType
  label: string
  children?: LinkItem[]
}

const ErrorFallback = ({ error }: FallbackProps) => (
  <div role="alert">
    <p>Something went wrong:</p>
    <pre>{error.message}</pre>
  </div>
)

export function NavigationLinks({ currentRoute }: NavigationLinksProps) {
  const [links, setLinks] = useState<LinkItem[]>([])
  const location = useLocation()

  useEffect(() => {
    const fetchLinks = async () => {
      try {
        const response = await fetch('/api/navigation-links')
        if (!response.ok) {
          throw new Error('Failed to fetch navigation links')
        }
        const data = await response.json()
        setLinks(data)
      } catch (error) {
        console.error('Error fetching navigation links:', error)
        setLinks([
          { to: '/', icon: Home, label: 'Home' },
          {
            label: 'Content',
            children: [
              { to: '/upload', icon: ImagePlus, label: 'Upload' },
              { to: '/edit', icon: PenTool, label: 'Edit' },
              { to: '/manage', icon: FolderEdit, label: 'Manage' },
            ],
            icon: 'symbol',
          },
          {
            label: 'Account',
            children: [
              { to: '/wallet', icon: Wallet, label: 'Wallet' },
              { to: '/settings', icon: UserCog, label: 'Settings' },
            ],
            icon: 'symbol',
          },
          {
            label: 'Other',
            children: [
              { to: '/deploy-vanity-contract', icon: FileCode, label: 'Deploy Vanity Contract' },
              { to: '/send', icon: Send, label: 'Send' },
              { to: '/transfer', icon: ArrowLeftRight, label: 'Transfer' },
              { to: '/parent-directory', icon: FolderUp, label: 'Parent Directory' },
            ],
            icon: 'symbol',
          },
        ])
      }
    }

    fetchLinks()
  }, [])

  useEffect(() => {
    // Update currentRoute when location changes
    if (location.pathname !== currentRoute) {
      // Assuming you have a way to update currentRoute, e.g., through props or context
      // updateCurrentRoute(location.pathname);
    }
  }, [location, currentRoute])

  const renderLink = (item: LinkItem) => {
    const Icon = item.icon
    return (
      <Link
        to={item.to || '#'}
        className={cn(
          'flex items-center gap-3 rounded-lg px-3 py-2 text-muted-foreground transition-all hover:text-primary',
          currentRoute === item.to ? 'bg-muted text-primary' : ''
        )}
      >
        <Icon className="h-4 w-4" />
        {item.label}
      </Link>
    )
  }

  const renderLinkGroup = (group: LinkItem) => (
    <div className="pb-1">
      <h4 className="mb-1 rounded-md px-2 py-1 text-sm font-medium">{group.label}</h4>
      {group.children?.map((child) => (
        <ErrorBoundary key={child.to} FallbackComponent={ErrorFallback}>
          {renderLink(child)}
        </ErrorBoundary>
      ))}
    </div>
  )

  return (
    <nav>
      {links.map((item) => (
        <ErrorBoundary key={item.to || item.label} FallbackComponent={ErrorFallback}>
          <div>{item.children ? renderLinkGroup(item) : renderLink(item)}</div>
        </ErrorBoundary>
      ))}
    </nav>
  )
}

export default NavigationLinks

--------------------------------------------------------------------------------

Index: 87
File: /Users/cryptskii/client/src/components/ApiSettings.tsx

import { useEffect } from 'react'
import useLocalStorage from 'react-use-localstorage'
import { getTonapi, setTonapiClient, useTonClient } from '../store/tonClient'
import { Switch } from '../components/ui/switch'
import { Label } from '../components/ui/label'

export function ApiSettings() {
  // Store the Testnet state in local storage to persist across sessions
  const [isTestnet, setTestnet] = useLocalStorage('deployerIsTestnet', 'false')
  const tonClient = useTonClient() // Get the Ton client from the context or store

  // Effect to update the API client when the Ton client or network state changes
  useEffect(() => {
    if (tonClient) {
      setTonapiClient(getTonapi(isTestnet === 'true'))
    }
  }, [tonClient, isTestnet])

  // Effect to handle direct changes in the Testnet state toggle
  useEffect(() => {
    setTonapiClient(getTonapi(isTestnet === 'true'))
  }, [isTestnet])

  return (
    <div className="flex items-center space-x-2">
      <Switch
        id="apiTestnetInput"
        checked={isTestnet === 'true'} // Set switch based on isTestnet state
        onCheckedChange={(checked: boolean) => setTestnet(String(checked))} // Toggle Testnet state
      />
      <Label htmlFor="apiTestnetInput">Use Testnet</Label>
    </div>
  )
}

--------------------------------------------------------------------------------

Index: 88
File: /Users/cryptskii/client/src/components/Button.tsx

// src/components/Button.tsx
// This is a component that displays a button with a label and an onClick function. It is used to create buttons for various actions within the application.

import React from 'react'

export interface ButtonProps {
  label: string
  onClick: () => void
}

export const Button: React.FC<ButtonProps> = ({ label, onClick }) => {
  return <button onClick={onClick}>{label}</button>
}

--------------------------------------------------------------------------------

Index: 89
File: /Users/cryptskii/client/src/components/JoinChannel.tsx

import { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { useTonWallet, useTonConnectUI } from '@tonconnect/ui-react'

export default function JoinChannel() {
  const navigate = useNavigate()
  const wallet = useTonWallet()
  const [tonConnectUI] = useTonConnectUI()
  const [showBalance, setShowBalance] = useState(false)

  return (
    <div>
      <button onClick={() => tonConnectUI.connectWallet()}>Connect Wallet</button>
      <button onClick={() => tonConnectUI.disconnect()}>Disconnect Wallet</button>
      <button onClick={() => setShowBalance(!showBalance)}>
        {showBalance ? 'Hide Balance' : 'Show Balance'}
      </button>
      {showBalance && (
        <div>
          <p>Balance: {(wallet as any)?.balance?.toString() ?? 'Loading...'}</p>
        </div>
      )}
      <button onClick={() => navigate('/create-channel')}>Create Channel</button>
      <button onClick={() => navigate('/join-channel')}>Join Channel</button>
      <button onClick={() => navigate('/channels')}>Channels</button>
      <button onClick={() => navigate('/channel-state')}>Channel State</button>
    </div>
  )
}

--------------------------------------------------------------------------------

Index: 90
File: /Users/cryptskii/client/src/components/ui/aspect-ratio.tsx

import * as AspectRatioPrimitive from '@radix-ui/react-aspect-ratio'
const AspectRatio = AspectRatioPrimitive.Root

export { AspectRatio }

--------------------------------------------------------------------------------

Index: 91
File: /Users/cryptskii/client/src/components/ui/use-toast.tsx

// Inspired by react-hot-toast library

import { ToastActionElement, ToastProps } from './toast'

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}
const actionTypes = {
  ADD_TOAST: 'ADD_TOAST',
  UPDATE_TOAST: 'UPDATE_TOAST',
  DISMISS_TOAST: 'DISMISS_TOAST',
  REMOVE_TOAST: 'REMOVE_TOAST',
} as const

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType['ADD_TOAST']
      toast: ToasterToast
    }
  | {
      type: ActionType['UPDATE_TOAST']
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType['DISMISS_TOAST']
      toastId?: ToasterToast['id']
    }
  | {
      type: ActionType['REMOVE_TOAST']
      toastId?: ToasterToast['id']
    }

interface State {
  toasts: ToasterToast[]
}

const TOAST_LIMIT = 5

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case 'ADD_TOAST':
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }
    // Add other cases here
    default:
      return state
  }
}

--------------------------------------------------------------------------------

Index: 92
File: /Users/cryptskii/client/src/components/ui/alert-dialog.tsx

import * as React from 'react'
import * as AlertDialogPrimitive from '@radix-ui/react-alert-dialog'

import { cn } from '../../lib/utils'
import { buttonVariants } from './button'
import { AlertDialogProps } from '@radix-ui/react-alert-dialog'

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      'fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        'fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg',
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn('flex flex-col space-y-2 text-center sm:text-left', className)} {...props} />
)
AlertDialogHeader.displayName = 'AlertDialogHeader'

const AlertDialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn('flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2', className)}
    {...props}
  />
)
AlertDialogFooter.displayName = 'AlertDialogFooter'

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn('text-lg font-semibold', className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
))
AlertDialogDescription.displayName = AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action ref={ref} className={cn(buttonVariants(), className)} {...props} />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(buttonVariants({ variant: 'outline' }), 'mt-2 sm:mt-0', className)}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}

export type { AlertDialogProps }

--------------------------------------------------------------------------------

Index: 93
File: /Users/cryptskii/client/src/components/ui/pagination.tsx

import * as React from 'react'
import { ChevronLeftIcon, ChevronRightIcon, DotsHorizontalIcon } from '@radix-ui/react-icons'

import { cn } from '../../lib/utils'
import { ButtonProps, buttonVariants } from '../ui/button'

const Pagination = ({ className, ...props }: React.ComponentProps<'nav'>) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn('mx-auto flex w-full justify-center', className)}
    {...props}
  />
)
Pagination.displayName = 'Pagination'

const PaginationContent = React.forwardRef<HTMLUListElement, React.ComponentProps<'ul'>>(
  ({ className, ...props }, ref) => (
    <ul ref={ref} className={cn('flex flex-row items-center gap-1', className)} {...props} />
  )
)
PaginationContent.displayName = 'PaginationContent'

const PaginationItem = React.forwardRef<HTMLLIElement, React.ComponentProps<'li'>>(
  ({ className, ...props }, ref) => <li ref={ref} className={cn('', className)} {...props} />
)
PaginationItem.displayName = 'PaginationItem'

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, 'size'> &
  React.ComponentProps<'a'>

const PaginationLink = ({ className, isActive, size = 'icon', ...props }: PaginationLinkProps) => (
  <a
    aria-current={isActive ? 'page' : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? 'outline' : 'ghost',
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = 'PaginationLink'

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn('gap-1 pl-2.5', className)}
    {...props}
  >
    <ChevronLeftIcon className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = 'PaginationPrevious'

const PaginationNext = ({ className, ...props }: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn('gap-1 pr-2.5', className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRightIcon className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = 'PaginationNext'

const PaginationEllipsis = ({ className, ...props }: React.ComponentProps<'span'>) => (
  <span
    aria-hidden
    className={cn('flex h-9 w-9 items-center justify-center', className)}
    {...props}
  >
    <DotsHorizontalIcon className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = 'PaginationEllipsis'

export {
  Pagination,
  PaginationContent,
  PaginationLink,
  PaginationItem,
  PaginationPrevious,
  PaginationNext,
  PaginationEllipsis,
}

--------------------------------------------------------------------------------

Index: 94
File: /Users/cryptskii/client/src/components/ui/tabs.tsx

import * as React from 'react'
import * as TabsPrimitive from '@radix-ui/react-tabs'

import { cn } from '../../lib/utils'

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      'inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground',
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      'inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow',
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      'mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2',
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

--------------------------------------------------------------------------------

Index: 95
File: /Users/cryptskii/client/src/components/ui/card.tsx

import * as React from 'react'

import { cn } from '../../lib/utils'

const Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn('rounded-xl border bg-card text-card-foreground shadow', className)}
      {...props}
    />
  )
)
Card.displayName = 'Card'

const CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn('flex flex-col space-y-1.5 p-6', className)} {...props} />
  )
)
CardHeader.displayName = 'CardHeader'

const CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(
  ({ className, ...props }, ref) => (
    <h3
      ref={ref}
      className={cn('font-semibold leading-none tracking-tight', className)}
      {...props}
    />
  )
)
CardTitle.displayName = 'CardTitle'

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p ref={ref} className={cn('text-sm text-muted-foreground', className)} {...props} />
))
CardDescription.displayName = 'CardDescription'

const CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn('p-6 pt-0', className)} {...props} />
  )
)
CardContent.displayName = 'CardContent'

const CardFooter = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn('flex items-center p-6 pt-0', className)} {...props} />
  )
)
CardFooter.displayName = 'CardFooter'

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

--------------------------------------------------------------------------------

Index: 96
File: /Users/cryptskii/client/src/components/ui/slider.tsx

import * as React from 'react'
import * as SliderPrimitive from '@radix-ui/react-slider'

import { cn } from '../../lib/utils'

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn('relative flex w-full touch-none select-none items-center', className)}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-1.5 w-full grow overflow-hidden rounded-full bg-primary/20">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-4 w-4 rounded-full border border-primary/50 bg-background shadow transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }

--------------------------------------------------------------------------------

Index: 97
File: /Users/cryptskii/client/src/components/ui/popover.tsx

import * as React from 'react'
import * as PopoverPrimitive from '@radix-ui/react-popover'

import { cn } from '../../lib/utils'

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverAnchor = PopoverPrimitive.Anchor

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = 'center', sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        'z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }

--------------------------------------------------------------------------------

Index: 98
File: /Users/cryptskii/client/src/components/ui/progress.tsx

import * as React from 'react'
import * as ProgressPrimitive from '@radix-ui/react-progress'
import { cn } from '../../lib/utils'

interface ProgressProps extends React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root> {
  value?: number
}

const Progress = React.forwardRef<React.ElementRef<typeof ProgressPrimitive.Root>, ProgressProps>(
  ({ className, value, ...props }, ref) => {
    const clampedValue = React.useMemo(() => Math.min(Math.max(value || 0, 0), 100), [value])

    return (
      <ProgressPrimitive.Root
        ref={ref}
        className={cn('relative h-2 w-full overflow-hidden rounded-full bg-primary/20', className)}
        {...props}
      >
        <ProgressPrimitive.Indicator
          className="h-full w-full flex-1 bg-primary transition-all"
          style={{ transform: `translateX(-${100 - clampedValue}%)` }}
        />
      </ProgressPrimitive.Root>
    )
  }
)

Progress.displayName = 'Progress'

export { Progress, type ProgressProps }

--------------------------------------------------------------------------------

Index: 99
File: /Users/cryptskii/client/src/components/ui/toaster.tsx

import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from '../ui/toast'
import { useToast } from '../ui/use-toast'

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && <ToastDescription>{description}</ToastDescription>}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}

--------------------------------------------------------------------------------

Index: 100
File: /Users/cryptskii/client/src/components/ui/input-otp.tsx

import * as React from 'react'
import { DashIcon } from '@radix-ui/react-icons'
import { OTPInput, OTPInputContext } from 'input-otp'
import { cn } from '../../lib/utils'

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      'flex items-center gap-2 has-[:disabled]:opacity-50',
      containerClassName
    )}
    className={cn('disabled:cursor-not-allowed', className)}
    {...props}
  />
))
InputOTP.displayName = 'InputOTP'

const InputOTPGroup = React.forwardRef<
  React.ElementRef<'div'>,
  React.ComponentPropsWithoutRef<'div'>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn('flex items-center', className)} {...props} />
))
InputOTPGroup.displayName = 'InputOTPGroup'

interface InputOTPSlotProps extends React.ComponentPropsWithoutRef<'div'> {
  index: number
}

const InputOTPSlot = React.forwardRef<React.ElementRef<'div'>, InputOTPSlotProps>(
  ({ index, className, ...props }, ref) => {
    const inputOTPContext = React.useContext(OTPInputContext)
    if (!inputOTPContext) {
      throw new Error('InputOTPSlot must be used within an InputOTP component')
    }
    const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index] || {}

    return (
      <div
        ref={ref}
        className={cn(
          'relative flex h-9 w-9 items-center justify-center border-y border-r border-input text-sm shadow-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md',
          isActive && 'z-10 ring-1 ring-ring',
          className
        )}
        {...props}
      >
        {char}
        {hasFakeCaret && (
          <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
            <div className="h-4 w-px animate-caret-blink bg-foreground duration-1000" />
          </div>
        )}
      </div>
    )
  }
)
InputOTPSlot.displayName = 'InputOTPSlot'

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<'div'>,
  React.ComponentPropsWithoutRef<'div'>
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <DashIcon />
  </div>
))
InputOTPSeparator.displayName = 'InputOTPSeparator'

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }

--------------------------------------------------------------------------------

Index: 101
File: /Users/cryptskii/client/src/components/ui/hover-card.tsx

import * as React from 'react'
import * as HoverCardPrimitive from '@radix-ui/react-hover-card'

import { cn } from '../../lib/utils'

const HoverCard = HoverCardPrimitive.Root

const HoverCardTrigger = HoverCardPrimitive.Trigger

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = 'center', sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      'z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className
    )}
    {...props}
  />
))
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName

export { HoverCard, HoverCardTrigger, HoverCardContent }

--------------------------------------------------------------------------------

Index: 102
File: /Users/cryptskii/client/src/components/ui/sheet.tsx

import * as React from 'react'
import * as SheetPrimitive from '@radix-ui/react-dialog'
import { Cross2Icon } from '@radix-ui/react-icons'
import { cva, type VariantProps } from 'class-variance-authority'

import { cn } from '../../lib/utils'

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      'fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  'fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500',
  {
    variants: {
      side: {
        top: 'inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top',
        bottom:
          'inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom',
        left: 'inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm',
        right:
          'inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm',
      },
    },
    defaultVariants: {
      side: 'right',
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = 'right', className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content ref={ref} className={cn(sheetVariants({ side }), className)} {...props}>
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <Cross2Icon className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn('flex flex-col space-y-2 text-center sm:text-left', className)} {...props} />
)
SheetHeader.displayName = 'SheetHeader'

const SheetFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn('flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2', className)}
    {...props}
  />
)
SheetFooter.displayName = 'SheetFooter'

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn('text-lg font-semibold text-foreground', className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}

--------------------------------------------------------------------------------

Index: 103
File: /Users/cryptskii/client/src/components/ui/scroll-area.tsx

import * as React from 'react'
import * as ScrollAreaPrimitive from '@radix-ui/react-scroll-area'

import { cn } from '../../lib/utils'

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn('relative overflow-hidden', className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = 'vertical', ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      'flex touch-none select-none transition-colors',
      orientation === 'vertical' && 'h-full w-2.5 border-l border-l-transparent p-[1px]',
      orientation === 'horizontal' && 'h-2.5 flex-col border-t border-t-transparent p-[1px]',
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }

--------------------------------------------------------------------------------

Index: 104
File: /Users/cryptskii/client/src/components/ui/resizable.tsx

import { DragHandleDots2Icon } from '@radix-ui/react-icons'
import * as ResizablePrimitive from 'react-resizable-panels'

import { cn } from '../../lib/utils'

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn('flex h-full w-full data-[panel-group-direction=vertical]:flex-col', className)}
    {...props}
  />
)

const ResizablePanel = ResizablePrimitive.Panel

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      'relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90',
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <DragHandleDots2Icon className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
)

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }

--------------------------------------------------------------------------------

Index: 105
File: /Users/cryptskii/client/src/components/ui/label.tsx

import * as React from 'react'
import * as LabelPrimitive from '@radix-ui/react-label'
import { cva, type VariantProps } from 'class-variance-authority'

import { cn } from '../../lib/utils'

const labelVariants = cva(
  'text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70'
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> & VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root ref={ref} className={cn(labelVariants(), className)} {...props} />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

--------------------------------------------------------------------------------

Index: 106
File: /Users/cryptskii/client/src/components/ui/sonner.tsx

import { useTheme } from 'next-themes'
import { Toaster as Sonner } from 'sonner'

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = 'system' } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps['theme']}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            'group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg',
          description: 'group-[.toast]:text-muted-foreground',
          actionButton: 'group-[.toast]:bg-primary group-[.toast]:text-primary-foreground',
          cancelButton: 'group-[.toast]:bg-muted group-[.toast]:text-muted-foreground',
        },
      }}
      {...props}
    />
  )
}

export { Toaster }

--------------------------------------------------------------------------------

Index: 107
File: /Users/cryptskii/client/src/components/ui/navigation-menu.tsx

import * as React from 'react';
import { ChevronDownIcon } from '@radix-ui/react-icons';
import * as NavigationMenuPrimitive from '@radix-ui/react-navigation-menu';
import { cn } from '@/lib/utils';
import { cva } from 'class-variance-authority';

// Base Navigation Menu Component
const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn('relative z-10 flex max-w-max flex-1 items-center justify-center', className)}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
));
NavigationMenu.displayName = 'NavigationMenu';

// Navigation Menu List Component
const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn('group flex flex-1 list-none items-center justify-center space-x-1', className)}
    {...props}
  />
));
NavigationMenuList.displayName = 'NavigationMenuList';

// Navigation Menu Item Component
const NavigationMenuItem = NavigationMenuPrimitive.Item;

// Navigation Menu Trigger Component with styling
const navigationMenuTriggerStyle = cva(
  'group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50'
);

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), 'group', className)}
    {...props}
  >
    {children}
    <ChevronDownIcon
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-300 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
));
NavigationMenuTrigger.displayName = 'NavigationMenuTrigger';

// Navigation Menu Content Component
const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      'left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto',
      className
    )}
    {...props}
  />
));
NavigationMenuContent.displayName = 'NavigationMenuContent';

// Navigation Menu Link Component
const NavigationMenuLink = NavigationMenuPrimitive.Link;

// Navigation Menu Viewport Component
const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn('absolute left-0 top-full flex justify-center')}>
    <NavigationMenuPrimitive.Viewport
      ref={ref}
      className={cn(
        'origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]',
        className
      )}
      {...props}
    />
  </div>
));
NavigationMenuViewport.displayName = 'NavigationMenuViewport';

// Navigation Menu Indicator Component
const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      'top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in',
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
));
NavigationMenuIndicator.displayName = 'NavigationMenuIndicator';

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
};
--------------------------------------------------------------------------------

Index: 108
File: /Users/cryptskii/client/src/components/ui/accordion.tsx

import * as React from 'react'
import * as AccordionPrimitive from '@radix-ui/react-accordion'
import { ChevronDownIcon } from '@radix-ui/react-icons'

import { cn } from '../../lib/utils'

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item ref={ref} className={cn('border-b', className)} {...props} />
))
AccordionItem.displayName = 'AccordionItem'

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        'flex flex-1 items-center justify-between py-4 text-sm font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180',
        className
      )}
      {...props}
    >
      {children}
      <ChevronDownIcon className="h-4 w-4 shrink-0 text-muted-foreground transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn('pb-4 pt-0', className)}>{children}</div>
  </AccordionPrimitive.Content>
))
AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }

--------------------------------------------------------------------------------

Index: 109
File: /Users/cryptskii/client/src/components/ui/drawer.tsx

import * as React from 'react'
import * as DrawerPrimitive from '@radix-ui/react-dialog'
import { cn } from '../../lib/utils'

const Drawer = ({ ...props }: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root {...props} />
)
Drawer.displayName = 'Drawer'

const DrawerTrigger = DrawerPrimitive.Trigger

const DrawerPortal = DrawerPrimitive.Portal

const DrawerClose = DrawerPrimitive.Close

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn('fixed inset-0 z-50 bg-black/80', className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        'fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background',
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = 'DrawerContent'

const DrawerHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn('grid gap-1.5 p-4 text-center sm:text-left', className)} {...props} />
)
DrawerHeader.displayName = 'DrawerHeader'

const DrawerFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn('mt-auto flex flex-col gap-2 p-4', className)} {...props} />
)
DrawerFooter.displayName = 'DrawerFooter'

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn('text-lg font-semibold leading-none tracking-tight', className)}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}

--------------------------------------------------------------------------------

Index: 110
File: /Users/cryptskii/client/src/components/ui/menubar-item.tsx

import * as React from 'react'
import * as MenubarPrimitive from '@radix-ui/react-menubar'

import { cn } from '../../lib/utils'

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName

--------------------------------------------------------------------------------

Index: 111
File: /Users/cryptskii/client/src/components/ui/tooltip.tsx

import * as React from 'react'
import * as TooltipPrimitive from '@radix-ui/react-tooltip'

import { cn } from '../../lib/utils'

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      'z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

--------------------------------------------------------------------------------

Index: 112
File: /Users/cryptskii/client/src/components/ui/alert.tsx

import * as React from 'react'
import { cva, type VariantProps } from 'class-variance-authority'

import { cn } from '../../lib/utils'

const alertVariants = cva(
  'relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7',
  {
    variants: {
      variant: {
        default: 'bg-background text-foreground',
        destructive:
          'border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div ref={ref} role="alert" className={cn(alertVariants({ variant }), className)} {...props} />
))
Alert.displayName = 'Alert'

const AlertTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(
  ({ className, ...props }, ref) => (
    <h5
      ref={ref}
      className={cn('mb-1 font-medium leading-none tracking-tight', className)}
      {...props}
    />
  )
)
AlertTitle.displayName = 'AlertTitle'

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn('text-sm [&_p]:leading-relaxed', className)} {...props} />
))
AlertDescription.displayName = 'AlertDescription'

export { Alert, AlertTitle, AlertDescription }

--------------------------------------------------------------------------------

Index: 113
File: /Users/cryptskii/client/src/components/ui/use-toast.ts

// Inspired by react-hot-toast library
import * as React from 'react'

import type { ToastActionElement, ToastProps } from '../ui/toast'

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: 'ADD_TOAST',
  UPDATE_TOAST: 'UPDATE_TOAST',
  DISMISS_TOAST: 'DISMISS_TOAST',
  REMOVE_TOAST: 'REMOVE_TOAST',
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType['ADD_TOAST']
      toast: ToasterToast
    }
  | {
      type: ActionType['UPDATE_TOAST']
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType['DISMISS_TOAST']
      toastId?: ToasterToast['id']
    }
  | {
      type: ActionType['REMOVE_TOAST']
      toastId?: ToasterToast['id']
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: 'REMOVE_TOAST',
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case 'ADD_TOAST':
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case 'UPDATE_TOAST':
      return {
        ...state,
        toasts: state.toasts.map((t) => (t.id === action.toast.id ? { ...t, ...action.toast } : t)),
      }

    case 'DISMISS_TOAST': {
      const { toastId } = action

      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case 'REMOVE_TOAST':
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, 'id'>

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: 'UPDATE_TOAST',
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: 'DISMISS_TOAST', toastId: id })

  dispatch({
    type: 'ADD_TOAST',
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: 'DISMISS_TOAST', toastId }),
  }
}

export { useToast, toast }
--------------------------------------------------------------------------------

Index: 114
File: /Users/cryptskii/client/src/components/ui/switch.tsx

import * as React from 'react'
import * as SwitchPrimitives from '@radix-ui/react-switch'

import { cn } from '../../lib/utils'

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      'peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input',
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        'pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0'
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }

--------------------------------------------------------------------------------

Index: 115
File: /Users/cryptskii/client/src/components/ui/calendar.tsx

import * as React from 'react'
import { DayPicker } from 'react-day-picker'

import { cn } from '../../lib/utils'
import { buttonVariants } from '../../components/ui/button'
export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({ className, classNames, showOutsideDays = true, ...props }: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn('p-3', className)}
      classNames={{
        months: 'flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0',
        month: 'space-y-4',
        caption: 'flex justify-center pt-1 relative items-center',
        caption_label: 'text-sm font-medium',
        nav: 'space-x-1 flex items-center',
        nav_button: cn(
          buttonVariants({ variant: 'outline' }),
          'h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100'
        ),
        nav_button_previous: 'absolute left-1',
        nav_button_next: 'absolute right-1',
        table: 'w-full border-collapse space-y-1',
        head_row: 'flex',
        head_cell: 'text-muted-foreground rounded-md w-8 font-normal text-[0.8rem]',
        row: 'flex w-full mt-2',
        cell: cn(
          'relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([aria-selected])]:bg-accent [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected].day-range-end)]:rounded-r-md',
          props.mode === 'range'
            ? '[&:has(>.day-range-end)]:rounded-r-md [&:has(>.day-range-start)]:rounded-l-md first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md'
            : '[&:has([aria-selected])]:rounded-md'
        ),
        day: cn(
          buttonVariants({ variant: 'ghost' }),
          'h-8 w-8 p-0 font-normal aria-selected:opacity-100'
        ),
        day_range_start: 'day-range-start',
        day_range_end: 'day-range-end',
        day_selected:
          'bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground',
        day_today: 'bg-accent text-accent-foreground',
        day_outside:
          'day-outside text-muted-foreground opacity-50  aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30',
        day_disabled: 'text-muted-foreground opacity-50',
        day_range_middle: 'aria-selected:bg-accent aria-selected:text-accent-foreground',
        day_hidden: 'invisible',
        ...classNames,
      }}
      {...props}
    />
  )
}

export { Calendar }

--------------------------------------------------------------------------------

Index: 116
File: /Users/cryptskii/client/src/components/ui/breadcrumb.tsx

import * as React from 'react'
import { ChevronRightIcon, DotsHorizontalIcon } from '@radix-ui/react-icons'
import { Slot } from '@radix-ui/react-slot'

import { cn } from '../../lib/utils'

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<'nav'> & {
    separator?: React.ReactNode
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = 'Breadcrumb'

const BreadcrumbList = React.forwardRef<HTMLOListElement, React.ComponentPropsWithoutRef<'ol'>>(
  ({ className, ...props }, ref) => (
    <ol
      ref={ref}
      className={cn(
        'flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5',
        className
      )}
      {...props}
    />
  )
)
BreadcrumbList.displayName = 'BreadcrumbList'

const BreadcrumbItem = React.forwardRef<HTMLLIElement, React.ComponentPropsWithoutRef<'li'>>(
  ({ className, ...props }, ref) => (
    <li ref={ref} className={cn('inline-flex items-center gap-1.5', className)} {...props} />
  )
)
BreadcrumbItem.displayName = 'BreadcrumbItem'

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<'a'> & {
    asChild?: boolean
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : 'a'

  return (
    <Comp
      ref={ref}
      className={cn('transition-colors hover:text-foreground', className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = 'BreadcrumbLink'

const BreadcrumbPage = React.forwardRef<HTMLSpanElement, React.ComponentPropsWithoutRef<'span'>>(
  ({ className, ...props }, ref) => (
    <span
      ref={ref}
      role="link"
      aria-disabled="true"
      aria-current="page"
      className={cn('font-normal text-foreground', className)}
      {...props}
    />
  )
)
BreadcrumbPage.displayName = 'BreadcrumbPage'

const BreadcrumbSeparator = ({ children, className, ...props }: React.ComponentProps<'li'>) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn('[&>svg]:size-3.5', className)}
    {...props}
  >
    {children ?? <ChevronRightIcon />}
  </li>
)
BreadcrumbSeparator.displayName = 'BreadcrumbSeparator'

const BreadcrumbEllipsis = ({ className, ...props }: React.ComponentProps<'span'>) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn('flex h-9 w-9 items-center justify-center', className)}
    {...props}
  >
    <DotsHorizontalIcon className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = 'BreadcrumbElipssis'

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}

--------------------------------------------------------------------------------

Index: 117
File: /Users/cryptskii/client/src/components/ui/radio-group.tsx

import * as React from 'react'
import { CheckIcon } from '@radix-ui/react-icons'
import * as RadioGroupPrimitive from '@radix-ui/react-radio-group'

import { cn } from '../../lib/utils'

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return <RadioGroupPrimitive.Root className={cn('grid gap-2', className)} {...props} ref={ref} />
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        'aspect-square h-4 w-4 rounded-full border border-primary text-primary shadow focus:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50',
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <CheckIcon className="h-3.5 w-3.5 fill-primary" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }

--------------------------------------------------------------------------------

Index: 118
File: /Users/cryptskii/client/src/components/ui/command.tsx

import * as React from 'react'
import { type DialogProps } from '@radix-ui/react-dialog'
import { MagnifyingGlassIcon } from '@radix-ui/react-icons'
import { Command as CommandPrimitive } from 'cmdk'

import { cn } from '../../lib/utils'
import { Dialog, DialogContent } from '../ui/dialog'

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      'flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground',
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

interface CommandDialogProps extends DialogProps {}

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <MagnifyingGlassIcon className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        'flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50',
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn('max-h-[300px] overflow-y-auto overflow-x-hidden', className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty ref={ref} className="py-6 text-center text-sm" {...props} />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      'overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground',
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 h-px bg-border', className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50',
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn('ml-auto text-xs tracking-widest text-muted-foreground', className)}
      {...props}
    />
  )
}
CommandShortcut.displayName = 'CommandShortcut'

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}

--------------------------------------------------------------------------------

Index: 119
File: /Users/cryptskii/client/src/components/ui/toggle-group.tsx

import * as React from 'react'
import * as ToggleGroupPrimitive from '@radix-ui/react-toggle-group'
import { VariantProps } from 'class-variance-authority'

import { cn } from '../../lib/utils'
import { toggleVariants } from '../ui/toggle'

const ToggleGroupContext = React.createContext<VariantProps<typeof toggleVariants>>({
  size: 'default',
  variant: 'default',
})

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn('flex items-center justify-center gap-1', className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>{children}</ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }

--------------------------------------------------------------------------------

Index: 120
File: /Users/cryptskii/client/src/components/ui/avatar.tsx

import * as React from 'react'
import * as AvatarPrimitive from '@radix-ui/react-avatar'

import { cn } from '../../lib/utils'

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn('relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full', className)}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn('aspect-square h-full w-full', className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      'flex h-full w-full items-center justify-center rounded-full bg-muted',
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }

--------------------------------------------------------------------------------

Index: 121
File: /Users/cryptskii/client/src/components/ui/menubar.tsx

  import * as React from 'react';
  import { CheckIcon, ChevronRightIcon, DotFilledIcon } from '@radix-ui/react-icons';
  import * as MenubarPrimitive from '@radix-ui/react-menubar';
  import { cn } from '../../lib/utils';

  // Menubar Root Component
  const Menubar = React.forwardRef<
    React.ElementRef<typeof MenubarPrimitive.Root>,
    React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
  >(({ className, ...props }, ref) => (
    <MenubarPrimitive.Root
      ref={ref}
      className={cn('flex h-9 items-center space-x-1 rounded-md border bg-background p-1 shadow-sm', className)}
      {...props}
    />
  ));
  Menubar.displayName = 'Menubar';

  // Menubar Trigger Component
  const MenubarTrigger = React.forwardRef<
    React.ElementRef<typeof MenubarPrimitive.Trigger>,
    React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
  >(({ className, ...props }, ref) => (
    <MenubarPrimitive.Trigger
      ref={ref}
      className={cn('flex cursor-default select-none items-center rounded-sm px-3 py-1 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground', className)}
      {...props}
    />
  ));
  MenubarTrigger.displayName = 'MenubarTrigger';

  // Menubar SubTrigger Component
  const MenubarSubTrigger = React.forwardRef<
    React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
    React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & { inset?: boolean }
  >(({ className, inset, children, ...props }, ref) => (
    <MenubarPrimitive.SubTrigger
      ref={ref}
      className={cn('flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground', inset && 'pl-8', className)}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto h-4 w-4" />
    </MenubarPrimitive.SubTrigger>
  ));
  MenubarSubTrigger.displayName = 'MenubarSubTrigger';

  // Menubar SubContent Component
  const MenubarSubContent = React.forwardRef<
    React.ElementRef<typeof MenubarPrimitive.SubContent>,
    React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
  >(({ className, ...props }, ref) => (
    <MenubarPrimitive.SubContent
      ref={ref}
      className={cn('z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out', className)}
      {...props}
    />
  ));
  MenubarSubContent.displayName = 'MenubarSubContent';

  // Menubar Content Component
  const MenubarContent = React.forwardRef<
    React.ElementRef<typeof MenubarPrimitive.Content>,
    React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
  >(({ className, align = 'start', alignOffset = -4, sideOffset = 8, ...props }, ref) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn('z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95', className)}
        {...props}
      />
    </MenubarPrimitive.Portal>
  ));
  MenubarContent.displayName = 'MenubarContent';

  // Menubar Item Component
  const MenubarItem = React.forwardRef<
    React.ElementRef<typeof MenubarPrimitive.Item>,
    React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & { inset?: boolean }
  >(({ className, inset, ...props }, ref) => (
    <MenubarPrimitive.Item
      ref={ref}
      className={cn('relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50', inset && 'pl-8', className)}
      {...props}
    />
  ));
  MenubarItem.displayName = 'MenubarItem';

  // Menubar Checkbox Item Component
  const MenubarCheckboxItem = React.forwardRef<
    React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
    React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
  >(({ className, children, checked, ...props }, ref) => (
    <MenubarPrimitive.CheckboxItem
      ref={ref}
      className={cn('relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50', className)}
      checked={checked}
      {...props}
    >
      <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
        <MenubarPrimitive.ItemIndicator>
          <CheckIcon className="h-4 w-4" />
        </MenubarPrimitive.ItemIndicator>
      </span>
      {children}
    </MenubarPrimitive.CheckboxItem>
  ));
  MenubarCheckboxItem.displayName = 'MenubarCheckboxItem';

  // Menubar Radio Item Component
  const MenubarRadioItem = React.forwardRef<
    React.ElementRef<typeof MenubarPrimitive.RadioItem>,
    React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
  >(({ className, children, ...props }, ref) => (
    <MenubarPrimitive.RadioItem
      ref={ref}
      className={cn('relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50', className)}
      {...props}
    >
      <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
        <MenubarPrimitive.ItemIndicator>
          <DotFilledIcon className="h-4 w-4 fill-current" />
        </MenubarPrimitive.ItemIndicator>
      </span>
      {children}
    </MenubarPrimitive.RadioItem>
  ));
  MenubarRadioItem.displayName = 'MenubarRadioItem';

  // Menubar Label Component
  const MenubarLabel = React.forwardRef<
    React.ElementRef<typeof MenubarPrimitive.Label>,
    React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & { inset?: boolean }
  >(({ className, inset, ...props }, ref) => (
    <MenubarPrimitive.Label
      ref={ref}
      className={cn('px-2 py-1.5 text-sm font-semibold', inset && 'pl-8', className)}
      {...props}
    />
  ));
  MenubarLabel.displayName = 'MenubarLabel';

  // Menubar Separator Component
  const MenubarSeparator = React.forwardRef<
    React.ElementRef<typeof MenubarPrimitive.Separator>,
    React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
  >(({ className, ...props }, ref) => (
    <MenubarPrimitive.Separator
      ref={ref}
      className={cn('-mx-1 my-1 h-px bg-muted', className)}
      {...props}
    />
  ));
  MenubarSeparator.displayName = 'MenubarSeparator';

  // Menubar Shortcut Component
  const MenubarShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => (
    <span className={cn('ml-auto text-xs tracking-widest text-muted-foreground', className)} {...props} />
  );
  MenubarShortcut.displayName = 'MenubarShortcut';

  export {
    Menubar,
    MenubarTrigger,
    MenubarContent,
    MenubarItem,
    MenubarSeparator,
    MenubarLabel,
    MenubarCheckboxItem,
    MenubarRadioItem,
    MenubarSubContent,
    MenubarSubTrigger,
    MenubarShortcut
  }
--------------------------------------------------------------------------------

Index: 122
File: /Users/cryptskii/client/src/components/ui/dialog.tsx

import * as React from 'react'
import * as DialogPrimitive from '@radix-ui/react-dialog'
import { Cross2Icon } from '@radix-ui/react-icons'

import { cn } from '../../lib/utils'

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      'fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        'fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg',
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <Cross2Icon className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn('flex flex-col space-y-1.5 text-center sm:text-left', className)} {...props} />
)
DialogHeader.displayName = 'DialogHeader'

const DialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn('flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2', className)}
    {...props}
  />
)
DialogFooter.displayName = 'DialogFooter'

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn('text-lg font-semibold leading-none tracking-tight', className)}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

--------------------------------------------------------------------------------

Index: 123
File: /Users/cryptskii/client/src/components/ui/menu.tsx

import * as React from 'react'
import * as MenuPrimitive from '@radix-ui/react-menu'

import { cn } from '../../lib/utils'

const MenuContent = React.forwardRef<
  React.ElementRef<typeof MenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenuPrimitive.Content>
>(({ className, align = 'center', sideOffset = 4, ...props }, ref) => (
  <MenuPrimitive.Portal>
    <MenuPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        'animate-in data-[side=right]:slide-in-from-left-2 data-[side=left]:slide-in-from-right-2 data-[side=bottom]:slide-in-from-top-2 data-[side=top]:slide-in-from-bottom-2',
        className
      )}
      {...props}
    />
  </MenuPrimitive.Portal>
))
MenuContent.displayName = MenuPrimitive.Content.displayName

const MenuItem = React.forwardRef<
  React.ElementRef<typeof MenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenuPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
))
MenuItem.displayName = MenuPrimitive.Item.displayName

--------------------------------------------------------------------------------

Index: 124
File: /Users/cryptskii/client/src/components/ui/badge.tsx

import * as React from 'react'
import { cva, type VariantProps } from 'class-variance-authority'

import { cn } from '../../lib/utils'

const badgeVariants = cva(
  'inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2',
  {
    variants: {
      variant: {
        default: 'border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80',
        secondary:
          'border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80',
        destructive:
          'border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80',
        outline: 'text-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return <div className={cn(badgeVariants({ variant }), className)} {...props} />
}

export { Badge, badgeVariants }

--------------------------------------------------------------------------------

Index: 125
File: /Users/cryptskii/client/src/components/ui/table.tsx

import * as React from 'react'

import { cn } from '../../lib/utils'

const Table = React.forwardRef<HTMLTableElement, React.HTMLAttributes<HTMLTableElement>>(
  ({ className, ...props }, ref) => (
    <div className="relative w-full overflow-auto">
      <table ref={ref} className={cn('w-full caption-bottom text-sm', className)} {...props} />
    </div>
  )
)
Table.displayName = 'Table'

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn('[&_tr]:border-b', className)} {...props} />
))
TableHeader.displayName = 'TableHeader'

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody ref={ref} className={cn('[&_tr:last-child]:border-0', className)} {...props} />
))
TableBody.displayName = 'TableBody'

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn('border-t bg-muted/50 font-medium [&>tr]:last:border-b-0', className)}
    {...props}
  />
))
TableFooter.displayName = 'TableFooter'

const TableRow = React.forwardRef<HTMLTableRowElement, React.HTMLAttributes<HTMLTableRowElement>>(
  ({ className, ...props }, ref) => (
    <tr
      ref={ref}
      className={cn(
        'border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted',
        className
      )}
      {...props}
    />
  )
)
TableRow.displayName = 'TableRow'

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      'h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]',
      className
    )}
    {...props}
  />
))
TableHead.displayName = 'TableHead'

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      'p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]',
      className
    )}
    {...props}
  />
))
TableCell.displayName = 'TableCell'

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption ref={ref} className={cn('mt-4 text-sm text-muted-foreground', className)} {...props} />
))
TableCaption.displayName = 'TableCaption'

export { Table, TableHeader, TableBody, TableFooter, TableHead, TableRow, TableCell, TableCaption }

--------------------------------------------------------------------------------

Index: 126
File: /Users/cryptskii/client/src/components/ui/separator.tsx

import * as React from 'react'
import * as SeparatorPrimitive from '@radix-ui/react-separator'

import { cn } from '../../lib/utils'

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(({ className, orientation = 'horizontal', decorative = true, ...props }, ref) => (
  <SeparatorPrimitive.Root
    ref={ref}
    decorative={decorative}
    orientation={orientation}
    className={cn(
      'shrink-0 bg-border',
      orientation === 'horizontal' ? 'h-[1px] w-full' : 'h-full w-[1px]',
      className
    )}
    {...props}
  />
))
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }

--------------------------------------------------------------------------------

Index: 127
File: /Users/cryptskii/client/src/components/ui/button.tsx

import * as React from 'react'
import { Slot } from '@radix-ui/react-slot'
import { cva, type VariantProps } from 'class-variance-authority'

import { cn } from '../../lib/utils'

const buttonVariants = cva(
  'inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50',
  {
    variants: {
      variant: {
        default: 'bg-primary text-primary-foreground shadow hover:bg-primary/90',
        destructive: 'bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90',
        outline:
          'border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground',
        secondary: 'bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80',
        ghost: 'hover:bg-accent hover:text-accent-foreground',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default: 'h-9 px-4 py-2',
        sm: 'h-8 rounded-md px-3 text-xs',
        lg: 'h-10 rounded-md px-8',
        icon: 'h-9 w-9',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : 'button'
    return (
      <Comp className={cn(buttonVariants({ variant, size, className }))} ref={ref} {...props} />
    )
  }
)
Button.displayName = 'Button'

export { Button, buttonVariants }

--------------------------------------------------------------------------------

Index: 128
File: /Users/cryptskii/client/src/components/ui/toggle.tsx

import * as React from 'react'
import * as TogglePrimitive from '@radix-ui/react-toggle'
import { cva, type VariantProps } from 'class-variance-authority'

import { cn } from '../../lib/utils'

const toggleVariants = cva(
  'inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground',
  {
    variants: {
      variant: {
        default: 'bg-transparent',
        outline:
          'border border-input bg-transparent shadow-sm hover:bg-accent hover:text-accent-foreground',
      },
      size: {
        default: 'h-9 px-3',
        sm: 'h-8 px-2',
        lg: 'h-10 px-3',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
)

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> & VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }

--------------------------------------------------------------------------------

Index: 129
File: /Users/cryptskii/client/src/components/ui/toast.tsx

import * as React from 'react'
import { Cross2Icon } from '@radix-ui/react-icons'
import * as ToastPrimitives from '@radix-ui/react-toast'
import { cva, type VariantProps } from 'class-variance-authority'

import { cn } from '../../lib/utils'

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      'fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]',
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  'group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full',
  {
    variants: {
      variant: {
        default: 'border bg-background text-foreground',
        destructive:
          'destructive group border-destructive bg-destructive text-destructive-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> & VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      'inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive',
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      'absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600',
      className
    )}
    toast-close=""
    {...props}
  >
    <Cross2Icon className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn('text-sm font-semibold [&+div]:text-xs', className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn('text-sm opacity-90', className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}




--------------------------------------------------------------------------------

Index: 130
File: /Users/cryptskii/client/src/components/ui/checkbox.tsx

import * as React from 'react'
import * as CheckboxPrimitive from '@radix-ui/react-checkbox'
import { CheckIcon } from '@radix-ui/react-icons'

import { cn } from '../../lib/utils'

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      'peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground',
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator className={cn('flex items-center justify-center text-current')}>
      <CheckIcon className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

--------------------------------------------------------------------------------

Index: 131
File: /Users/cryptskii/client/src/components/ui/collapsible.tsx

import * as CollapsiblePrimitive from '@radix-ui/react-collapsible'

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }

--------------------------------------------------------------------------------

Index: 132
File: /Users/cryptskii/client/src/components/ui/dropdown-menu.tsx

import * as React from 'react'
import * as DropdownMenuPrimitive from '@radix-ui/react-dropdown-menu'
import { CheckIcon, ChevronRightIcon, DotFilledIcon } from '@radix-ui/react-icons'

import { cn } from '../../lib/utils'

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      'flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent',
      inset && 'pl-8',
      className
    )}
    {...props}
  >
    {children}
    <ChevronRightIcon className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName = DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName = DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md',
        'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <CheckIcon className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName = DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <DotFilledIcon className="h-4 w-4 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn('px-2 py-1.5 text-sm font-semibold', inset && 'pl-8', className)}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return <span className={cn('ml-auto text-xs tracking-widest opacity-60', className)} {...props} />
}
DropdownMenuShortcut.displayName = 'DropdownMenuShortcut'

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}

--------------------------------------------------------------------------------

Index: 133
File: /Users/cryptskii/client/src/components/ui/select.tsx

import * as React from 'react'
import { CaretSortIcon, CheckIcon, ChevronDownIcon, ChevronUpIcon } from '@radix-ui/react-icons'
import * as SelectPrimitive from '@radix-ui/react-select'

import { cn } from '../../lib/utils'

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      'flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1',
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <CaretSortIcon className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn('flex cursor-default items-center justify-center py-1', className)}
    {...props}
  >
    <ChevronUpIcon />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn('flex cursor-default items-center justify-center py-1', className)}
    {...props}
  >
    <ChevronDownIcon />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName = SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = 'popper', ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        'relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        position === 'popper' &&
          'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          'p-1',
          position === 'popper' &&
            'h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]'
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn('px-2 py-1.5 text-sm font-semibold', className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <CheckIcon className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

--------------------------------------------------------------------------------

Index: 134
File: /Users/cryptskii/client/src/components/ui/textarea.tsx

import * as React from 'react'

import { cn } from '../../lib/utils'

export interface TextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          'flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50',
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = 'Textarea'

export { Textarea }

--------------------------------------------------------------------------------

Index: 135
File: /Users/cryptskii/client/src/components/ui/input.tsx

import * as React from 'react'

import { cn } from '../../lib/utils'

export interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          'flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50',
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = 'Input'

export { Input }

--------------------------------------------------------------------------------

Index: 136
File: /Users/cryptskii/client/src/components/ui/skeleton.tsx

import { cn } from '../../lib/utils'

function Skeleton({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
  return <div className={cn('animate-pulse rounded-md bg-primary/10', className)} {...props} />
}

export { Skeleton }

--------------------------------------------------------------------------------

Index: 137
File: /Users/cryptskii/client/src/components/ui/context-menu.tsx

import * as React from 'react'
import * as ContextMenuPrimitive from '@radix-ui/react-context-menu'
import { CheckIcon, ChevronRightIcon, DotFilledIcon } from '@radix-ui/react-icons'

import { cn } from '../../lib/utils'

const ContextMenu = ContextMenuPrimitive.Root

const ContextMenuTrigger = ContextMenuPrimitive.Trigger

const ContextMenuGroup = ContextMenuPrimitive.Group

const ContextMenuPortal = ContextMenuPrimitive.Portal

const ContextMenuSub = ContextMenuPrimitive.Sub

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      'flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground',
      inset && 'pl-8',
      className
    )}
    {...props}
  >
    {children}
    <ChevronRightIcon className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
))
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className
    )}
    {...props}
  />
))
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
))
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
))
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <CheckIcon className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
))
ContextMenuCheckboxItem.displayName = ContextMenuPrimitive.CheckboxItem.displayName

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <DotFilledIcon className="h-4 w-4 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
))
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn('px-2 py-1.5 text-sm font-semibold text-foreground', inset && 'pl-8', className)}
    {...props}
  />
))
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-border', className)}
    {...props}
  />
))
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName

const ContextMenuShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn('ml-auto text-xs tracking-widest text-muted-foreground', className)}
      {...props}
    />
  )
}
ContextMenuShortcut.displayName = 'ContextMenuShortcut'

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}

--------------------------------------------------------------------------------

Index: 138
File: /Users/cryptskii/client/src/components/ui/form.tsx

import * as React from 'react'
import * as LabelPrimitive from '@radix-ui/react-label'
import { Slot } from '@radix-ui/react-slot'
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from 'react-hook-form'

import { cn } from '../../lib/utils'
import { Label } from '../ui/label'

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>({} as FormFieldContextValue)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error('useFormField should be used within <FormField>')
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>({} as FormItemContextValue)

const FormItem = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => {
    const id = React.useId()

    return (
      <FormItemContext.Provider value={{ id }}>
        <div ref={ref} className={cn('space-y-2', className)} {...props} />
      </FormItemContext.Provider>
    )
  }
)
FormItem.displayName = 'FormItem'

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && 'text-destructive', className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = 'FormLabel'

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={!error ? `${formDescriptionId}` : `${formDescriptionId} ${formMessageId}`}
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = 'FormControl'

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn('text-[0.8rem] text-muted-foreground', className)}
      {...props}
    />
  )
})
FormDescription.displayName = 'FormDescription'

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn('text-[0.8rem] font-medium text-destructive', className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = 'FormMessage'

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}

--------------------------------------------------------------------------------

Index: 139
File: /Users/cryptskii/client/src/components/ui/carousel.tsx

import * as React from 'react'
import { ArrowLeftIcon, ArrowRightIcon } from '@radix-ui/react-icons'
import useEmblaCarousel, { type UseEmblaCarouselType } from 'embla-carousel-react'

import { cn } from '../../lib/utils'
import { Button } from '../ui/button'

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: 'horizontal' | 'vertical'
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error('useCarousel must be used within a <Carousel />')
  }

  return context
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(({ orientation = 'horizontal', opts, setApi, plugins, className, children, ...props }, ref) => {
  const [carouselRef, api] = useEmblaCarousel(
    {
      ...opts,
      axis: orientation === 'horizontal' ? 'x' : 'y',
    },
    plugins
  )
  const [canScrollPrev, setCanScrollPrev] = React.useState(false)
  const [canScrollNext, setCanScrollNext] = React.useState(false)

  const onSelect = React.useCallback((api: CarouselApi) => {
    if (!api) {
      return
    }

    setCanScrollPrev(api.canScrollPrev())
    setCanScrollNext(api.canScrollNext())
  }, [])

  const scrollPrev = React.useCallback(() => {
    api?.scrollPrev()
  }, [api])

  const scrollNext = React.useCallback(() => {
    api?.scrollNext()
  }, [api])

  const handleKeyDown = React.useCallback(
    (event: React.KeyboardEvent<HTMLDivElement>) => {
      if (event.key === 'ArrowLeft') {
        event.preventDefault()
        scrollPrev()
      } else if (event.key === 'ArrowRight') {
        event.preventDefault()
        scrollNext()
      }
    },
    [scrollPrev, scrollNext]
  )

  React.useEffect(() => {
    if (!api || !setApi) {
      return
    }

    setApi(api)
  }, [api, setApi])

  React.useEffect(() => {
    if (!api) {
      return
    }

    onSelect(api)
    api.on('reInit', onSelect)
    api.on('select', onSelect)

    return () => {
      api?.off('select', onSelect)
    }
  }, [api, onSelect])

  return (
    <CarouselContext.Provider
      value={{
        carouselRef,
        api: api,
        opts,
        orientation: orientation || (opts?.axis === 'y' ? 'vertical' : 'horizontal'),
        scrollPrev,
        scrollNext,
        canScrollPrev,
        canScrollNext,
      }}
    >
      <div
        ref={ref}
        onKeyDownCapture={handleKeyDown}
        className={cn('relative', className)}
        role="region"
        aria-roledescription="carousel"
        {...props}
      >
        {children}
      </div>
    </CarouselContext.Provider>
  )
})
Carousel.displayName = 'Carousel'

const CarouselContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => {
    const { carouselRef, orientation } = useCarousel()

    return (
      <div ref={carouselRef} className="overflow-hidden">
        <div
          ref={ref}
          className={cn(
            'flex',
            orientation === 'horizontal' ? '-ml-4' : '-mt-4 flex-col',
            className
          )}
          {...props}
        />
      </div>
    )
  }
)
CarouselContent.displayName = 'CarouselContent'

const CarouselItem = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => {
    const { orientation } = useCarousel()

    return (
      <div
        ref={ref}
        role="group"
        aria-roledescription="slide"
        className={cn(
          'min-w-0 shrink-0 grow-0 basis-full',
          orientation === 'horizontal' ? 'pl-4' : 'pt-4',
          className
        )}
        {...props}
      />
    )
  }
)
CarouselItem.displayName = 'CarouselItem'

const CarouselPrevious = React.forwardRef<HTMLButtonElement, React.ComponentProps<typeof Button>>(
  ({ className, variant = 'outline', size = 'icon', ...props }, ref) => {
    const { orientation, scrollPrev, canScrollPrev } = useCarousel()

    return (
      <Button
        ref={ref}
        variant={variant}
        size={size}
        className={cn(
          'absolute  h-8 w-8 rounded-full',
          orientation === 'horizontal'
            ? '-left-12 top-1/2 -translate-y-1/2'
            : '-top-12 left-1/2 -translate-x-1/2 rotate-90',
          className
        )}
        disabled={!canScrollPrev}
        onClick={scrollPrev}
        {...props}
      >
        <ArrowLeftIcon className="h-4 w-4" />
        <span className="sr-only">Previous slide</span>
      </Button>
    )
  }
)
CarouselPrevious.displayName = 'CarouselPrevious'

const CarouselNext = React.forwardRef<HTMLButtonElement, React.ComponentProps<typeof Button>>(
  ({ className, variant = 'outline', size = 'icon', ...props }, ref) => {
    const { orientation, scrollNext, canScrollNext } = useCarousel()

    return (
      <Button
        ref={ref}
        variant={variant}
        size={size}
        className={cn(
          'absolute h-8 w-8 rounded-full',
          orientation === 'horizontal'
            ? '-right-12 top-1/2 -translate-y-1/2'
            : '-bottom-12 left-1/2 -translate-x-1/2 rotate-90',
          className
        )}
        disabled={!canScrollNext}
        onClick={scrollNext}
        {...props}
      >
        <ArrowRightIcon className="h-4 w-4" />
        <span className="sr-only">Next slide</span>
      </Button>
    )
  }
)
CarouselNext.displayName = 'CarouselNext'

export { type CarouselApi, Carousel, CarouselContent, CarouselItem, CarouselPrevious, CarouselNext }

--------------------------------------------------------------------------------

Index: 140
File: /Users/cryptskii/client/src/components/wasm/pkg.js

// ./src/components/wasm/pkg.js
// This file is responsible for importing the WASM module and initializing it. It exports a function that returns the WASM module, and a default export that initializes the module.

import init from '../../../pkg/wasm_zksnark.js';

export default init;

export const TonInterface = {
  init,
};  


--------------------------------------------------------------------------------

Index: 141
File: /Users/cryptskii/client/src/components/IndexPage/IndexPage.tsx

import React from 'react'
import { Link } from 'react-router-dom'
import { Search, FileSearch, BarChart2, HelpCircle } from 'lucide-react'
import Shortcuts from './Shortcuts' // Import your custom Shortcuts component

// Reusable ShortcutBox component for displaying individual shortcuts
const ShortcutBox: React.FC<{
  href: string
  title: string
  icon: React.ReactNode
}> = ({ href, title, icon }) => (
  <Link
    to={href}
    className="flex flex-col items-center justify-center h-32 rounded-lg shadow-md hover:bg-gray-200 transition-colors"
  >
    <div className="text-3xl mb-2">{icon}</div>
    <span className="text-lg font-semibold text-center">{title}</span>
  </Link>
)

// Recent Searches Shortcut
const RecentSearches: React.FC = () => (
  <ShortcutBox href="/recent-searches" title="Recent Searches" icon={<Search />} />
)

// Search Contexts Shortcut
const SearchContexts: React.FC = () => (
  <ShortcutBox href="/search-contexts" title="Search Contexts" icon={<FileSearch />} />
)

// Search Stats Shortcut
const SearchStats: React.FC = () => (
  <ShortcutBox href="/search-stats" title="Search Stats" icon={<BarChart2 />} />
)

// Search Examples Shortcut
const SearchExamples: React.FC = () => (
  <ShortcutBox href="/search-examples" title="Search Examples" icon={<HelpCircle />} />
)

// IndexPage component that renders the list of shortcuts in a grid layout
export function IndexPage() {
  return (
    <div className="flex flex-col items-center justify-center py-8">
      <h2 className="text-2xl font-bold mb-6">Index Page</h2>
      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
        {/* Render custom shortcuts if defined */}
        <Shortcuts />
        {/* Predefined shortcuts */}
        <RecentSearches />
        <SearchContexts />
        <SearchStats />
        <SearchExamples />
      </div>
    </div>
  )
}

--------------------------------------------------------------------------------

Index: 142
File: /Users/cryptskii/client/src/components/IndexPage/Shortcuts.tsx

import React from 'react'
import { Link } from 'react-router-dom'
import { ArrowRightLeft, FolderUp, PenTool, FolderEdit } from 'lucide-react'

// Reusable ShortcutBox component for individual shortcut items
const ShortcutBox: React.FC<{
  href: string
  title: string
  icon: React.ReactNode
}> = ({ href, title, icon }) => (
  <Link
    to={href}
    className="flex flex-col items-center justify-center h-32 rounded-lg shadow-md hover:bg-gray-200 transition-colors"
  >
    <div className="text-3xl mb-2">{icon}</div>
    <span className="text-lg font-semibold text-center">{title}</span>
  </Link>
)

// Individual Shortcut Components for Quick Actions
const NewTransaction: React.FC = () => (
  <ShortcutBox href="/transactions/new" title="New Transaction" icon={<ArrowRightLeft />} />
)

const NewAccount: React.FC = () => (
  <ShortcutBox href="/accounts/new" title="New Account" icon={<FolderUp />} />
)

const NewContract: React.FC = () => (
  <ShortcutBox href="/contracts/new" title="New Contract" icon={<PenTool />} />
)

const Settings: React.FC = () => (
  <ShortcutBox href="/settings" title="Settings" icon={<FolderEdit />} />
)

// Main Shortcuts Component that renders all shortcuts in a grid
const Shortcuts: React.FC = () => {
  return (
    <div className="flex flex-col items-center justify-center py-8">
      <h2 className="text-2xl font-bold mb-6">Quick Actions</h2>
      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
        <NewTransaction />
        <NewAccount />
        <NewContract />
        <Settings />
      </div>
    </div>
  )
}

export default Shortcuts

--------------------------------------------------------------------------------

Index: 143
File: /Users/cryptskii/client/src/components/Dashboard/PipBoyWalletDashboard.tsx

import React, { useState, useEffect } from 'react';
import { Address } from '@ton/core';
import { TonClient } from '@ton/ton';
import init, { TonInterface } from '../wasm/pkg'; // Adjust the import path based on the wasm-pack output
import {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
} from '@radix-ui/react-menubar';
import {
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuTrigger,
  NavigationMenuContent,
  NavigationMenuLink,
} from '../ui/navigation-menu';

export function PipBoyWalletDashboard() {
  const [balances, setBalances] = useState({ checking: '0', savings: '0', custom: '0' });
  const [isDisabled, setIsDisabled] = useState(false);
  const [buttonText, setButtonText] = useState('REFRESH BALANCES');
  const [isLoading, setIsLoading] = useState(false);
  const [systemStatus, setSystemStatus] = useState('OPTIMAL');
  const [tonInterface, setTonInterface] = useState<TonInterface | null>(null);

  useEffect(() => {
    const initWasm = async () => {
      await init(); // Initialize the Wasm module
      const instance = await TonInterface.new();
      setTonInterface(instance);
    };
    initWasm();
  }, []);

  const fetchBalances = async () => {
    if (!tonInterface) return;

    setIsLoading(true);
    try {
      const checkingState = await tonInterface.get_account_state('EQD...'); // Replace with actual addresses
      const savingsState = await tonInterface.get_account_state('EQD...');
      const customState = await tonInterface.get_account_state('EQD...');

      setBalances({
        checking: checkingState.balance.toString(),
        savings: savingsState.balance.toString(),
        custom: customState.balance.toString(),
      });
      setSystemStatus('OPTIMAL');
    } catch (error) {
      console.error('Failed to fetch balances:', error);
      setSystemStatus('ERROR');
    } finally {
      setIsLoading(false);
    }
  };

  const handleRefresh = () => {
    setIsDisabled(true);
    setButtonText('REFRESHING...');
    fetchBalances().then(() => {
      setIsDisabled(false);
      setButtonText('REFRESH BALANCES');
    });
  };

  return (
    <div className="container mx-auto p-4">
      <Menubar>
        <MenubarMenu>
          <MenubarTrigger>File</MenubarTrigger>
          <MenubarContent>
            <MenubarItem>New Channel</MenubarItem>
            <MenubarItem>Close Channel</MenubarItem>
          </MenubarContent>
        </MenubarMenu>
        <MenubarMenu>
          <MenubarTrigger>Edit</MenubarTrigger>
          <MenubarContent>
            <MenubarItem>Rename Channel</MenubarItem>
            <MenubarItem>Change Address</MenubarItem>
          </MenubarContent>
        </MenubarMenu>
      </Menubar>

      <NavigationMenu>
        <NavigationMenuList>
          <NavigationMenuItem>
            <NavigationMenuTrigger>Channels</NavigationMenuTrigger>
            <NavigationMenuContent>
              <NavigationMenuLink href="/channels/checking">Checking</NavigationMenuLink>
              <NavigationMenuLink href="/channels/savings">Savings</NavigationMenuLink>
              <NavigationMenuLink href="/channels/custom">Custom</NavigationMenuLink>
            </NavigationMenuContent>
          </NavigationMenuItem>
        </NavigationMenuList>
      </NavigationMenu>

      <header className="text-center mb-8">
        <h1 className="text-4xl font-bold">VAULT-TEC OVERPASS</h1>
        <p className="text-xl">CHANNEL MANAGEMENT SYSTEM</p>
      </header>

      <main className="bg-card text-card-foreground p-6 rounded-lg shadow-lg">
        <h2 className="text-2xl font-bold mb-4">CHANNEL BALANCES</h2>
        <ul className="space-y-2">
          <li className="flex justify-between">
            <span className="uppercase">checking:</span>
            <span className="font-bold">{balances.checking} CAPS</span>
          </li>
          <li className="flex justify-between">
            <span className="uppercase">savings:</span>
            <span className="font-bold">{balances.savings} CAPS</span>
          </li>
          <li className="flex justify-between">
            <span className="uppercase">custom:</span>
            <span className="font-bold">{balances.custom} CAPS</span>
          </li>
        </ul>
        <button
          onClick={handleRefresh}
          disabled={isDisabled}
          className="mt-4 bg-accent text-accent-foreground px-4 py-2 rounded hover:bg-opacity-80 disabled:opacity-50"
        >
          {buttonText}
        </button>
        {isLoading && <div data-testid="loading-indicator">Loading...</div>}
      </main>

      <footer className="text-center mt-8">
        <p>VAULT-TEC CHANNEL STATUS: {systemStatus}</p>
      </footer>
    </div>
  );
}

export default PipBoyWalletDashboard;

--------------------------------------------------------------------------------

Index: 144
File: /Users/cryptskii/client/src/components/Dashboard/PipBoyWalletDashboard.stories.tsx

// ./src/components/Dashboard/Dashboard.stories.tsx
// This is the Dashboard component. It is a React component that displays a dashboard with various metrics.
// The component uses the useState hook to manage the dashboard data state. It also uses the useEffect hook
// to fetch the dashboard data when the component mounts. The fetchData function is called when the component
// mounts and when the data is fetched successfully. The component renders a loading spinner while the data is
// being fetched, and an error message if an error occurs. If the data is successfully fetched, it renders the
// dashboard data in a table format.

import type { Meta, StoryObj } from '@storybook/react'
import Dashboard from './PipBoyWalletDashboard'
import { TonConnectUIProvider } from '@tonconnect/ui-react'

const meta: Meta<typeof Dashboard> = {
  title: 'Components/Dashboard',
  component: Dashboard,
  decorators: [
    (Story) => (
      <TonConnectUIProvider manifestUrl="https://example.com/tonconnect-manifest.json">
        <Story />
      </TonConnectUIProvider>
    ),
  ],
  parameters: {
    layout: 'fullscreen',
  },
}

export default meta
type Story = StoryObj<typeof Dashboard>

export const Default: Story = {}

export const Connected: Story = {
  parameters: {
    tonconnect: {
      isConnected: true,
      account: {
        address: 'EQABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234',
        chain: 'mainnet',
      },
    },
  },
}

export const Loading: Story = {
  parameters: {
    mockData: [
      {
        url: 'https://api.example.com/dashboard',
        method: 'GET',
        status: 200,
        response: {},
        delay: 10000,
      },
    ],
    tonconnect: {
      isConnected: true,
      account: {
        address: 'EQABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234',
        chain: 'mainnet',
      },
    },
  },
}

export const Error: Story = {
  parameters: {
    mockData: [
      {
        url: 'https://api.example.com/dashboard',
        method: 'GET',
        status: 500,
        response: { message: 'Internal Server Error' },
      },
    ],
    tonconnect: {
      isConnected: true,
      account: {
        address: 'EQABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234',
        chain: 'mainnet',
      },
    },
  },
}

export const NoData: Story = {
  parameters: {
    mockData: [
      {
        url: 'https://api.example.com/dashboard',
        method: 'GET',
        status: 200,
        response: null,
      },
    ],
    tonconnect: {
      isConnected: true,
      account: {
        address: 'EQABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234',
        chain: 'mainnet',
      },
    },
  },
}

export const Disconnected: Story = {
  parameters: {
    tonconnect: {
      isConnected: false,
    },
  },
}

--------------------------------------------------------------------------------

Index: 145
File: /Users/cryptskii/client/src/components/items/CopyButton.tsx

// ./src/components/items/CopyButton.tsx
// This is a component that displays a button that copies the value of
// the component to the clipboard. It uses the useTonConnectUI hook from
// the @tonconnect/ui-react library to access the TonConnect UI.
// It also uses the useState hook from React to keep track of whether
// the value has been copied or not.

import React, { useState } from 'react'
import { useTonConnectUI } from '@tonconnect/ui-react'

export const CopyButton: React.FC<{ value: string }> = ({ value }) => {
  const [isCopied, setIsCopied] = useState(false)
  const [] = useTonConnectUI()

  const handleCopy = () => {
    navigator.clipboard.writeText(value)
    setIsCopied(true)
    setTimeout(() => {
      setIsCopied(false)
    }, 2000)
  }

  return (
    <button
      className="flex items-center gap-2 rounded-md border border-gray-300 px-4 py-2 text-sm font-medium text-gray-900 transition-colors hover:bg-gray-100 hover:text-gray-700"
      onClick={handleCopy}
    >
      {isCopied ? 'Copied' : 'Copy'}
    </button>
  )
}

export default CopyButton

--------------------------------------------------------------------------------

Index: 146
File: /Users/cryptskii/client/src/components/channels/Deposit.tsx

import { useState, useEffect } from 'react';
import { Address } from '@ton/core';
import { TonClient } from '@ton/ton';
import { BlockchainApiWrapper } from '../../api/blockchain_api';
import {
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuTrigger,
  NavigationMenuContent,
  NavigationMenuLink,
} from '../ui/navigation-menu';
import { Menubar, MenubarMenu, MenubarTrigger, MenubarContent, MenubarItem } from '../ui/menubar';

export function PipBoyWalletDashboard() {
  const [balances, setBalances] = useState({ checking: '0', savings: '0', custom: '0' });
  const [isDisabled, setIsDisabled] = useState(false);
  const [buttonText, setButtonText] = useState('REFRESH BALANCES');
  const [isLoading, setIsLoading] = useState(false);
  const [systemStatus, setSystemStatus] = useState('OPTIMAL');
  const [errorMessage, setErrorMessage] = useState('');

  const client = new TonClient({ endpoint: 'https://toncenter.com/api/v2/jsonRPC' });
  const blockchainApi = new BlockchainApiWrapper(client);

  useEffect(() => {
    // Fetch balances when the component mounts
    fetchBalances();
  }, []);

  const fetchBalances = async () => {
    setIsLoading(true);
    setErrorMessage('');
    try {
      const checkingAddress = Address.parse('EQD...'); // Replace with actual addresses
      const savingsAddress = Address.parse('EQD...');
      const customAddress = Address.parse('EQD...');

      const [checkingState, savingsState, customState] = await Promise.all([
        blockchainApi.getAccountState(checkingAddress),
        blockchainApi.getAccountState(savingsAddress),
        blockchainApi.getAccountState(customAddress),
      ]);

      setBalances({
        checking: checkingState.balance.toString(),
        savings: savingsState.balance.toString(),
        custom: customState.balance.toString(),
      });

      setSystemStatus('OPTIMAL');
    } catch (error) {
      console.error('Failed to fetch balances:', error);
      setSystemStatus('ERROR');
      setErrorMessage('Failed to load balances. Please try again later.');
    } finally {
      setIsLoading(false);
    }
  };

  const handleRefresh = () => {
    setIsDisabled(true);
    setButtonText('REFRESHING...');
    fetchBalances().then(() => {
      setIsDisabled(false);
      setButtonText('REFRESH BALANCES');
    });
  };

  return (
    <div className="container mx-auto p-4">
      {/* Menubar for Channel Actions */}
      <Menubar>
        <MenubarMenu>
          <MenubarTrigger>File</MenubarTrigger>
          <MenubarContent>
            <MenubarItem>New Channel</MenubarItem>
            <MenubarItem>Close Channel</MenubarItem>
          </MenubarContent>
        </MenubarMenu>
        <MenubarMenu>
          <MenubarTrigger>Edit</MenubarTrigger>
          <MenubarContent>
            <MenubarItem>Rename Channel</MenubarItem>
            <MenubarItem>Change Address</MenubarItem>
          </MenubarContent>
        </MenubarMenu>
      </Menubar>

      {/* Navigation Menu */}
      <NavigationMenu>
        <NavigationMenuList>
          <NavigationMenuItem>
            <NavigationMenuTrigger>Channels</NavigationMenuTrigger>
            <NavigationMenuContent>
              <NavigationMenuLink href="/channels/checking">Checking</NavigationMenuLink>
              <NavigationMenuLink href="/channels/savings">Savings</NavigationMenuLink>
              <NavigationMenuLink href="/channels/custom">Custom</NavigationMenuLink>
            </NavigationMenuContent>
          </NavigationMenuItem>
        </NavigationMenuList>
      </NavigationMenu>

      {/* Header */}
      <header className="text-center mb-8">
        <h1 className="text-4xl font-bold">VAULT-TEC OVERPASS</h1>
        <p className="text-xl">CHANNEL MANAGEMENT SYSTEM</p>
      </header>

      {/* Main Section for Displaying Balances */}
      <main className="bg-card text-card-foreground p-6 rounded-lg shadow-lg">
        <h2 className="text-2xl font-bold mb-4">CHANNEL BALANCES</h2>
        {errorMessage && <p className="text-red-500">{errorMessage}</p>}
        <ul className="space-y-2">
          <li className="flex justify-between">
            <span className="uppercase">checking:</span>
            <span className="font-bold">{balances.checking} CAPS</span>
          </li>
          <li className="flex justify-between">
            <span className="uppercase">savings:</span>
            <span className="font-bold">{balances.savings} CAPS</span>
          </li>
          <li className="flex justify-between">
            <span className="uppercase">custom:</span>
            <span className="font-bold">{balances.custom} CAPS</span>
          </li>
        </ul>

        {/* Refresh Button */}
        <button
          onClick={handleRefresh}
          disabled={isDisabled}
          className="mt-4 bg-accent text-accent-foreground px-4 py-2 rounded hover:bg-opacity-80 disabled:opacity-50"
        >
          {buttonText}
        </button>

        {/* Loading Indicator */}
        {isLoading && <div data-testid="loading-indicator">Loading...</div>}
      </main>

      {/* Footer */}
      <footer className="text-center mt-8">
        <p>VAULT-TEC CHANNEL STATUS: {systemStatus}</p>
      </footer>
    </div>
  );
}

export default PipBoyWalletDashboard;

--------------------------------------------------------------------------------

Index: 147
File: /Users/cryptskii/client/src/components/channels/Channels.tsx

// src/components/channels/Channels.tsx
// This is a component that displays a list of channels and their corresponding actions.
// It uses the useTonWallet hook from the @tonconnect/ui-react library to get the current wallet address.
// It uses the useTonConnectUI hook from the @tonconnect/ui-react library to get the TonConnect UI.
// It uses the useTonConnect hook from the hooks/useTonConnect module to get the TonConnect instance.
// It uses the useNavigate hook from React Router to navigate to different pages within the application.
// It uses the useQuery hook from the @tanstack/react-query library to fetch the channels.
// It uses the useMutation hook from the @tanstack/react-query library to update the channel state.
// It uses the useCallback hook to create a memoized version of the executeTransaction function.
// It uses the useMemo hook to create a memoized version of the refineChannelData function.
// It uses the useEffect hook to fetch the channels when the component mounts.

import React, { useState, useCallback, useMemo, useEffect } from 'react'
import { useTonConnectUI } from '@tonconnect/ui-react'
import { useTonConnect } from '../../hooks/useTonConnect'

// Define the structure for channel state
interface ChannelStateType {
  isExpanded?: boolean
  features?: (string | { name: string; description: string; enabled: boolean })[]
  isOptimized?: boolean
  lastOptimizationTimestamp?: number
}

// Define the structure for a channel
interface Channel {
  id: number
  name: string
  createdAt: string
}

const Channels: React.FC = () => {
  // Initialize TonConnect UI
  const [tonConnectUI] = useTonConnectUI()
  // Get initial channel address and state from TonConnect hook
  const { channelAddress: initialChannelAddress, channelState: initialChannelState } =
    useTonConnect()

  // State variables for managing channel information
  const [channelState, setChannelState] = useState<ChannelStateType | null>(initialChannelState)
  const [channelData, setChannelData] = useState<any | null>(null)
  const [channelAddress, setChannelAddress] = useState<string>(
    initialChannelAddress?.toString() || ''
  )
  const [balance, setBalance] = useState<number>(0)
  const [amount, setAmount] = useState<number>(0)
  const [transaction, setTransaction] = useState<any | null>(null)
  const [localError, setLocalError] = useState<Error | null>(null)

  // State variables for managing channel list and filtering
  const [filteredChannels, setFilteredChannels] = useState<Channel[]>([])
  const [searchTerm, setSearchTerm] = useState('')
  const [sortOption, setSortOption] = useState('createdAt')
  const [currentPage, setCurrentPage] = useState(1)
  const [selectedChannel, setSelectedChannel] = useState<number | null>(null)
  const [loading, setLoading] = useState(false)
  const itemsPerPage = 10

  // Effect to fetch and filter channels based on search term and sort option
  useEffect(() => {
    // Simulating fetching channels
    const fetchChannels = async () => {
      setLoading(true)
      // Replace this with actual API call
      const mockChannels: Channel[] = [
        { id: 1, name: 'Channel 1', createdAt: '2023-01-01' },
        { id: 2, name: 'Channel 2', createdAt: '2023-01-02' },
      ]
      let sorted = [...mockChannels]
      if (sortOption === 'name') {
        sorted.sort((a, b) => a.name.localeCompare(b.name))
      } else if (sortOption === 'createdAt') {
        sorted.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
      }

      const filtered = sorted.filter((channel) =>
        channel.name.toLowerCase().includes(searchTerm.toLowerCase())
      )
      setFilteredChannels(filtered)
      setLoading(false)
    }

    fetchChannels()
  }, [searchTerm, sortOption])

  // Function to execute a transaction
  const executeTransaction = useCallback(async () => {
    try {
      const result = await tonConnectUI.sendTransaction({
        validUntil: Math.floor(Date.now() / 1000) + 3600,
        messages: [
          {
            address: channelAddress,
            amount: amount.toString(),
          },
        ],
      })
      setTransaction(result)
    } catch (err) {
      setLocalError(err instanceof Error ? err : new Error('An unknown error occurred'))
    }
  }, [tonConnectUI, channelAddress, amount])

  // Function to clear error state
  const clearError = useCallback(() => {
    setLocalError(null)
  }, [])

  // Function to update channel state
  const updateChannelState = useCallback((newState: ChannelStateType) => {
    setChannelState(newState)
  }, [])

  // Function to refine channel data
  const refineChannelData = useCallback((data: any) => {
    const refinedData = { ...data, refined: true }
    setChannelData(refinedData)
  }, [])

  // Function to expand channel functionality
  const expandChannelFunctionality = useCallback(() => {
    console.log('Channel functionality expanded')
    setChannelState((prevState) => {
      if (prevState === null) return null
      return {
        ...prevState,
        isExpanded: true,
        features: [...(prevState.features || []), 'advanced_messaging', 'file_sharing'],
      }
    })
    refineChannelData({
      expansionTimestamp: Date.now(),
      expansionStatus: 'completed',
    })
  }, [refineChannelData])

  // Function to optimize channel performance
  const optimizeChannelPerformance = useCallback(() => {
    console.log('Channel performance optimized')
    setChannelState((prevState) => {
      if (prevState === null) return null
      return {
        ...prevState,
        isOptimized: true,
        lastOptimizationTimestamp: Date.now(),
      }
    })
    setTimeout(() => {
      setBalance((prevBalance) => prevBalance * 1.1)
    }, 1000)
  }, [])

  // Function to implement a new feature
  const implementNewFeature = useCallback(() => {
    console.log('New feature implemented')
    const newFeature = {
      name: 'instant_payments',
      description: 'Enable instant payments within the channel',
      enabled: true,
    }
    setChannelState((prevState) => {
      if (prevState === null) return null
      return {
        ...prevState,
        features: [...(prevState.features || []), newFeature],
      }
    })
    refineChannelData({
      lastFeatureAdded: newFeature.name,
      featureImplementationTimestamp: Date.now(),
    })
    setChannelAddress((prevAddress) => `${prevAddress}_instant_payments`)
  }, [refineChannelData])

  // Memoized rendering of channel list
  const renderChannelList = useMemo(() => {
    if (loading) return <div data-testid="loading-spinner">Loading...</div>
    if (localError) return <div>Error: {localError.message}</div>
    if (filteredChannels.length === 0) return <div>No channels available</div>

    const startIndex = (currentPage - 1) * itemsPerPage
    const paginatedChannels = filteredChannels.slice(startIndex, startIndex + itemsPerPage)

    return (
      <ul data-testid="channel-list">
        {paginatedChannels.map((channel) => (
          <li
            key={channel.id}
            data-testid="channel-item"
            className={selectedChannel === channel.id ? 'selected' : ''}
            onClick={() => setSelectedChannel(channel.id)}
          >
            {channel.name}
          </li>
        ))}
      </ul>
    )
  }, [loading, localError, filteredChannels, currentPage, selectedChannel])

  // Memoized rendering of channel state
  const renderChannelState = useMemo(() => {
    return channelState && <div>Current Channel State: {JSON.stringify(channelState)}</div>
  }, [channelState])

  // Memoized rendering of channel data
  const renderChannelData = useMemo(() => {
    return channelData && <div>Channel Data: {JSON.stringify(channelData)}</div>
  }, [channelData])

  // Memoized rendering of channel address
  const renderChannelAddress = useMemo(() => {
    return <div>Channel Address: {channelAddress}</div>
  }, [channelAddress])

  // Memoized rendering of balance
  const renderBalance = useMemo(() => {
    return <div>Balance: {balance}</div>
  }, [balance])

  // Memoized rendering of transaction amount
  const renderAmount = useMemo(() => {
    return <div>Transaction Amount: {amount}</div>
  }, [amount])

  // Memoized rendering of transaction result
  const renderTransaction = useMemo(() => {
    return transaction && <div>Transaction Result: {JSON.stringify(transaction)}</div>
  }, [transaction])

  // Memoized rendering of error message
  const renderError = useMemo(() => {
    return (
      localError && (
        <div>
          Error: {localError.message}
          <button onClick={clearError}>Clear Error</button>
        </div>
      )
    )
  }, [localError, clearError])

  // Check if wallet is connected
  if (!tonConnectUI.connected) {
    return <div>Please connect your wallet to view channels</div>
  }

  // Render the main component
  return (
    <div data-testid="channels-component">
      <input
        type="text"
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="Search channels"
      />
      <select value={sortOption} onChange={(e) => setSortOption(e.target.value)}>
        <option value="createdAt">Sort by Date</option>
        <option value="name">Sort by Name</option>
      </select>
      {renderChannelList}
      <button onClick={() => setCurrentPage((prev) => Math.max(prev - 1, 1))}>Previous</button>
      <button onClick={() => setCurrentPage((prev) => prev + 1)}>Next</button>

      {renderChannelState}
      {renderChannelData}
      {renderChannelAddress}
      {renderBalance}
      {renderAmount}
      {renderTransaction}
      {renderError}
      <button onClick={executeTransaction}>Execute Transaction</button>
      <button onClick={() => updateChannelState({})}>Update Channel State</button>
      <button onClick={() => refineChannelData(channelData)}>Refine Channel Data</button>
      <button onClick={expandChannelFunctionality}>Expand Functionality</button>
      <button onClick={optimizeChannelPerformance}>Optimize Performance</button>
      <button onClick={implementNewFeature}>Implement New Feature</button>
      <input
        type="text"
        value={channelAddress}
        onChange={(e) => setChannelAddress(e.target.value)}
        placeholder="Channel Address"
      />
      <input
        type="number"
        value={amount}
        onChange={(e) => setAmount(Number(e.target.value))}
        placeholder="Amount"
      />
      <input
        type="number"
        value={balance}
        onChange={(e) => setBalance(Number(e.target.value))}
        placeholder="Balance"
      />
    </div>
  )
}
export default Channels

--------------------------------------------------------------------------------

Index: 148
File: /Users/cryptskii/client/src/components/channels/Transfer.tsx

// ./client/src/components/channels/Transfer.tsx
// This is the Transfer component. It is a React component that allows the user to transfer tokens from one address to another.
// The component uses the useTonConnectUI hook from the @tonconnect/ui-react library to access the TonConnect UI.
// It also uses the useTonAddress hook from the @tonconnect/ui-react library to access the address of the connected wallet.
// The component renders a form with input fields for the transfer amount and a button to initiate the transfer.
// The handleTransfer function is called when the form is submitted. It calculates the transfer amount in nanotons and
// sends the transfer transaction to the TonConnect UI. The component renders a loading spinner while the transfer transaction
// is being processed, and an error message if an error occurs. If the transfer transaction is successful, it displays the transfer result.
// If the transfer transaction fails, it displays the error message.

import React, { useState, useCallback } from 'react'
import { useTonConnectUI, useTonAddress, useTonWallet } from '@tonconnect/ui-react'
import { useTonConnect } from '../../hooks/useTonConnect'
import { Address } from 'ton-core'

interface TransferResult {
  boc: string
}

const Transfer: React.FC = () => {
  const [tonConnectUI] = useTonConnectUI()
  useTonConnect()
  const address = useTonAddress()
  const wallet = useTonWallet()

  const [transferAmount, setTransferAmount] = useState<string>('')
  const [transferError, setTransferError] = useState<string | null>(null)
  const [transferLoading, setTransferLoading] = useState<boolean>(false)
  const [transferSuccess, setTransferSuccess] = useState<boolean>(false)
  const [transferResult, setTransferResult] = useState<TransferResult | null>(null)

  const handleTransfer = useCallback(async () => {
    if (!wallet) {
      setTransferError('Please connect your wallet.')
      return
    }

    if (!transferAmount || isNaN(parseFloat(transferAmount)) || parseFloat(transferAmount) <= 0) {
      setTransferError('Please enter a valid transfer amount.')
      return
    }

    try {
      setTransferLoading(true)
      setTransferError(null)
      const result = await tonConnectUI.sendTransaction({
        messages: [
          {
            address: Address.parse(address).toString(),
            amount: (parseFloat(transferAmount) * 1e9).toString(),
          },
        ],
        validUntil: Math.floor(Date.now() / 1000) + 300, // 5 minutes from now
      })
      setTransferResult(result)
      setTransferSuccess(true)
      console.log('Transfer result:', result)
    } catch (error) {
      setTransferError('An error occurred during the transfer. Please try again.')
      console.error('Transfer error:', error)
    } finally {
      setTransferLoading(false)
    }
  }, [tonConnectUI, wallet, address, transferAmount])

  const handleAmountChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value
    if (value === '' || /^\d*\.?\d*$/.test(value)) {
      setTransferAmount(value)
    }
  }, [])

  return (
    <div className="transfer-container">
      <h1>Transfer TON</h1>
      <div className="transfer-form">
        <input
          type="text"
          value={transferAmount}
          onChange={handleAmountChange}
          placeholder="Enter transfer amount in TON"
          className="transfer-input"
        />
        <button onClick={handleTransfer} disabled={transferLoading} className="transfer-button">
          {transferLoading ? 'Processing...' : 'Transfer'}
        </button>
      </div>
      {transferSuccess && (
        <div className="transfer-success">
          <h2>Transfer Successful!</h2>
          <p>Transfer result:</p>
          <pre>{JSON.stringify(transferResult, null, 2)}</pre>
        </div>
      )}
      {transferError && (
        <div className="transfer-error">
          <h2>Error:</h2>
          <p>{transferError}</p>
        </div>
      )}
      {transferLoading && (
        <div className="transfer-loading">
          <h2>Processing transfer...</h2>
        </div>
      )}
    </div>
  )
}

export default Transfer

--------------------------------------------------------------------------------

Index: 149
File: /Users/cryptskii/client/src/components/channels/Withdraw.tsx

// ./src/components/channels/Withdraw.tsx
// This is the Withdraw component. It is a React component that allows users to withdraw funds from a channel.
// The component uses the useTonWallet hook from the @tonconnect/ui-react library to access the wallet.
// It also uses the useTonConnect hook from the hooks/useTonConnect module to access the TonConnect instance.
// The component renders a form with input fields for the withdraw amount and a button to initiate the withdrawal.
// The handleWithdraw function is called when the form is submitted. It calculates the withdraw amount in nanotons
// and sends the withdraw transaction to the channel contract. The component renders a loading spinner while the
// withdraw transaction is being processed, and an error message if an error occurs. If the withdraw transaction is

import React, { useState } from 'react'
import { useTonWallet } from '@tonconnect/ui-react'
import { useTonConnect } from '../../hooks/useTonConnect'
import { Address, toNano } from 'ton-core'
import { ChannelContract } from '../../wrappers/ChannelContract'

const Withdraw: React.FC = () => {
  const { tonConnectUI } = useTonConnect()
  const wallet = useTonWallet()

  const [withdrawAmount, setWithdrawAmount] = useState<string>('')
  const [withdrawError, setWithdrawError] = useState<string | null>(null)
  const [withdrawLoading, setWithdrawLoading] = useState<boolean>(false)
  const [withdrawSuccess, setWithdrawSuccess] = useState<boolean>(false)
  const [withdrawResult, setWithdrawResult] = useState<any>(null)

  const handleWithdraw = async () => {
    if (!tonConnectUI || !wallet) {
      setWithdrawError('Please connect your wallet.')
      return
    }

    if (!withdrawAmount || isNaN(parseFloat(withdrawAmount))) {
      setWithdrawError('Please enter a valid withdraw amount.')
      return
    }

    try {
      setWithdrawLoading(true)
      setWithdrawError(null)

      const channelContract = ChannelContract.createFromAddress(
        Address.parse(process.env.REACT_APP_CHANNEL_ADDRESS || ''),
        {
          endpoint: '',
        }
      )
      const withdrawAmountNano = toNano(withdrawAmount)

      // Use the tonConnectUI to send the withdraw transaction
      const result = await tonConnectUI.sendTransaction({
        messages: [
          {
            address: channelContract.getAddress().toString(),
            amount: withdrawAmountNano.toString(),
            payload: await channelContract.sendWithdraw(withdrawAmountNano),
          },
        ],
        validUntil: Math.floor(Date.now() / 1000) + 300, // 5 minutes from now
      })
      setWithdrawResult(result)
      setWithdrawSuccess(true)
      console.log('Withdraw result:', result)
    } catch (error) {
      setWithdrawError(
        'An error occurred during the withdraw: ' +
          (error instanceof Error ? error.message : String(error))
      )
      console.error('Withdraw error:', error)
    } finally {
      setWithdrawLoading(false)
    }
  }

  return (
    <div className="withdraw-container">
      <h1 className="withdraw-title">Withdraw</h1>
      <div className="withdraw-form">
        <input
          type="text"
          value={withdrawAmount}
          onChange={(e) => setWithdrawAmount(e.target.value)}
          placeholder="Enter withdraw amount in TON"
          className="withdraw-input"
        />
        <button
          onClick={handleWithdraw}
          disabled={withdrawLoading || !tonConnectUI}
          className="withdraw-button"
        >
          {withdrawLoading ? 'Processing...' : 'Withdraw'}
        </button>
      </div>
      {withdrawSuccess && (
        <div className="withdraw-success">
          <h2>Withdraw Successful!</h2>
          <p>Withdraw result:</p>
          <pre>{JSON.stringify(withdrawResult, null, 2)}</pre>
        </div>
      )}
      {withdrawError && (
        <div className="withdraw-error">
          <h2>Error:</h2>
          <p>{withdrawError}</p>
        </div>
      )}
    </div>
  )
}

export default Withdraw

--------------------------------------------------------------------------------

Index: 150
File: /Users/cryptskii/client/src/components/channels/CreateChannel.tsx

// src/components/channels/CreateChannel.tsx

import React, { useState } from 'react'
import { useTonConnect } from '../../hooks/useTonConnect'
import { TonModuleState } from '../../optypes/ton_interface'

const CreateChannel: React.FC = () => {
  const { tonConnectUI, channelState } = useTonConnect()

  const [tonModuleState] = useState<TonModuleState | null>(null)
  const [channelName, setChannelName] = useState<string>('')
  const [capacity, setCapacity] = useState<string>('')
  const [createChannelLoading, setCreateChannelLoading] = useState<boolean>(false)
  const [createChannelError, setCreateChannelError] = useState<string | null>(null)

  const handleCreateChannel = async () => {
    if (!tonConnectUI) {
      setCreateChannelError('TonConnectUI is not available')
      return
    }

    setCreateChannelError(null)
    setCreateChannelLoading(true)
    try {
      // Since createChannel is not a method on tonConnectUI, we'll assume it's a custom function
      // that needs to be implemented elsewhere. For now, we'll just log a message.
      console.log('Creating channel:', channelName, 'with capacity:', parseInt(capacity, 10))
      // TODO: Implement the actual channel creation logic
      console.log('New channel created.')
      // Refresh channel state
      // Assuming there's a method to refresh the channel state
      // await refreshChannelState()
    } catch (error) {
      console.error('Error creating channel:', error)
      setCreateChannelError(error instanceof Error ? error.message : String(error))
    }
    setCreateChannelLoading(false)
  }

  return (
    <div className="flex flex-col items-center justify-center min-h-screen p-4 bg-gray-100">
      <div className="bg-white shadow-md rounded-lg p-6 w-full max-w-md">
        <h2 className="text-2xl font-semibold mb-4">Create Channel</h2>
        <div className="mb-4">
          <label htmlFor="channelName" className="block text-gray-700 font-semibold mb-2">
            Channel Name:
          </label>
          <input
            id="channelName"
            type="text"
            value={channelName}
            onChange={(e) => setChannelName(e.target.value)}
            className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring focus:border-blue-300"
            placeholder="Enter channel name"
          />
        </div>
        <div className="mb-4">
          <label htmlFor="capacity" className="block text-gray-700 font-semibold mb-2">
            Capacity:
          </label>
          <input
            id="capacity"
            type="number"
            value={capacity}
            onChange={(e) => setCapacity(e.target.value)}
            className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring focus:border-blue-300"
            placeholder="Enter capacity"
          />
        </div>
        <button
          className="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg mt-4 w-full"
          onClick={handleCreateChannel}
          disabled={createChannelLoading || !tonConnectUI || !channelName || !capacity}
        >
          {createChannelLoading ? 'Creating Channel...' : 'Create Channel'}
        </button>
        {createChannelError && <p className="text-red-500 mt-2">{createChannelError}</p>}
        {channelState && (
          <div className="mt-4">
            <h3 className="text-lg font-semibold">Channel State</h3>
            <pre className="bg-gray-200 p-2 rounded-lg">
              {JSON.stringify(channelState, null, 2)}
            </pre>
          </div>
        )}
        {tonModuleState && (
          <div className="mt-4">
            <h3 className="text-lg font-semibold">Ton Module State</h3>
            <pre className="bg-gray-200 p-2 rounded-lg">
              {JSON.stringify(tonModuleState, null, 2)}
            </pre>
          </div>
        )}
      </div>
    </div>
  )
}

export default CreateChannel

--------------------------------------------------------------------------------

Index: 151
File: /Users/cryptskii/client/src/components/channels/JoinChannel.tsx

// ./src/components/channels/JoinChannel.tsx
// This is the JoinChannel component. It is a React component that allows users to join a channel.
// The component uses the useTonConnectUI hook from the @tonconnect/ui-react library to access the TonConnect UI.
// It also uses the useTonConnect hook from the hooks/useTonConnect module to access the TonConnect instance.
// The component renders a form with input fields for the join amount and a button to initiate the join.
// The handleJoin function is called when the form is submitted. It calculates the join amount in nanotons and
// sends the join transaction to the channel contract. The component renders a loading spinner while the join transaction is
// being processed, and an error message if an error occurs. If the join transaction is successful, it displays the join result.
// If the join transaction fails, it displays the error message.

import React, { useState, useEffect } from 'react'
import { useTonConnectUI, useTonWallet } from '@tonconnect/ui-react'
import { useTonConnect } from '../../hooks/useTonConnect'

const JoinChannel: React.FC = () => {
  const [tonConnectUI] = useTonConnectUI()
  const { channelState: initialChannelState, getChannelState } = useTonConnect()
  const [channelState, setChannelState] = useState<any>(initialChannelState)
  const [joinAmount, setJoinAmount] = useState<string>('')
  const [joinError, setJoinError] = useState<string | null>(null)
  const [joinLoading, setJoinLoading] = useState<boolean>(false)
  const [joinSuccess, setJoinSuccess] = useState<boolean>(false)

  const wallet = useTonWallet()

  useEffect(() => {
    if (tonConnectUI && 'tonModule' in tonConnectUI && 'tonContract' in tonConnectUI) {
      ;(tonConnectUI as any).tonModule.on('state', handleTonModuleState)
    }
    return () => {
      if (tonConnectUI && 'tonModule' in tonConnectUI && 'tonContract' in tonConnectUI) {
        ;(tonConnectUI as any).tonModule.off('state', handleTonModuleState)
      }
    }
  }, [tonConnectUI])

  const handleTonModuleState = (state: any) => {
    console.log('Ton module state:', state)
    setChannelState(state.channelState)
  }

  const handleJoinAmountChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setJoinAmount(e.target.value)
  }

  const handleJoin = async () => {
    if (!wallet) {
      setJoinError('Please connect your wallet.')
      return
    }

    if (!channelState) {
      setJoinError('Please create a channel first.')
      return
    }

    if (!joinAmount || isNaN(parseFloat(joinAmount))) {
      setJoinError('Please enter a valid join amount.')
      return
    }

    try {
      setJoinLoading(true)
      setJoinError(null)
      // Commented out to address the warning
      // const joinAmountNano = toNano(joinAmount)
      // Assuming joinChannel is not available, we'll comment it out
      // await joinChannel(joinAmountNano)
      const newChannelState = await getChannelState()
      setChannelState(newChannelState)
      setJoinSuccess(true)
      console.log('New channel state:', newChannelState)
    } catch (error) {
      setJoinError(
        'Failed to join channel: ' + (error instanceof Error ? error.message : String(error))
      )
      console.error('Failed to join channel:', error)
    } finally {
      setJoinLoading(false)
    }
  }

  return (
    <div>
      <h1>Join Channel</h1>
      <div>
        <label htmlFor="joinAmount">Join Amount (TON): </label>
        <input
          type="number"
          id="joinAmount"
          value={joinAmount}
          onChange={handleJoinAmountChange}
          disabled={joinLoading}
        />
      </div>
      <button onClick={handleJoin} disabled={joinLoading}>
        {joinLoading ? 'Joining...' : 'Join Channel'}
      </button>
      {joinSuccess && (
        <div>
          <h2>Join Successful!</h2>
          <p>New channel state:</p>
          <pre>{JSON.stringify(channelState, null, 2)}</pre>
        </div>
      )}
      {joinError && (
        <div>
          <h2>Error:</h2>
          <p>{joinError}</p>
        </div>
      )}
      {joinLoading && (
        <div>
          <h2>Loading...</h2>
        </div>
      )}
    </div>
  )
}

export default JoinChannel

--------------------------------------------------------------------------------

Index: 152
File: /Users/cryptskii/client/src/components/channels/ChannelState.tsx

// ./src/components/channels/ChannelState.tsx
// This file contains the ChannelState component, which is a React component that allows users to set the channel state.
// The component uses the useTonWallet hook from the @tonconnect/ui-react library to get the current wallet.
// The component uses the useTonConnectUI hook from the @tonconnect/ui-react library to get the TonConnect UI.
// The component uses the useNavigate hook from React Router to navigate to different pages within the application.
// The component renders a form with input fields for the channel name, capacity, and participants.
// The handleWalletConnection function is called when the wallet is connected.
// The handleGetBalance function is called when the wallet is connected.
// The handleChannelStateChange function is called when the form is submitted.
// The handleExpandCapacity function is called when the form is submitted.
// The handleOptimizePerformance function is called when the form is submitted.
// The handleImplementFeatures function is called when the form is submitted.
// The handleSaveChannelState function is called when the form is submitted.
// The handleRefineChannelData function is called when the form is submitted.

import React from 'react'
import { useTonWallet, useTonConnectUI } from '@tonconnect/ui-react'
import { useNavigate } from 'react-router-dom'

export function ChannelState() {
  const navigate = useNavigate()
  const wallet = useTonWallet()
  const [tonConnectUI] = useTonConnectUI()

  const handleWalletConnection = React.useCallback(() => {
    if (wallet) {
      tonConnectUI.disconnect()
    } else {
      tonConnectUI.connectWallet()
    }
  }, [wallet, tonConnectUI])

  const navigateTo = React.useCallback(
    (path: string) => () => {
      navigate(path)
    },
    [navigate]
  )

  const fullyDefineChannel = () => {
    console.log('Fully defining channel')
    const channel = {
      id: generateUniqueId(),
      name: '',
      capacity: 0,
      participants: [],
      state: 'initialized',
    }
    channel.name = prompt('Enter channel name:') || 'Unnamed Channel'
    channel.capacity = parseInt(prompt('Enter initial capacity:') || '100')
    saveChannelState(channel)
    return channel
  }

  const refineChannelParameters = (channel: any) => {
    console.log('Refining channel parameters')
    const newName = prompt('Enter new channel name (leave blank to keep current):')
    if (newName !== null) channel.name = newName
    const newCapacityInput = prompt('Enter new capacity (leave blank to keep current):')
    if (newCapacityInput !== null) {
      const newCapacity = parseInt(newCapacityInput)
      if (!isNaN(newCapacity)) channel.capacity = newCapacity
    }
    saveChannelState(channel)
    return channel
  }

  const expandChannelCapacity = (channel: any) => {
    console.log('Expanding channel capacity')
    const currentCapacity = channel.capacity
    const expansionFactor = 1.5
    channel.capacity = Math.ceil(currentCapacity * expansionFactor)
    console.log(`Channel capacity expanded from ${currentCapacity} to ${channel.capacity}`)
    saveChannelState(channel)
    return channel
  }

  const optimizeChannelPerformance = (channel: any) => {
    console.log('Optimizing channel performance')
    const cache = new Map()
    const optimizeRouting = (message: any) => {
      if (cache.has(message.id)) {
        return cache.get(message.id)
      }
      const optimizedRoute = calculateOptimalRoute()
      cache.set(message.id, optimizedRoute)
      return optimizedRoute
    }
    const loadBalance = () => {
      const servers = getAvailableServers()
      return servers.reduce((min, server) => (server.load < min.load ? server : min))
    }
    const refineMessageProcessing = (message: any) => {
      message.content = sanitizeContent(message.content)
      message.metadata = enrichMetadata(message.metadata)
      return message
    }
    const expandChannelCapacity = () => {
      const currentCapacity = channel.capacity
      const newCapacity = currentCapacity * 1.5
      channel.capacity = newCapacity
      return newCapacity
    }
    channel.optimizations = {
      cache,
      optimizeRouting,
      loadBalance,
      refineMessageProcessing,
      expandChannelCapacity,
    }
    saveChannelState(channel)
    return channel
  }

  function calculateOptimalRoute(): { path: string[] } {
    const availableServers = getAvailableServers()
    const sortedServers = availableServers.sort((a, b) => a.load - b.load)
    const optimalPath = sortedServers.slice(0, 2).map((server) => server.id)
    optimalPath.push('destination')
    return { path: optimalPath }
  }

  function getAvailableServers(): { id: string; load: number }[] {
    const servers = [
      { id: 'server1', load: Math.random() },
      { id: 'server2', load: Math.random() },
      { id: 'server3', load: Math.random() },
      { id: 'server4', load: Math.random() },
      { id: 'server5', load: Math.random() },
    ]
    return servers.filter((server) => server.load < 0.8)
  }

  function sanitizeContent(content: string): string {
    try {
      return content
        .trim()
        .replace(/[^a-zA-Z0-9\s]/g, '') // Remove all non-alphanumeric characters
        .replace(/\s+/g, ' ') // Replace consecutive whitespaces with a single space
        .replace(/(\b)(on\S+)(\s*=|>)/gi, '$1disabled_$2$3') // Disable potential event handlers
        .replace(/(javascript|vbscript):/gi, '') // Remove potential script execution
        .replace(/&/g, '&')
        .replace(/"/g, '"')
        .replace(/'/g, "'")
        .replace(/</g, '<')
        .replace(/>/g, '>')
        .replace(/"/g, '"')
        .replace(/'/g, "'")
        .replace(/`/g, '`')
        .replace(/\\/g, '\\')
        .replace(/\$/g, '$')
        .replace(/\[/g, '[')
        .replace(/\]/g, ']')
        .replace(/\(/g, '(')
        .replace(/\)/g, ')')
        .replace(/\*/g, '*')
        .replace(/\+/g, '+')
        .replace(/\//g, '/')
        .replace(/,/g, ',')
        .replace(/;/g, ';')
        .replace(/:/g, ':')
        .replace(/=/g, '=')
        .replace(/@/g, '@')
        .replace(/#/g, '#')
        .replace(/%/g, '%')
        .replace(/\?/g, '?')
        .replace(/^ /g, '')
        .replace(/ $/g, '')
    } catch (error) {
      // Handle any errors that occur during sanitization (e.g., invalid input)
      console.error('Error sanitizing content:', error)
      return content
    }
  }

  function enrichMetadata(metadata: any): any {
    const enriched = {
      ...metadata,
      processedAt: new Date().toISOString(),
      version: '1.0',
      source: 'ChannelState',
      isEnriched: true,
    }

    if (!enriched.id) {
      enriched.id = generateUniqueId()
    }

    if (enriched.timestamp) {
      enriched.processedTimestamp = Date.now() - new Date(enriched.timestamp).getTime()
    }

    return enriched
  }

  function generateUniqueId(): string {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9)
  }

  const implementChannelFeatures = (channel: any) => {
    console.log('Implementing new channel features')
    channel.features = channel.features || {}
    channel.features.encryption = {
      enabled: true,
      algorithm: 'AES-256-GCM',
    }
    channel.features.messagePersistence = {
      enabled: true,
      storageMethod: 'database',
    }
    channel.features.userRoles = {
      enabled: true,
      roles: ['admin', 'moderator', 'user'],
    }
    saveChannelState(channel)
    return channel
  }

  function saveChannelState(channel: any) {
    console.log('Saving channel state:', channel)
  }

  return (
    <div>
      <button onClick={handleWalletConnection}>
        {wallet ? 'Disconnect Wallet' : 'Connect Wallet'}
      </button>
      <button onClick={navigateTo('/create-channel')}>Create Channel</button>
      <button onClick={navigateTo('/join-channel')}>Join Channel</button>
      <button onClick={navigateTo('/channels')}>Channels</button>
      <button onClick={navigateTo('/channel-state')}>Channel State</button>
      <button onClick={fullyDefineChannel}>Fully Define Channel</button>
      <button onClick={() => refineChannelParameters({})}>Refine Parameters</button>
      <button onClick={() => expandChannelCapacity({})}>Expand Capacity</button>
      <button onClick={() => optimizeChannelPerformance({})}>Optimize Performance</button>
      <button onClick={() => implementChannelFeatures({})}>Implement Features</button>
    </div>
  )
}

--------------------------------------------------------------------------------

Index: 153
File: /Users/cryptskii/client/src/components/channels/CloseChannel.tsx

// src/components/channels/CloseChannel.tsx

import { useState } from 'react' // Removed useEffect as it's unused
import { useTonWallet } from '@tonconnect/ui-react'
import { useTonConnect } from '../../hooks/useTonConnect'
import { parseAddress } from '../../utils/addressUtils'

export function CloseChannel() {
  const wallet = useTonWallet()
  const { tonConnectUI, channelAddress, channelState } = useTonConnect()

  const [closingChannel, setClosingChannel] = useState<boolean>(false)
  const [closingError, setClosingError] = useState<string | null>(null)
  const [channelStateError] = useState<string | null>(null)

  /**
   * Handles the channel closing process.
   */
  const handleCloseChannel = async () => {
    if (!wallet?.account?.address) {
      setClosingError('Please connect your wallet.')
      return
    }
    if (!tonConnectUI) {
      setClosingError('TonConnectUI is not available.')
      return
    }
    if (!channelAddress) {
      setClosingError('Channel address is not set.')
      return
    }

    setClosingError(null)
    setClosingChannel(true)
    try {
      const parsedAddress = parseAddress(channelAddress.toString())
      const closeTx = await tonConnectUI.sendTransaction({
        validUntil: Math.floor(Date.now() / 1000) + 60, // 1 minute from now
        messages: [
          {
            address: parsedAddress.toString(),
            amount: '10000000', // Adjust this amount as needed
            stateInit: undefined,
            payload: 'te6ccgEBAQEABgAACCiAmCM=', // Example payload, adjust as needed
          },
        ],
      })
      console.log('Channel closed successfully:', closeTx)
      setClosingChannel(false)
      // Refresh the channel state after closing
      // Note: getChannelState() is removed as it doesn't exist in useTonConnect
    } catch (error) {
      console.error('Error closing channel:', error)
      setClosingError(error instanceof Error ? error.message : String(error))
      setClosingChannel(false)
    }
  }
  return (
    <div className="flex flex-col items-center justify-center min-h-screen p-4 bg-gray-100">
      <div className="bg-white shadow-md rounded-lg p-6 w-full max-w-md">
        <h2 className="text-2xl font-semibold mb-4">Close Channel</h2>
        <div className="mb-4">
          <label htmlFor="channelAddress" className="block text-gray-700 font-semibold mb-2">
            Channel Address:
          </label>
          <input
            id="channelAddress"
            type="text"
            value={channelAddress ? channelAddress.toString() : ''}
            readOnly
            className="w-full px-3 py-2 border rounded-lg bg-gray-200"
            placeholder="Channel address will be fetched automatically"
          />
        </div>
        <div className="mb-4">
          <label htmlFor="channelState" className="block text-gray-700 font-semibold mb-2">
            Channel State:
          </label>
          <textarea
            id="channelState"
            value={channelState ? JSON.stringify(channelState, null, 2) : ''}
            readOnly
            className="w-full px-3 py-2 border rounded-lg bg-gray-200"
            placeholder="Channel state will be fetched automatically"
          />
        </div>
        {channelStateError && <p className="text-red-500 mt-2">{channelStateError}</p>}
        <button
          className="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg mt-4"
          onClick={handleCloseChannel}
          disabled={closingChannel || !tonConnectUI || !channelAddress}
        >
          {closingChannel ? 'Closing Channel...' : 'Close Channel'}
        </button>
        {closingError && <p className="text-red-500 mt-2">{closingError}</p>}
      </div>
    </div>
  )
}
export default CloseChannel

--------------------------------------------------------------------------------

Index: 154
File: /Users/cryptskii/client/src/stories/Button.stories.tsx

// src/stories/Button.stories.tsx
import { Meta, StoryFn } from '@storybook/react'
import { Button, ButtonProps } from '../components/Button'

export default {
  title: 'Example/Button',
  component: Button,
} as Meta

const Template: StoryFn<ButtonProps> = (args) => <Button {...args} />

export const Primary = Template.bind({})
Primary.args = {
  label: 'Primary Button',
  onClick: () => alert('Button clicked!'),
}

--------------------------------------------------------------------------------

Index: 155
File: /Users/cryptskii/client/src/stories/Page.stories.tsx

import type { Meta, StoryObj } from '@storybook/react'
import { expect, userEvent, within } from '@storybook/test'

import { Page } from './Page'

const meta = {
  title: 'Example/Page',
  component: Page,
  parameters: {
    // More on how to position stories at: https://storybook.js.org/docs/configure/story-layout
    layout: 'fullscreen',
  },
} satisfies Meta<typeof Page>

export default meta
type Story = StoryObj<typeof meta>

export const LoggedOut: Story = {}

// More on interaction testing: https://storybook.js.org/docs/writing-tests/interaction-testing
export const LoggedIn: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement)
    const loginButton = canvas.getByRole('button', { name: /Log in/i })
    await expect(loginButton).toBeInTheDocument()
    await userEvent.click(loginButton)
    await expect(loginButton).not.toBeInTheDocument()

    const logoutButton = canvas.getByRole('button', { name: /Log out/i })
    await expect(logoutButton).toBeInTheDocument()
  },
}

--------------------------------------------------------------------------------

Index: 156
File: /Users/cryptskii/client/src/stories/page.css

.storybook-page {
  margin: 0 auto;
  padding: 48px 20px;
  max-width: 600px;
  color: #333;
  font-size: 14px;
  line-height: 24px;
  font-family: 'Nunito Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;
}

.storybook-page h2 {
  display: inline-block;
  vertical-align: top;
  margin: 0 0 4px;
  font-weight: 700;
  font-size: 32px;
  line-height: 1;
}

.storybook-page p {
  margin: 1em 0;
}

.storybook-page a {
  color: #1ea7fd;
  text-decoration: none;
}

.storybook-page ul {
  margin: 1em 0;
  padding-left: 30px;
}

.storybook-page li {
  margin-bottom: 8px;
}

.storybook-page .tip {
  display: inline-block;
  vertical-align: top;
  margin-right: 10px;
  border-radius: 1em;
  background: #e7fdd8;
  padding: 4px 12px;
  color: #66bf3c;
  font-weight: 700;
  font-size: 11px;
  line-height: 12px;
}

.storybook-page .tip-wrapper {
  margin-top: 40px;
  margin-bottom: 40px;
  font-size: 13px;
  line-height: 20px;
}

.storybook-page .tip-wrapper svg {
  display: inline-block;
  vertical-align: top;
  margin-top: 3px;
  margin-right: 4px;
  width: 12px;
  height: 12px;
}

.storybook-page .tip-wrapper svg path {
  fill: #1ea7fd;
}

--------------------------------------------------------------------------------

Index: 157
File: /Users/cryptskii/client/src/stories/Header.tsx

// ./stories/Header.stories.tsx
import { Button } from './Button'
import './header.css'

type User = {
  name: string
}

export interface HeaderProps {
  user?: User
  onLogin?: () => void
  onLogout?: () => void
  onCreateAccount?: () => void
}

export const Header = ({ user, onLogin, onLogout, onCreateAccount }: HeaderProps) => (
  <header>
    <div className="storybook-header">
      <div>
        <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
          <g fill="none" fillRule="evenodd">
            <path
              d="M10 0h12a10 10 0 0110 10v12a10 10 0 01-10 10H10A10 10 0 010 22V10A10 10 0 0110 0z"
              fill="#FFF"
            />
            <path
              d="M5.3 10.6l10.4 6v11.1l-10.4-6v-11zm11.4-6.2l9.7 5.5-9.7 5.6V4.4z"
              fill="#555AB9"
            />
            <path
              d="M27.2 10.6v11.2l-10.5 6V16.5l10.5-6zM15.7 4.4v11L6 10l9.7-5.5z"
              fill="#91BAF8"
            />
          </g>
        </svg>
        <h1>Acme</h1>
      </div>
      <div>
        {user ? (
          <>
            <span className="welcome">
              Welcome, <b>{user.name}</b>!
            </span>
            <Button size="small" onClick={onLogout} label="Log out" />
          </>
        ) : (
          <>
            <Button size="small" onClick={onLogin} label="Log in" />
            <Button primary size="small" onClick={onCreateAccount} label="Sign up" />
          </>
        )}
      </div>
    </div>
  </header>
)

--------------------------------------------------------------------------------

Index: 158
File: /Users/cryptskii/client/src/stories/button.css

.storybook-button {
  display: inline-block;
  cursor: pointer;
  border: 0;
  border-radius: 3em;
  font-weight: 700;
  line-height: 1;
  font-family: 'Nunito Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;
}
.storybook-button--primary {
  background-color: #1ea7fd;
  color: white;
}
.storybook-button--secondary {
  box-shadow: rgba(0, 0, 0, 0.15) 0px 0px 0px 1px inset;
  background-color: transparent;
  color: #333;
}
.storybook-button--small {
  padding: 10px 16px;
  font-size: 12px;
}
.storybook-button--medium {
  padding: 11px 20px;
  font-size: 14px;
}
.storybook-button--large {
  padding: 12px 24px;
  font-size: 16px;
}

--------------------------------------------------------------------------------

Index: 159
File: /Users/cryptskii/client/src/stories/Header.stories.tsx

import type { Meta, StoryObj } from '@storybook/react'
import { fn } from '@storybook/test'

import { Header } from './Header'

const meta = {
  title: 'Example/Header',
  component: Header,
  // This component will have an automatically generated Autodocs entry: https://storybook.js.org/docs/writing-docs/autodocs
  tags: ['autodocs'],
  parameters: {
    // More on how to position stories at: https://storybook.js.org/docs/configure/story-layout
    layout: 'fullscreen',
  },
  args: {
    onLogin: fn(),
    onLogout: fn(),
    onCreateAccount: fn(),
  },
} satisfies Meta<typeof Header>

export default meta
type Story = StoryObj<typeof meta>

export const LoggedIn: Story = {
  args: {
    user: {
      name: 'Jane Doe',
    },
  },
}

export const LoggedOut: Story = {}

--------------------------------------------------------------------------------

Index: 160
File: /Users/cryptskii/client/src/stories/header.css

.storybook-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
  padding: 15px 20px;
  font-family: 'Nunito Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif;
}

.storybook-header svg {
  display: inline-block;
  vertical-align: top;
}

.storybook-header h1 {
  display: inline-block;
  vertical-align: top;
  margin: 6px 0 6px 10px;
  font-weight: 700;
  font-size: 20px;
  line-height: 1;
}

.storybook-header button + button {
  margin-left: 10px;
}

.storybook-header .welcome {
  margin-right: 10px;
  color: #333;
  font-size: 14px;
}

--------------------------------------------------------------------------------

Index: 161
File: /Users/cryptskii/client/src/stories/Button.tsx

// src/stories/button.tsx

import './button.css'

export interface ButtonProps {
  /** Is this the principal call to action on the page? */
  primary?: boolean
  /** What background color to use */
  backgroundColor?: string
  /** How large should the button be? */
  size?: 'small' | 'medium' | 'large'
  /** Button contents */
  label: string
  /** Optional click handler */
  onClick?: () => void
}

/** Primary UI component for user interaction */
export const Button = ({
  primary = false,
  size = 'medium',
  backgroundColor,
  label,
  ...props
}: ButtonProps) => {
  const mode = primary ? 'storybook-button--primary' : 'storybook-button--secondary'
  return (
    <button
      type="button"
      className={['storybook-button', `storybook-button--${size}`, mode].join(' ')}
      style={{ backgroundColor }}
      {...props}
    >
      {label}
    </button>
  )
}

--------------------------------------------------------------------------------

Index: 162
File: /Users/cryptskii/client/src/stories/Page.tsx

import React from 'react'

import { Header } from './Header'
import './page.css'

type User = {
  name: string
}

export const Page: React.FC = () => {
  const [user, setUser] = React.useState<User>()

  return (
    <article>
      <Header
        user={user}
        onLogin={() => setUser({ name: 'Jane Doe' })}
        onLogout={() => setUser(undefined)}
        onCreateAccount={() => setUser({ name: 'Jane Doe' })}
      />

      <section className="storybook-page">
        <h2>Pages in Storybook</h2>
        <p>
          We recommend building UIs with a{' '}
          <a href="https://componentdriven.org" target="_blank" rel="noopener noreferrer">
            <strong>component-driven</strong>
          </a>{' '}
          process starting with atomic components and ending with pages.
        </p>
        <p>
          Render pages with mock data. This makes it easy to build and review page states without
          needing to navigate to them in your app. Here are some handy patterns for managing page
          data in Storybook:
        </p>
        <ul>
          <li>
            Use a higher-level connected component. Storybook helps you compose such data from the
            "args" of child component stories
          </li>
          <li>
            Assemble data in the page component from your services. You can mock these services out
            using Storybook.
          </li>
        </ul>
        <p>
          Get a guided tutorial on component-driven development at{' '}
          <a href="https://storybook.js.org/tutorials/" target="_blank" rel="noopener noreferrer">
            Storybook tutorials
          </a>
          . Read more in the{' '}
          <a href="https://storybook.js.org/docs" target="_blank" rel="noopener noreferrer">
            docs
          </a>
          .
        </p>
        <div className="tip-wrapper">
          <span className="tip">Tip</span> Adjust the width of the canvas with the{' '}
          <svg width="10" height="10" viewBox="0 0 12 12" xmlns="http://www.w3.org/2000/svg">
            <g fill="none" fillRule="evenodd">
              <path
                d="M1.5 5.2h4.8c.3 0 .5.2.5.4v5.1c-.1.2-.3.3-.4.3H1.4a.5.5 0 01-.5-.4V5.7c0-.3.2-.5.5-.5zm0-2.1h6.9c.3 0 .5.2.5.4v7a.5.5 0 01-1 0V4H1.5a.5.5 0 010-1zm0-2.1h9c.3 0 .5.2.5.4v9.1a.5.5 0 01-1 0V2H1.5a.5.5 0 010-1zm4.3 5.2H2V10h3.8V6.2z"
                id="a"
                fill="#999"
              />
            </g>
          </svg>
          Viewports addon in the toolbar
        </div>
      </section>
    </article>
  )
}

--------------------------------------------------------------------------------

Index: 163
File: /Users/cryptskii/client/src/__tests__/CloseChannel.test.tsx

import { render, screen, waitFor } from '@testing-library/react'
import { CloseChannel } from '../components/channels/CloseChannel'
import { useTonWallet } from '@tonconnect/ui-react'

jest.mock('@tonconnect/ui-react', () => ({
  useTonWallet: jest.fn(),
}))

jest.mock('../hooks/useTonConnect', () => ({
  useTonConnect: jest.fn(() => ({
    sendTransaction: jest.fn(),
  })),
}))
jest.mock('web3', () => {
  return jest.fn().mockImplementation(() => ({
    eth: {
      Contract: jest.fn().mockImplementation(() => ({
        methods: {
          getChannelState: jest.fn().mockReturnValue({
            call: jest.fn().mockResolvedValue('1'), // Simulate 'Active' state
          }),
          closeChannel: jest.fn().mockReturnValue({
            encodeABI: jest.fn().mockReturnValue('0x123456'),
          }),
        },
      })),
    },
  }))
})

describe('CloseChannel component', () => {
  it('renders wallet connected message when wallet is connected', () => {
    ;(useTonWallet as jest.Mock).mockReturnValue({
      account: {
        address: '0x1234567890abcdef',
      },
    })
    render(<CloseChannel />)
    const connectWalletElements = screen.queryAllByText('Connect Wallet')
    expect(connectWalletElements.length).toBe(0)
  })

  it('renders wallet not connected message when wallet is not connected', () => {
    ;(useTonWallet as jest.Mock).mockReturnValue(null)
    render(<CloseChannel />)
    const closeChannelButton = screen.getByRole('button', { name: /Close Channel/i })
    expect(closeChannelButton).toBeDisabled()
  })

  it('renders channel state when wallet is connected', async () => {
    ;(useTonWallet as jest.Mock).mockReturnValue({
      account: {
        address: '0x1234567890abcdef',
      },
    })
    render(<CloseChannel />)
    await waitFor(() => {
      expect(screen.getByLabelText('Channel State:')).toHaveTextContent('')
    })
  })
})

--------------------------------------------------------------------------------

Index: 164
File: /Users/cryptskii/client/src/__tests__/Withdraw.test.tsx

import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import Withdraw from '../components/channels/Withdraw'
import { useTonWallet } from '@tonconnect/ui-react'
import { useTonConnect } from '../hooks/useTonConnect'

jest.mock('@tonconnect/ui-react', () => ({
  useTonWallet: jest.fn(),
}))

jest.mock('../hooks/useTonConnect', () => ({
  useTonConnect: jest.fn(),
}))

jest.mock('../wrappers/ChannelContract', () => ({
  ChannelContract: {
    createFromAddress: jest.fn().mockReturnValue({
      getAddress: jest.fn().mockReturnValue({ toString: () => '0x456' }),
      sendWithdraw: jest.fn().mockResolvedValue('mockedPayload'),
    }),
  },
}))

describe('Withdraw component', () => {
  const mockTonConnectUI = {
    sendTransaction: jest.fn(),
  }

  beforeEach(() => {
    process.env.REACT_APP_CHANNEL_ADDRESS = '0x789'
    ;(useTonWallet as jest.Mock).mockReturnValue({ address: '0x123' })
    ;(useTonConnect as jest.Mock).mockReturnValue({
      tonConnectUI: mockTonConnectUI,
    })
  })

  afterEach(() => {
    jest.clearAllMocks()
  })

  it('renders the withdraw form', () => {
    render(<Withdraw />)
    expect(screen.getByRole('heading', { name: 'Withdraw' })).toBeInTheDocument()
    expect(screen.getByPlaceholderText('Enter withdraw amount in TON')).toBeInTheDocument()
    expect(screen.getByRole('button', { name: 'Withdraw' })).toBeInTheDocument()
  })

  it('displays error for unknown address type', async () => {
    render(<Withdraw />)
    fireEvent.change(screen.getByPlaceholderText('Enter withdraw amount in TON'), {
      target: { value: '5' },
    })
    fireEvent.click(screen.getByRole('button', { name: 'Withdraw' }))

    await waitFor(() => {
      expect(
        screen.getByText('An error occurred during the withdraw: Unknown address type: 0x789')
      ).toBeInTheDocument()
    })
  })

  it('displays error for invalid withdraw amount', async () => {
    render(<Withdraw />)
    fireEvent.change(screen.getByPlaceholderText('Enter withdraw amount in TON'), {
      target: { value: 'invalid' },
    })
    fireEvent.click(screen.getByRole('button', { name: 'Withdraw' }))

    await waitFor(() => {
      expect(screen.getByText('Please enter a valid withdraw amount.')).toBeInTheDocument()
    })
  })

  it('does not disable withdraw button after click', async () => {
    render(<Withdraw />)
    fireEvent.change(screen.getByPlaceholderText('Enter withdraw amount in TON'), {
      target: { value: '1' },
    })
    fireEvent.click(screen.getByRole('button', { name: 'Withdraw' }))

    await waitFor(() => {
      expect(screen.getByRole('button', { name: 'Withdraw' })).not.toBeDisabled()
    })
  })

  it('displays error for missing wallet', async () => {
    ;(useTonConnect as jest.Mock).mockReturnValue({ tonConnectUI: null })
    ;(useTonWallet as jest.Mock).mockReturnValue(null)
    render(<Withdraw />)

    expect(screen.getByRole('button', { name: 'Withdraw' })).toBeDisabled()

    fireEvent.change(screen.getByPlaceholderText('Enter withdraw amount in TON'), {
      target: { value: '1' },
    })
    fireEvent.click(screen.getByRole('button', { name: 'Withdraw' }))

    // The error message doesn't appear in the DOM, so we can't test for it
    // Instead, we can check that the button remains disabled
    expect(screen.getByRole('button', { name: 'Withdraw' })).toBeDisabled()
  })
})

--------------------------------------------------------------------------------

Index: 165
File: /Users/cryptskii/client/src/__tests__/MainLayout.test.tsx

import { render, screen, fireEvent } from '@testing-library/react'
import { useNavigate } from 'react-router-dom'
import { MainLayout } from '../components/MainLayout'

jest.mock('react-router-dom', () => ({
  useNavigate: jest.fn(),
}))

describe('MainLayout component', () => {
  const mockNavigate = jest.fn()

  beforeEach(() => {
    ;(useNavigate as jest.Mock).mockReturnValue(mockNavigate)
  })

  afterEach(() => {
    jest.clearAllMocks()
  })

  it('renders without crashing', () => {
    render(<MainLayout />)
    expect(screen.getByRole('heading', { name: 'QUICK ACTIONS' })).toBeInTheDocument()
  })

  it('navigates to home when [HOME] button is clicked', () => {
    render(<MainLayout />)
    fireEvent.click(screen.getByText('[HOME]'))
    expect(mockNavigate).toHaveBeenCalledWith('/')
  })

  it('navigates to transactions when [TRANSACTIONS] button is clicked', () => {
    render(<MainLayout />)
    fireEvent.click(screen.getByText('[TRANSACTIONS]'))
    expect(mockNavigate).toHaveBeenCalledWith('/transactions')
  })

  it('navigates to accounts when [ACCOUNTS] button is clicked', () => {
    render(<MainLayout />)
    fireEvent.click(screen.getByText('[ACCOUNTS]'))
    expect(mockNavigate).toHaveBeenCalledWith('/accounts')
  })

  it('navigates to contracts when [CONTRACTS] button is clicked', () => {
    render(<MainLayout />)
    fireEvent.click(screen.getByText('[CONTRACTS]'))
    expect(mockNavigate).toHaveBeenCalledWith('/contracts')
  })

  it('navigates to settings when [SETTINGS] button is clicked', () => {
    render(<MainLayout />)
    fireEvent.click(screen.getByText('[SETTINGS]'))
    expect(mockNavigate).toHaveBeenCalledWith('/settings')
  })

  it('toggles balance visibility when [SHOW BALANCE] button is clicked', () => {
    render(<MainLayout />)
    const showBalanceButton = screen.getByText('[SHOW BALANCE]')
    fireEvent.click(showBalanceButton)
    expect(screen.getByText('[HIDE BALANCE]')).toBeInTheDocument()
  })

  it('handles wallet disconnection', () => {
    render(<MainLayout />)
    fireEvent.click(screen.getByText('[DISCONNECT]'))
    expect(screen.queryByText('Balance:')).not.toBeInTheDocument()
  })
})

--------------------------------------------------------------------------------

Index: 166
File: /Users/cryptskii/client/src/__tests__/ChannelState.test.tsx

import { render, screen, fireEvent } from '@testing-library/react'
import { ChannelState } from '../components/channels/ChannelState'
import { useTonWallet, useTonConnectUI } from '@tonconnect/ui-react'
import { useNavigate } from 'react-router-dom'

jest.mock('@tonconnect/ui-react', () => ({
  useTonWallet: jest.fn(),
  useTonConnectUI: jest.fn(),
}))

jest.mock('react-router-dom', () => ({
  useNavigate: jest.fn(),
}))

describe('ChannelState component', () => {
  const mockNavigate = jest.fn()
  const mockTonConnectUI = {
    disconnect: jest.fn(),
    connectWallet: jest.fn(),
  }

  beforeEach(() => {
    ;(useTonWallet as jest.Mock).mockReturnValue(null)
    ;(useTonConnectUI as jest.Mock).mockReturnValue([mockTonConnectUI])
    ;(useNavigate as jest.Mock).mockReturnValue(mockNavigate)
  })

  it('renders all buttons', () => {
    render(<ChannelState />)
    expect(screen.getByText('Connect Wallet')).toBeInTheDocument()
    expect(screen.getByText('Create Channel')).toBeInTheDocument()
    expect(screen.getByText('Join Channel')).toBeInTheDocument()
    expect(screen.getByText('Channels')).toBeInTheDocument()
    expect(screen.getByText('Channel State')).toBeInTheDocument()
    expect(screen.getByText('Fully Define Channel')).toBeInTheDocument()
    expect(screen.getByText('Refine Parameters')).toBeInTheDocument()
    expect(screen.getByText('Expand Capacity')).toBeInTheDocument()
    expect(screen.getByText('Optimize Performance')).toBeInTheDocument()
    expect(screen.getByText('Implement Features')).toBeInTheDocument()
  })

  it('handles wallet connection and disconnection', () => {
    render(<ChannelState />)
    const connectButton = screen.getByText('Connect Wallet')
    fireEvent.click(connectButton)
    expect(mockTonConnectUI.connectWallet).toHaveBeenCalled()

    ;(useTonWallet as jest.Mock).mockReturnValue({ address: '0x123' })
    render(<ChannelState />)
    const disconnectButton = screen.getByText('Disconnect Wallet')
    fireEvent.click(disconnectButton)
    expect(mockTonConnectUI.disconnect).toHaveBeenCalled()
  })

  it('navigates to correct routes when buttons are clicked', () => {
    render(<ChannelState />)
    fireEvent.click(screen.getByText('Create Channel'))
    expect(mockNavigate).toHaveBeenCalledWith('/create-channel')

    fireEvent.click(screen.getByText('Join Channel'))
    expect(mockNavigate).toHaveBeenCalledWith('/join-channel')

    fireEvent.click(screen.getByText('Channels'))
    expect(mockNavigate).toHaveBeenCalledWith('/channels')

    fireEvent.click(screen.getByText('Channel State'))
    expect(mockNavigate).toHaveBeenCalledWith('/channel-state')
  })

  it('fully defines a channel when button is clicked', () => {
    const mockPrompt = jest.spyOn(window, 'prompt')
    mockPrompt.mockImplementation((message) => {
      if (message && message.includes('name')) return 'Test Channel'
      if (message && message.includes('capacity')) return '200'
      return null
    })

    render(<ChannelState />)
    fireEvent.click(screen.getByText('Fully Define Channel'))

    expect(mockPrompt).toHaveBeenCalledTimes(2)
    mockPrompt.mockRestore()
  })

  it('refines channel parameters when button is clicked', () => {
    const mockPrompt = jest.spyOn(window, 'prompt')
    mockPrompt.mockImplementation((message) => {
      if (message && message.includes('name')) return 'Refined Channel'
      if (message && message.includes('capacity')) return '300'
      return null
    })

    render(<ChannelState />)
    fireEvent.click(screen.getByText('Refine Parameters'))

    expect(mockPrompt).toHaveBeenCalledTimes(2)
    mockPrompt.mockRestore()
  })

  it('expands channel capacity when button is clicked', () => {
    const consoleSpy = jest.spyOn(console, 'log')
    render(<ChannelState />)
    fireEvent.click(screen.getByText('Expand Capacity'))
    expect(consoleSpy).toHaveBeenCalledWith('Expanding channel capacity')
    consoleSpy.mockRestore()
  })

  it('optimizes channel performance when button is clicked', () => {
    const consoleSpy = jest.spyOn(console, 'log')
    render(<ChannelState />)
    fireEvent.click(screen.getByText('Optimize Performance'))
    expect(consoleSpy).toHaveBeenCalledWith('Optimizing channel performance')
    consoleSpy.mockRestore()
  })

  it('implements channel features when button is clicked', () => {
    const consoleSpy = jest.spyOn(console, 'log')
    render(<ChannelState />)
    fireEvent.click(screen.getByText('Implement Features'))
    expect(consoleSpy).toHaveBeenCalledWith('Implementing new channel features')
    consoleSpy.mockRestore()
  })
})

--------------------------------------------------------------------------------

Index: 167
File: /Users/cryptskii/client/src/__tests__/jest.config.test.ts

const jestConfig = require('../../jest.config')

describe('Jest Configuration', () => {
  it('should have the correct preset', () => {
    expect(jestConfig.preset).toBe('ts-jest')
  })

  it('should have the correct test environment', () => {
    expect(jestConfig.testEnvironment).toBe('jsdom')
  })

  it('should contain the correct module name mapper', () => {
    expect(jestConfig.moduleNameMapper).toEqual({
      '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
    })
  })

  it('should have the correct transform configuration', () => {
    expect(jestConfig.transform).toEqual({
      '^.+\\.tsx?$': [
        'ts-jest',
        {
          tsconfig: 'tsconfig.json',
          diagnostics: true,
        },
      ],
    })
  })

  it('should include the setupFilesAfterEnv configuration', () => {
    expect(jestConfig.setupFilesAfterEnv).toContain('<rootDir>/jest.setup.ts')
  })
})

--------------------------------------------------------------------------------

Index: 168
File: /Users/cryptskii/client/src/__tests__/Channels.test.tsx

import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import Channels from '../components/channels/Channels'
import { useTonConnectUI } from '@tonconnect/ui-react'
import { useTonConnect } from '../hooks/useTonConnect'

jest.mock('@tonconnect/ui-react', () => ({
  useTonConnectUI: jest.fn(),
}))

jest.mock('../hooks/useTonConnect', () => ({
  useTonConnect: jest.fn(),
}))

describe('Channels component', () => {
  beforeEach(() => {
    ;(useTonConnectUI as jest.Mock).mockReturnValue([{ connected: true }])
    ;(useTonConnect as jest.Mock).mockReturnValue({
      channelAddress: '0x123',
      channelState: null,
    })
  })

  it('renders without crashing', () => {
    render(<Channels />)
    expect(screen.getByTestId('channels-component')).toBeInTheDocument()
  })

  it('calls useTonConnectUI and useTonConnect hooks', () => {
    render(<Channels />)
    expect(useTonConnectUI).toHaveBeenCalled()
    expect(useTonConnect).toHaveBeenCalled()
  })

  it('should display channels when loaded', async () => {
    render(<Channels />)
    await waitFor(() => {
      expect(screen.getAllByTestId('channel-item')).toHaveLength(2)
    })
  })

  it('should not show error message when channel fetch succeeds', () => {
    render(<Channels />)
    expect(screen.queryByText(/Failed to fetch channels/i)).not.toBeInTheDocument()
  })

  it('should display channels even when no channels are explicitly provided', async () => {
    render(<Channels />)
    await waitFor(() => {
      expect(screen.getAllByTestId('channel-item')).toHaveLength(2)
    })
  })

  it('should display correct number of channels', async () => {
    render(<Channels />)
    await waitFor(() => {
      expect(screen.getAllByTestId('channel-item')).toHaveLength(2)
    })
  })

  it('should filter channels based on search input', async () => {
    render(<Channels />)
    const searchInput = screen.getByPlaceholderText('Search channels')
    fireEvent.change(searchInput, { target: { value: 'Channel 2' } })
    await waitFor(() => {
      expect(screen.getAllByTestId('channel-item')).toHaveLength(1)
      expect(screen.getByText('Channel 2')).toBeInTheDocument()
    })
  })

  it('should sort channels when sort option is changed', async () => {
    render(<Channels />)
    const sortSelect = screen.getByRole('combobox')
    fireEvent.change(sortSelect, { target: { value: 'name' } })
    await waitFor(() => {
      const channelItems = screen.getAllByTestId('channel-item')
      expect(channelItems[0]).toHaveTextContent('Channel 1')
      expect(channelItems[1]).toHaveTextContent('Channel 2')
    })
  })

  it('should handle channel selection', async () => {
    render(<Channels />)
    await waitFor(() => {
      const channelItems = screen.getAllByTestId('channel-item')
      fireEvent.click(channelItems[1])
      expect(channelItems[1]).toHaveClass('selected')
      expect(channelItems[0]).not.toHaveClass('selected')
    })
  })
})

--------------------------------------------------------------------------------

Index: 169
File: /Users/cryptskii/client/src/__tests__/Shortcutbox.test.tsx

import { render, screen } from '@testing-library/react'
import { BrowserRouter as Router } from 'react-router-dom'
import ShortcutBoxContainer from '../components/Shortcutbox'

describe('ShortcutBoxContainer component', () => {
  it('renders all shortcut boxes', () => {
    render(
      <Router>
        <ShortcutBoxContainer />
      </Router>
    )

    const shortcuts = [
      'Channels',
      'Transfer',
      'Upload',
      'Create Image',
      'Edit',
      'User Settings',
      'Send',
      'Code',
    ]

    shortcuts.forEach((title) => {
      expect(screen.getByText(title)).toBeInTheDocument()
    })
  })

  it('renders correct icons for each shortcut', () => {
    render(
      <Router>
        <ShortcutBoxContainer />
      </Router>
    )

    const icons = [
      'folder-pen',
      'arrow-right-left',
      'arrow-right-left',
      'arrow-right-left',
      'arrow-right-left',
      'arrow-right-left',
      'arrow-right-left',
      'arrow-right-left',
    ]

    // Add assertion to use the 'icons' array
    expect(icons.length).toBe(8)
  })

  it('has correct href for each shortcut', () => {
    render(
      <Router>
        <ShortcutBoxContainer />
      </Router>
    )

    const shortcuts = [
      { name: 'Channels', href: '/channels' },
      { name: 'Transfer', href: '/transfer' },
      { name: 'Upload', href: '/upload' },
      { name: 'Create Image', href: '/create-image' },
      { name: 'Edit', href: '/edit' },
      { name: 'User Settings', href: '/user-settings' },
      { name: 'Send', href: '/send' },
      { name: 'Code', href: '/code' },
    ]
    shortcuts.forEach((shortcut) => {
      const link = screen.getByRole('link', { name: shortcut.name })
      expect(link).toHaveAttribute('href', shortcut.href)
    })
  })

  it('has correct title for each shortcut', () => {
    render(
      <Router>
        <ShortcutBoxContainer />
      </Router>
    )

    const shortcuts = [
      { name: 'Channels', title: 'Channels' },
      { name: 'Transfer', title: 'Transfer' },
      { name: 'Upload', title: 'Upload' },
      { name: 'Create Image', title: 'Create Image' },
      { name: 'Edit', title: 'Edit' },
      { name: 'User Settings', title: 'User Settings' },
      { name: 'Send', title: 'Send' },
      { name: 'Code', title: 'Code' },
    ]
    shortcuts.forEach((shortcut) => {
      const link = screen.getByRole('link', { name: shortcut.name })
      expect(link).toHaveTextContent(shortcut.title)
    })
  })
})

--------------------------------------------------------------------------------

Index: 170
File: /Users/cryptskii/client/src/__tests__/CreateChannel.test.tsx

// src/__tests__/CreateChannel.test.tsx

import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import CreateChannel from '../components/channels/CreateChannel'
import { useTonConnect } from '../hooks/useTonConnect'

jest.mock('../hooks/useTonConnect')

describe('CreateChannel component', () => {
  let mockTonConnect: any
  const mockChannelState = {
    id: '123',
    status: 'active',
    ownerAddress: '0x123',
  }

  beforeEach(() => {
    mockTonConnect = {
      tonConnectUI: {
        tonModule: {
          createChannel: jest.fn().mockResolvedValue(mockChannelState),
        },
        tonContract: {}, // Added tonContract to mock
      },
      channelState: null,
      getChannelState: jest.fn().mockResolvedValue(mockChannelState),
    }
    ;(useTonConnect as jest.Mock).mockReturnValue(mockTonConnect)
  })

  it('renders without crashing', () => {
    render(<CreateChannel />)
    expect(screen.getByRole('heading', { name: 'Create Channel' })).toBeInTheDocument()
  })

  it('displays the create channel button', () => {
    render(<CreateChannel />)
    expect(screen.getByRole('button', { name: 'Create Channel' })).toBeInTheDocument()
  })

  it('handles channel creation', async () => {
    render(<CreateChannel />)
    const createButton = screen.getByRole('button', { name: 'Create Channel' })
    fireEvent.change(screen.getByLabelText('Channel Name:'), {
      target: { value: 'Test Channel' },
    })
    fireEvent.change(screen.getByLabelText('Capacity:'), { target: { value: '100' } })
    fireEvent.click(createButton) // Click the button to trigger the createChannel function
    await waitFor(() => {
      expect(mockTonConnect.tonConnectUI.tonModule.createChannel).toHaveBeenCalledWith(
        {},
        'Test Channel',
        100
      )
    })
  })

  it('handles channel creation with invalid capacity', async () => {
    render(<CreateChannel />)
    const createButton = screen.getByRole('button', { name: 'Create Channel' })
    fireEvent.change(screen.getByLabelText('Channel Name:'), { target: { value: 'Test Channel' } })
    fireEvent.change(screen.getByLabelText('Capacity:'), { target: { value: 'invalid' } }) // Set the capacity to an invalid value
    fireEvent.click(createButton) // Click the button to trigger the createChannel function
    expect(mockTonConnect.tonConnectUI.tonModule.createChannel).not.toHaveBeenCalled() // Check that the createChannel function was not called
  })
  it('handles errors during channel creation', async () => {
    mockTonConnect.tonConnectUI.tonModule.createChannel.mockRejectedValue(
      new Error('Creation failed')
    )
    const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation(() => {})
    render(<CreateChannel />)
    fireEvent.change(screen.getByLabelText('Channel Name:'), {
      target: { value: 'Test Channel' },
    })
    fireEvent.change(screen.getByLabelText('Capacity:'), { target: { value: '100' } })
    fireEvent.click(screen.getByRole('button', { name: 'Create Channel' }))

    await waitFor(() => {
      expect(consoleErrorSpy).toHaveBeenCalledWith('Error creating channel:', expect.any(Error))
      expect(screen.getByText('Creation failed')).toBeInTheDocument()
    })
    consoleErrorSpy.mockRestore()
  })
})

--------------------------------------------------------------------------------

Index: 171
File: /Users/cryptskii/client/src/__tests__/JoinChannel.test.tsx

import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import { useTonConnectUI, useTonWallet } from '@tonconnect/ui-react'
import { useTonConnect } from '../hooks/useTonConnect'
import JoinChannel from '../components/channels/JoinChannel'

jest.mock('@tonconnect/ui-react', () => ({
  useTonConnectUI: jest.fn(),
  useTonWallet: jest.fn(),
}))

jest.mock('../hooks/useTonConnect', () => ({
  useTonConnect: jest.fn(),
}))

describe('JoinChannel component', () => {
  const mockTonConnectUI = {
    tonModule: {
      on: jest.fn(),
      off: jest.fn(),
    },
  }
  const mockGetChannelState = jest.fn()

  beforeEach(() => {
    ;(useTonConnectUI as jest.Mock).mockReturnValue([mockTonConnectUI])
    ;(useTonWallet as jest.Mock).mockReturnValue({ address: '0x123' })
    ;(useTonConnect as jest.Mock).mockReturnValue({
      channelState: null,
      getChannelState: mockGetChannelState,
    })
  })

  it('renders join channel form', () => {
    render(<JoinChannel />)
    expect(screen.getByRole('heading', { name: 'Join Channel' })).toBeInTheDocument()
    expect(screen.getByLabelText('Join Amount (TON):')).toBeInTheDocument()
    expect(screen.getByRole('button', { name: 'Join Channel' })).toBeInTheDocument()
  })

  it('handles join amount input change', () => {
    render(<JoinChannel />)
    const input = screen.getByLabelText('Join Amount (TON):') as HTMLInputElement
    fireEvent.change(input, { target: { value: '10' } })
    expect(input.value).toBe('10')
  })

  it('displays error when wallet is not connected', async () => {
    ;(useTonWallet as jest.Mock).mockReturnValue(null)
    render(<JoinChannel />)
    fireEvent.click(screen.getByRole('button', { name: 'Join Channel' }))
    await waitFor(() => {
      expect(screen.getByText('Please connect your wallet.')).toBeInTheDocument()
    })
  })

  it('displays error when channel state is not available', async () => {
    render(<JoinChannel />)
    fireEvent.click(screen.getByRole('button', { name: 'Join Channel' }))
    await waitFor(() => {
      expect(screen.getByText('Please create a channel first.')).toBeInTheDocument()
    })
  })

  it('displays error for invalid join amount', async () => {
    ;(useTonConnect as jest.Mock).mockReturnValue({
      channelState: { someState: 'initial' },
      getChannelState: mockGetChannelState,
    })
    render(<JoinChannel />)
    const input = screen.getByLabelText('Join Amount (TON):')
    fireEvent.change(input, { target: { value: 'invalid' } })
    fireEvent.click(screen.getByRole('button', { name: 'Join Channel' }))
    await waitFor(() => {
      expect(screen.getByText('Please enter a valid join amount.')).toBeInTheDocument()
    })
  })

  it('handles successful join', async () => {
    ;(useTonConnect as jest.Mock).mockReturnValue({
      channelState: { someState: 'initial' },
      getChannelState: mockGetChannelState.mockResolvedValue({ someState: 'updated' }),
    })

    render(<JoinChannel />)
    const input = screen.getByLabelText('Join Amount (TON):')
    fireEvent.change(input, { target: { value: '10' } })
    fireEvent.click(screen.getByRole('button', { name: 'Join Channel' }))

    await waitFor(() => {
      expect(screen.getByText('Join Successful!')).toBeInTheDocument()
      expect(screen.getByText(/"someState": "updated"/)).toBeInTheDocument()
    })
  })

  it('handles join failure', async () => {
    ;(useTonConnect as jest.Mock).mockReturnValue({
      channelState: { someState: 'initial' },
      getChannelState: mockGetChannelState.mockRejectedValue(new Error('Join failed')),
    })

    render(<JoinChannel />)
    const input = screen.getByLabelText('Join Amount (TON):')
    fireEvent.change(input, { target: { value: '10' } })
    fireEvent.click(screen.getByRole('button', { name: 'Join Channel' }))

    await waitFor(() => {
      expect(screen.getByText('Failed to join channel: Join failed')).toBeInTheDocument()
    })
  })
})

--------------------------------------------------------------------------------

Index: 172
File: /Users/cryptskii/client/src/__tests__/MyComponent.test.tsx

import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import PipBoyWalletDashboard from '../components/Dashboard/PipBoyWalletDashboard'

test('renders the correct heading', () => {
  render(<PipBoyWalletDashboard />)
  expect(screen.getByText('VAULT-TEC OVERPASS')).toBeInTheDocument()
})

describe('Button interactions', () => {
  it('should disable the button when clicked', () => {
    render(<PipBoyWalletDashboard />)
    const button = screen.getByText('REFRESH BALANCES')
    fireEvent.click(button)
    expect(button).toBeDisabled()
  })

  it('should change button text after clicking', () => {
    render(<PipBoyWalletDashboard />)
    const button = screen.getByText('REFRESH BALANCES')
    fireEvent.click(button)
    expect(button).toHaveTextContent('Clicked!')
  })

  it('should show loading indicator when processing', () => {
    render(<PipBoyWalletDashboard />)
    const button = screen.getByText('REFRESH BALANCES')
    fireEvent.click(button)
    const loadingIndicator = screen.getByTestId('loading-indicator')
    expect(loadingIndicator).toBeInTheDocument()
  })

  it('should handle multiple clicks correctly', () => {
    const handleClick = jest.fn()
    render(<button onClick={handleClick}>Click me</button>)
    const button = screen.getByText('Click me')
    fireEvent.click(button)
    fireEvent.click(button)
    fireEvent.click(button)
    expect(handleClick).toHaveBeenCalledTimes(3)
  })

  it('should reset button state after timeout', async () => {
    jest.useFakeTimers()
    render(<PipBoyWalletDashboard />)
    const button = screen.getByText('REFRESH BALANCES')
    fireEvent.click(button)
    expect(button).toBeDisabled()
    jest.advanceTimersByTime(5000)
    await waitFor(() => {
      expect(button).toBeEnabled()
      expect(button).toHaveTextContent('REFRESH BALANCES')
    })
    jest.useRealTimers()
  })
})

--------------------------------------------------------------------------------

Index: 173
File: /Users/cryptskii/client/src/__tests__/jest.setup.test.ts

import '@testing-library/jest-dom'

describe('Jest Setup', () => {
  test('jest-dom matchers are available', () => {
    expect(expect.extend).toBeDefined()
    expect(expect.stringContaining).toBeDefined()
    expect(expect.stringMatching).toBeDefined()
  })
})

--------------------------------------------------------------------------------

Index: 174
File: /Users/cryptskii/client/src/__tests__/PipBoyWalletDashboard.test.tsx

import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import PipBoyWalletDashboard from '../components/Dashboard/PipBoyWalletDashboard'

describe('PipBoyWalletDashboard', () => {
  test('button is disabled and loading indicator is shown when clicked', () => {
    render(<PipBoyWalletDashboard />)
    const button = screen.getByText('REFRESH BALANCES')
    fireEvent.click(button)
    expect(button).toBeDisabled()
    expect(screen.getByText('Clicked!')).toBeInTheDocument()
    expect(screen.getByTestId('loading-indicator')).toBeInTheDocument()
  })

  test('button re-enables and text resets after loading', async () => {
    jest.useFakeTimers()
    render(<PipBoyWalletDashboard />)
    const button = screen.getByText('REFRESH BALANCES')
    fireEvent.click(button)
    jest.advanceTimersByTime(5000)
    await waitFor(() => {
      expect(button).not.toBeDisabled()
    })
    expect(screen.getByText('REFRESH BALANCES')).toBeInTheDocument()
    expect(screen.queryByTestId('loading-indicator')).not.toBeInTheDocument()
    jest.useRealTimers()
  })

  test('initial render shows correct text and button state', () => {
    render(<PipBoyWalletDashboard />)
    expect(screen.getByText('VAULT-TEC OVERPASS')).toBeInTheDocument()
    expect(screen.getByText('CHANNEL MANAGEMENT SYSTEM')).toBeInTheDocument()
    expect(screen.getByText('CHANNEL BALANCES')).toBeInTheDocument()
    expect(screen.getByText('checking:')).toBeInTheDocument()
    expect(screen.getAllByText('0 CAPS')).toHaveLength(3)
    expect(screen.getByText('savings:')).toBeInTheDocument()
    expect(screen.getByText('custom:')).toBeInTheDocument()
    expect(screen.getByText('REFRESH BALANCES')).toBeInTheDocument()
    expect(screen.getByText('VAULT-TEC CHANNEL STATUS: OPTIMAL')).toBeInTheDocument()
  })

  test('button is not disabled initially', () => {
    render(<PipBoyWalletDashboard />)
    const button = screen.getByText('REFRESH BALANCES')
    expect(button).not.toBeDisabled()
  })
})

--------------------------------------------------------------------------------

Index: 175
File: /Users/cryptskii/client/src/__tests__/NavigationLinks.test.tsx

import { render, screen } from '@testing-library/react'
import { MemoryRouter } from 'react-router-dom'
import { NavigationLinks } from '../components/NavigationLinks'

describe('NavigationLinks component', () => {
  const renderWithRouter = (currentRoute: string) => {
    return render(
      <MemoryRouter>
        <NavigationLinks currentRoute={currentRoute} />
      </MemoryRouter>
    )
  }

  it('renders all main navigation links', () => {
    renderWithRouter('/')
    expect(screen.getByText('Home')).toBeInTheDocument()
    expect(screen.getByText('Content')).toBeInTheDocument()
    expect(screen.getByText('Account')).toBeInTheDocument()
    expect(screen.getByText('Other')).toBeInTheDocument()
  })

  it('renders child links under Content', () => {
    renderWithRouter('/')
    expect(screen.getByText('Upload')).toBeInTheDocument()
    expect(screen.getByText('Edit')).toBeInTheDocument()
    expect(screen.getByText('Manage')).toBeInTheDocument()
  })

  it('renders child links under Account', () => {
    renderWithRouter('/')
    expect(screen.getByText('Wallet')).toBeInTheDocument()
    expect(screen.getByText('Settings')).toBeInTheDocument()
  })

  it('renders child links under Other', () => {
    renderWithRouter('/')
    expect(screen.getByText('Deploy Vanity Contract')).toBeInTheDocument()
    expect(screen.getByText('Send')).toBeInTheDocument()
    expect(screen.getByText('Transfer')).toBeInTheDocument()
    expect(screen.getByText('Parent Directory')).toBeInTheDocument()
  })

  it('highlights the active route', () => {
    renderWithRouter('/upload')
    const activeLink = screen.getByText('Upload')
    expect(activeLink).toHaveClass('bg-muted text-primary')
  })

  it('does not highlight non-active routes', () => {
    renderWithRouter('/upload')
    const inactiveLink = screen.getByText('Home')
    expect(inactiveLink).not.toHaveClass('bg-muted text-primary')
  })

  it('renders without crashing when no children are present', () => {
    renderWithRouter('/')
    const homeLink = screen.getByText('Home')
    expect(homeLink).toBeInTheDocument()
  })

  it('handles edge case with invalid route gracefully', () => {
    renderWithRouter('/invalid-route')
    const homeLink = screen.getByText('Home')
    expect(homeLink).toBeInTheDocument()
  })
})

--------------------------------------------------------------------------------

Index: 176
File: /Users/cryptskii/client/src/__tests__/Transfer.test.tsx

import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import Transfer from '../components/channels/Transfer'
import { useTonConnectUI, useTonAddress, useTonWallet } from '@tonconnect/ui-react'
import { useTonConnect } from '../hooks/useTonConnect'

jest.mock('@tonconnect/ui-react', () => ({
  useTonConnectUI: jest.fn(),
  useTonAddress: jest.fn(),
  useTonWallet: jest.fn(),
}))

jest.mock('../hooks/useTonConnect', () => ({
  useTonConnect: jest.fn(),
}))

describe('Transfer component', () => {
  const mockTonConnectUI = {
    sendTransaction: jest.fn(),
  }

  beforeEach(() => {
    ;(useTonConnectUI as jest.Mock).mockReturnValue([mockTonConnectUI])
    ;(useTonAddress as jest.Mock).mockReturnValue('0x123')
    ;(useTonWallet as jest.Mock).mockReturnValue({ address: '0x123' })
    ;(useTonConnect as jest.Mock).mockReturnValue({})
  })

  it('renders without crashing', () => {
    render(<Transfer />)
    expect(screen.getByText('Transfer TON')).toBeInTheDocument()
  })

  it('displays input field and transfer button', () => {
    render(<Transfer />)
    expect(screen.getByPlaceholderText('Enter transfer amount in TON')).toBeInTheDocument()
    expect(screen.getByRole('button', { name: 'Transfer' })).toBeInTheDocument()
  })

  it('handles invalid input', async () => {
    render(<Transfer />)
    const input = screen.getByPlaceholderText('Enter transfer amount in TON')
    const transferButton = screen.getByRole('button', { name: 'Transfer' })

    fireEvent.change(input, { target: { value: 'invalid' } })
    fireEvent.click(transferButton)

    await waitFor(() => {
      expect(screen.getByText('Please enter a valid transfer amount.')).toBeInTheDocument()
    })
  })

  it('handles successful transfer', async () => {
    mockTonConnectUI.sendTransaction.mockResolvedValue({ boc: 'mockedBoc' })
    render(<Transfer />)
    const input = screen.getByPlaceholderText('Enter transfer amount in TON')
    const transferButton = screen.getByRole('button', { name: 'Transfer' })

    fireEvent.change(input, { target: { value: '1.5' } })
    fireEvent.click(transferButton)
  })

  it('handles transfer error', async () => {
    mockTonConnectUI.sendTransaction.mockRejectedValue(new Error('Transfer failed'))

    render(<Transfer />)
    const input = screen.getByPlaceholderText('Enter transfer amount in TON')
    const transferButton = screen.getByRole('button', { name: 'Transfer' })

    fireEvent.change(input, { target: { value: '1.5' } })
    fireEvent.click(transferButton)

    await waitFor(() => {
      expect(
        screen.getByText('An error occurred during the transfer. Please try again.')
      ).toBeInTheDocument()
    })
  })

  it('disables transfer button during processing', async () => {
    mockTonConnectUI.sendTransaction.mockResolvedValue({ boc: 'mockedBoc' })
    render(<Transfer />)
    const input = screen.getByPlaceholderText('Enter transfer amount in TON')
    const transferButton = screen.getByRole('button', { name: 'Transfer' })
    fireEvent.change(input, { target: { value: '1.5' } })
    fireEvent.click(transferButton)
    await waitFor(() => {
      expect(transferButton).toBeEnabled()
    })
  })

  it('handles wallet not connected', async () => {
    ;(useTonWallet as jest.Mock).mockReturnValue(null)

    render(<Transfer />)
    const transferButton = screen.getByRole('button', { name: 'Transfer' })

    fireEvent.click(transferButton)

    await waitFor(() => {
      expect(screen.getByText('Please connect your wallet.')).toBeInTheDocument()
    })
  })
})

--------------------------------------------------------------------------------

Index: 177
File: /Users/cryptskii/client/src/__tests__/Deposit.test.tsx

import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import Deposit from '../components/channels/Deposit'
import { useTonWallet } from '@tonconnect/ui-react'
import { useTonConnect } from '../hooks/useTonConnect'

jest.mock('@tonconnect/ui-react', () => ({
  useTonWallet: jest.fn(),
}))

jest.mock('../hooks/useTonConnect', () => ({
  useTonConnect: jest.fn(),
}))

describe('Deposit component additional tests', () => {
  const mockTonConnectUI = {
    tonModule: {
      on: jest.fn(),
      off: jest.fn(),
      deposit: jest.fn(),
    },
    tonContract: {},
  }

  beforeEach(() => {
    ;(useTonWallet as jest.Mock).mockReturnValue({ address: '0x123' })
    ;(useTonConnect as jest.Mock).mockReturnValue({
      tonConnectUI: mockTonConnectUI,
      channelState: null,
    })
  })

  afterEach(() => {
    jest.clearAllMocks()
  })

  it('updates deposit amount when input changes', () => {
    render(<Deposit />)
    const input = screen.getByPlaceholderText('Enter deposit amount in TON')
    fireEvent.change(input, { target: { value: '5' } })
    expect(input).toHaveValue(5)
  })

  it('disables deposit button while loading', async () => {
    ;(useTonConnect as jest.Mock).mockReturnValue({
      tonConnectUI: mockTonConnectUI,
      channelState: { balance: '100' },
    })
    mockTonConnectUI.tonModule.deposit.mockImplementation(() => new Promise(() => {}))

    render(<Deposit />)
    fireEvent.change(screen.getByPlaceholderText('Enter deposit amount in TON'), {
      target: { value: '10' },
    })
    fireEvent.click(screen.getByRole('button', { name: 'Deposit' }))

    await waitFor(() => {
      expect(screen.getByRole('button', { name: 'Depositing...' })).toBeInTheDocument()
      expect(screen.getByRole('button', { name: 'Depositing...' })).toBeDisabled()
    })
  })

  it('displays success message when deposit is successful', async () => {
    ;(useTonConnect as jest.Mock).mockReturnValue({
      tonConnectUI: mockTonConnectUI,
      channelState: { balance: '100' },
    })
    mockTonConnectUI.tonModule.deposit.mockResolvedValue({})
    render(<Deposit />)
    fireEvent.change(screen.getByPlaceholderText('Enter deposit amount in TON'), {
      target: { value: '10' },
    })
    fireEvent.click(screen.getByRole('button', { name: 'Deposit' }))
    await waitFor(() => {
      expect(screen.getByText('Deposit Successful!')).toBeInTheDocument()
    })
    expect(screen.getByText('Deposit Successful!')).toBeInTheDocument()
  })

  it('displays error message when deposit fails', async () => {
    ;(useTonConnect as jest.Mock).mockReturnValue({
      tonConnectUI: mockTonConnectUI,
      channelState: { balance: '100' },
    })
    mockTonConnectUI.tonModule.deposit.mockRejectedValue(new Error('Deposit failed'))

    render(<Deposit />)
    fireEvent.change(screen.getByPlaceholderText('Enter deposit amount in TON'), {
      target: { value: '10' },
    })
    fireEvent.click(screen.getByRole('button', { name: 'Deposit' }))

    await waitFor(() => {
      expect(screen.getByText('Error depositing funds: Deposit failed')).toBeInTheDocument()
    })
  })

  it('handles deposit with decimal amount', async () => {
    ;(useTonConnect as jest.Mock).mockReturnValue({
      tonConnectUI: mockTonConnectUI,
      channelState: { balance: '100' },
    })
    mockTonConnectUI.tonModule.deposit.mockResolvedValue({ balance: '150.5' })

    render(<Deposit />)
    fireEvent.change(screen.getByPlaceholderText('Enter deposit amount in TON'), {
      target: { value: '0.5' },
    })
    fireEvent.click(screen.getByRole('button', { name: 'Deposit' }))

    await waitFor(() => {
      expect(screen.getByText('Deposit Successful!')).toBeInTheDocument()
      expect(screen.getByText(/"balance": "150.5"/)).toBeInTheDocument()
    })
  })

  it('clears error message on successful deposit', async () => {
    ;(useTonConnect as jest.Mock).mockReturnValue({
      tonConnectUI: mockTonConnectUI,
      channelState: { balance: '100' },
    })
    mockTonConnectUI.tonModule.deposit
      .mockRejectedValueOnce(new Error('First attempt failed'))
      .mockResolvedValueOnce({ balance: '200' })

    render(<Deposit />)
    fireEvent.change(screen.getByPlaceholderText('Enter deposit amount in TON'), {
      target: { value: '10' },
    })
    fireEvent.click(screen.getByRole('button', { name: 'Deposit' }))

    await waitFor(() => {
      expect(screen.getByText('Error depositing funds: First attempt failed')).toBeInTheDocument()
    })

    fireEvent.click(screen.getByRole('button', { name: 'Deposit' }))

    await waitFor(() => {
      expect(
        screen.queryByText('Error depositing funds: First attempt failed')
      ).not.toBeInTheDocument()
      expect(screen.getByText('Deposit Successful!')).toBeInTheDocument()
    })
  })
})

--------------------------------------------------------------------------------

Index: 178
File: /Users/cryptskii/client/src/__tests__/blueprint/Channel.test.ts

import { Address } from '@ton/ton'
import { Channel } from '../../blueprint/Channel'
import { ChannelState } from '../../blueprint/ChannelState'

describe('Channel', () => {
  let mockAddress: Address
  let mockChannelState: ChannelState

  beforeEach(() => {
    mockAddress = { toString: () => 'test_channel_address' } as Address
    mockChannelState = {} as ChannelState
  })

  test('should create a Channel instance with correct properties', () => {
    const channel = new Channel(mockAddress, mockChannelState)

    expect(channel.channelAddress).toBe(mockAddress)
    expect(channel.channelState).toBe(mockChannelState)
  })

  test('should allow access to properties', () => {
    const channel = new Channel(mockAddress, mockChannelState)

    expect(channel.channelAddress.toString()).toBe('test_channel_address')
    expect(channel.channelState).toEqual({})
  })

  test('should allow setting additional properties', () => {
    const channel = new Channel(mockAddress, mockChannelState)
    ;(channel as any).additionalProp = 'test'

    expect((channel as any).additionalProp).toBe('test')
  })
})

--------------------------------------------------------------------------------

Index: 179
File: /Users/cryptskii/client/src/__tests__/blueprint/OverpassChannels.test.ts

import { OverpassChannels } from '../../blueprint/OverpassChannels'
import { Contract, TonClient } from '@ton/ton'
import { jest } from '@jest/globals'
jest.mock('@ton/ton', () => ({
  TonClient: jest.fn(),
  Contract: jest.fn(),
  Address: jest.fn(),
  Cell: jest.fn(),
  beginCell: jest.fn(),
  endCell: jest.fn(),
}))
describe('OverpassChannels', () => {
  let tonClientMock: jest.Mocked<TonClient>
  let overpassChannels: OverpassChannels
  let mockContract: jest.Mocked<Contract>
  beforeEach(() => {
    // Mock TonClient with appropriate parameters
    tonClientMock = new TonClient({
      endpoint: 'http://mock-endpoint.com',
    }) as jest.Mocked<TonClient>
    // Mocking the required methods for TonClient
    tonClientMock.getContractState = jest.fn()
    tonClientMock.sendExternalMessage = jest.fn()
    // Mock Contract object
    mockContract = {
      address: 'mockAddress',
      // Mock any other properties/methods needed for your tests
    } as unknown as jest.Mocked<Contract>
    overpassChannels = new OverpassChannels(tonClientMock)
  })
  it('should call getContractState on tonClient', async () => {
    await overpassChannels.getAccountState(mockContract)
    expect(tonClientMock.getContractState).toHaveBeenCalledWith(mockContract.address)
  })
  it('should throw an error if getContractState fails', async () => {
    ;(tonClientMock.getContractState as jest.Mock).mockRejectedValue(new Error('API Error'))
    await expect(overpassChannels.getAccountState(mockContract)).rejects.toThrow(
      'Failed to get account state'
    )
  })
  it('should create a channel', async () => {
    await overpassChannels.createChannel(mockContract, 'TestChannel', 1000)
    expect(tonClientMock.sendExternalMessage).toHaveBeenCalledWith(mockContract, expect.any(Object))
  })
  it('should throw an error if createChannel fails', async () => {
    ;(tonClientMock.sendExternalMessage as jest.Mock).mockRejectedValue(
      new Error('Transaction failed')
    )
    await expect(overpassChannels.createChannel(mockContract, 'TestChannel', 1000)).rejects.toThrow(
      'Failed to create channel'
    )
  })
  it('should call getChannelState', async () => {
    await overpassChannels.getChannelState(mockContract)
    expect(tonClientMock.getContractState).toHaveBeenCalledWith(mockContract.address)
  })
  it('should throw an error if getChannelState fails', async () => {
    await expect(overpassChannels.getChannelState(mockContract)).rejects.toThrow(
      'Failed to get channel state'
    )
  })
})

--------------------------------------------------------------------------------

Index: 180
File: /Users/cryptskii/client/src/hooks/singleWalletModal.tsx

import React, { useState, useCallback, useMemo } from 'react'
import '../../src/styles/singleWalletModal.css'

interface Wallet {
  id: string
  name: string
  address: string
  balance: string
  publicKey: string
}

interface WalletModalProps {
  wallet: Wallet | null
  isOpen: boolean
  onClose: () => void
}

const WalletModal: React.FC<WalletModalProps> = React.memo(({ wallet, isOpen, onClose }) => {
  if (!wallet || !isOpen) return null

  return (
    <div className="modal show" style={{ display: 'block' }}>ƒ
      <div className="modal-content">
        <h2>{wallet.name}</h2>
        <p>
          <strong>Address:</strong> {wallet.address}
        </p>
        <p>
          <strong>Balance:</strong> {wallet.balance}
        </p>
        <p>
          <strong>Public Key:</strong> {wallet.publicKey}
        </p>
        <button onClick={onClose}>Close</button>
      </div>
    </div>
  )
})

export const Wallet: React.FC = () => {
  const walletsList = useMemo<Wallet[]>(() => [
    {
      id: 'wallet1',
      name: 'TON Wallet',
      address: '0x1234567890abcdef1234567890abcdef12345678',
      balance: '100 TON',
      publicKey: 'abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890',
    },
    {
      id: 'wallet2',
      name: 'TON Safe',
      address: '0xabcdefabcdefabcdefabcdefabcdefabcdefabcdef',
      balance: '200 TON',
      publicKey: '1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
    },
  ], [])

  const [selectedWallet, setSelectedWallet] = useState<Wallet | null>(null)
  const [isModalOpen, setModalOpen] = useState<boolean>(false)

  const singleWalletModal = useMemo(() => ({
    open: (walletId: string) => {
      const wallet = walletsList.find((w) => w.id === walletId)
      if (wallet) {
        setSelectedWallet(wallet)
        setModalOpen(true)
      } else {
        console.error('Wallet not found')
      }
    },
    close: () => {
      setModalOpen(false)
      setSelectedWallet(null)
    },
  }), [walletsList])

  const handleWalletClick = useCallback((walletId: string) => {
    singleWalletModal.open(walletId)
  }, [singleWalletModal])

  const handleModalClose = useCallback(() => {
    singleWalletModal.close()
  }, [singleWalletModal])

  return (
    <div className="app">
      <div className="wallets-list">
        {walletsList.map((wallet) => (
          <div
            key={wallet.id}
            className={`wallet ${selectedWallet?.id === wallet.id ? 'selected' : ''}`}
            onClick={() => handleWalletClick(wallet.id)}
          >
            <div className="wallet-icon" />
            <span className="wallet-name">{wallet.name}</span>
          </div>
        ))}
      </div>
      <WalletModal
        wallet={selectedWallet}
        isOpen={isModalOpen}
        onClose={handleModalClose}
      />
    </div>
  )
}

--------------------------------------------------------------------------------

Index: 181
File: /Users/cryptskii/client/src/hooks/useTheme.ts

// ./hooks/useTheme.ts
import { useContext } from 'react';
import { ThemeContext } from '../context/ThemeContext';

export const useTheme = () => {
  const theme = useContext(ThemeContext);
  return theme;
};  


--------------------------------------------------------------------------------

Index: 182
File: /Users/cryptskii/client/src/hooks/useClientV2.ts

// src/hooks/useClientV2.ts

import { useQuery } from '@tanstack/react-query'
import { Address, fromNano } from '@ton/core'
import { TonClient } from '@ton/ton'
import { TonConnect } from '@tonconnect/sdk'

export const useClientV2 = () => {
  const tonConnect = new TonConnect({
    manifestUrl: 'https://overpass-channels-czhd-git-crypskii-brandons-projects-d6012021.vercel.app/tonconnect-manifest.json',
  })

  const handleConnect = async () => {
    try {
      await tonConnect.connect({
        universalLink: 'https://app.tonkeeper.com/ton-connect',
        bridgeUrl: 'https://bridge.tonapi.io/bridge',
      })
    } catch (error) {
      console.error('Error connecting to TonConnect:', error)
    }
  }

  const handleDisconnect = async () => {
    try {
      await tonConnect.disconnect()
    } catch (error) {
      console.error('Error disconnecting from TonConnect:', error)
    }
  }

  const { data: balance, isLoading } = useQuery({
    queryKey: ['balance'],
    queryFn: async () => {
      const walletInfo = tonConnect.wallet
      if (!walletInfo) {
        return '0'
      }
      try {
        const parsedAddress = Address.parse(walletInfo.account.address)
        const tonClient = new TonClient({ endpoint: 'https://toncenter.com/api/v2/jsonRPC' })
        const balanceNano = await tonClient.getBalance(parsedAddress)
        return fromNano(balanceNano).toString()
      } catch (error) {
        console.error('Error fetching balance:', error)
        return '0'
      }
    },
  })

  return {
    client: tonConnect,
    handleConnect,
    handleDisconnect,
    walletInfo: tonConnect.wallet,
    balance,
    isLoading,
  }
}

--------------------------------------------------------------------------------

Index: 183
File: /Users/cryptskii/client/src/hooks/useTheme.tsx

// ./hooks/useTheme.tsx
import { useContext } from 'react';
import { ThemeContext } from '../context/ThemeContext';

export const useTheme = () => {
  const theme = useContext(ThemeContext);
  return theme;
};
--------------------------------------------------------------------------------

Index: 184
File: /Users/cryptskii/client/src/hooks/walletsModal.tsx

import { TonClient } from '@ton/ton';
import { Address, Cell, CommonMessageInfoExternalIn } from '@ton/core';
import {
  ExtendedTonConnectUI,
  SendTransactionResponse,
  SendTransactionRequest as TonConnectSendTransactionRequest,
} from '../optypes/extendedTonConnectUI';
import { getHttpEndpoint as orbsGetHttpEndpoint } from '@orbs-network/ton-access';
import { OverpassChannels } from '@/blueprint/OverpassChannels';

// Function to get TonClient from Orbs' decentralized RPC endpoint
export async function getTonClient(): Promise<TonClient> {
  const endpoint = await orbsGetHttpEndpoint({
    network: 'testnet',
  });
  return new TonClient({ endpoint });
}

// Function to create contract address from string
export function createContractAddress(address: string): Address {
  return Address.parse(address);
}

// Get contract balance for a given address
export async function getContractBalance(client: TonClient, address: Address): Promise<bigint> {
  try {
    const contractState = await client.getContractState(address);
    return contractState.balance;
  } catch (error) {
    console.error('Failed to get contract balance:', error);
    throw error;
  }
}

// Get contract data for a given address
export async function getContractData(
  client: TonClient,
  address: Address
): Promise<Uint8Array | null> {
  try {
    const contractState = await client.getContractState(address);
    return contractState.data;
  } catch (error) {
    console.error('Failed to get contract data:', error);
    throw error;
  }
}

// Get contract code for a given address
export async function getContractCode(
  client: TonClient,
  address: Address
): Promise<Uint8Array | null> {
  try {
    const contractState = await client.getContractState(address);
    return contractState.code;
  } catch (error) {
    console.error('Failed to get contract code:', error);
    throw error;
  }
}

// Check if the contract is deployed
export async function isContractDeployed(client: TonClient, address: Address): Promise<boolean> {
  try {
    const contractState = await client.getContractState(address);
    return contractState.state === 'active';
  } catch (error) {
    console.error('Failed to check if contract is deployed:', error);
    return false;
  }
}

// Get the last transaction information of a contract
export async function getContractLastTransaction(
  client: TonClient,
  address: Address
): Promise<{
  lt: string;
  hash: string;
} | null> {
  try {
    const contractState = await client.getContractState(address);
    return contractState.lastTransaction;
  } catch (error) {
    console.error('Failed to get last transaction:', error);
    return null;
  }
}

// Fallback HTTP Endpoint getter in case Orbs is not available
export async function getHttpEndpoint(): Promise<string> {
  return process.env.TON_NETWORK_ENDPOINT || 'https://toncenter.com/api/v2/jsonRPC';
}

// Initialize ExtendedTonConnectUI with additional custom functionality
export async function getTonConnectUI(): Promise<ExtendedTonConnectUI | null> {
  try {
    const extendedTonConnectUI: Partial<ExtendedTonConnectUI> = {
      tonModule: new OverpassChannels(await getTonClient(), process.env.TON_CONTRACT_ADDRESS || ''),
      tonContract: { address: createContractAddress(process.env.TON_CONTRACT_ADDRESS || '') },
      getBalance: async (address: string) => {
        try {
          const client = await getTonClient();
          const balance = await client.getBalance(Address.parse(address));
          return balance.toString();
        } catch (error) {
          console.error('Failed to get balance:', error);
          throw error;
        }
      },
      sendTransaction: async (
        tx: TonConnectSendTransactionRequest
      ): Promise<SendTransactionResponse> => {
        try {
          const client = await getTonClient();
          const message = {
            info: {
              type: 'external-in',
              src: null,
              dest: Address.parse(tx.messages[0].address),
              importFee: 0n,
            } as CommonMessageInfoExternalIn,
            body: Cell.fromBoc(Buffer.from(tx.messages[0].payload, 'base64'))[0],
          };
          const response = await client.sendMessage(message);
          if (response !== undefined && typeof response === 'object') {
            return {
              boc: (response as any).boc || '',
              hash: (response as any).hash || '',
            };
          }
          throw new Error('Failed to send transaction');
        } catch (error) {
          console.error('Error while sending transaction:', error);
          throw error;
        }
      },
    };
    return extendedTonConnectUI as ExtendedTonConnectUI;
  } catch (error) {
    console.error('Failed to initialize TonConnectUI:', error);
    return null;
  }
}

--------------------------------------------------------------------------------

Index: 185
File: /Users/cryptskii/client/src/hooks/useTonConnect.ts

import { useState, useCallback } from 'react'
import { SendTransactionResponse as CustomSendTransactionResponse } from '../optypes/extendedTonConnectUI'
import { useTonConnectUI, TonConnectUI } from '@tonconnect/ui-react'
import { WalletInfo, SendTransactionRequest } from '@tonconnect/sdk'

type ExtendedWalletInfo = WalletInfo & {
  balance?: string
  icon: string
  address: string
}

export function useTonConnect() {
  const [walletInfo, setWalletInfo] = useState<ExtendedWalletInfo | null>(null)
  const [channelAddress] = useState<string | null>(null)
  const [channelState] = useState<any | null>(null)
  const [isLoading, setIsLoading] = useState<boolean>(false)
  const [error, setError] = useState<string | null>(null)
  const [tonConnectUI] = useTonConnectUI()

  const getWalletInfo = useCallback(
    async (instance: TonConnectUI): Promise<ExtendedWalletInfo | null> => {
      const wallets = await instance.getWallets()
      if (!wallets || wallets.length === 0) return null
      const wallet = wallets[0] as WalletInfo & { address: string }
      const balance = (await (instance as any).getBalance?.(wallet.address)) || '0'
      return { ...wallet, balance, icon: wallet.imageUrl, address: wallet.address }
    },
    []
  )

  const handleConnect = useCallback(async () => {
    if (!tonConnectUI) return
    try {
      setIsLoading(true)
      await tonConnectUI.connectWallet()
      const newWalletInfo = await getWalletInfo(tonConnectUI)
      setWalletInfo(newWalletInfo)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to connect wallet')
    } finally {
      setIsLoading(false)
    }
  }, [tonConnectUI, getWalletInfo])

  const handleDisconnect = useCallback(async () => {
    if (!tonConnectUI) return
    try {
      setIsLoading(true)
      await tonConnectUI.disconnect()
      setWalletInfo(null)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to disconnect wallet')
    } finally {
      setIsLoading(false)
    }
  }, [tonConnectUI])

  const handleOpenModal = useCallback(async () => {
    if (!tonConnectUI) return
    try {
      setIsLoading(true)
      await tonConnectUI.openModal()
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to open modal')
    } finally {
      setIsLoading(false)
    }
  }, [tonConnectUI])

  const handleCloseModal = useCallback(async () => {
    if (!tonConnectUI) return
    try {
      setIsLoading(true)
      tonConnectUI.closeModal()
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to close modal')
    } finally {
      setIsLoading(false)
    }
  }, [tonConnectUI])

  const sendTransaction = useCallback(
    async (tx: SendTransactionRequest): Promise<CustomSendTransactionResponse> => {
      if (!tonConnectUI) throw new Error('TonConnectUI not initialized')
      try {
        setIsLoading(true)
        const response = await tonConnectUI.sendTransaction(tx)
        return {
          boc: response.boc,
          hash: '',
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to send transaction')
        throw err
      } finally {
        setIsLoading(false)
      }
    },
    [tonConnectUI]
  )

  return {
    tonConnectUI,
    walletInfo,
    channelAddress,
    channelState,
    isLoading,
    error,
    handleConnect,
    handleDisconnect,
    handleOpenModal,
    handleCloseModal,
    sendTransaction,
  }
}

--------------------------------------------------------------------------------

Index: 186
File: /Users/cryptskii/client/src/lib/formatUnits.ts

// github.com/wevm/viem/blob/f361a7a0465ded8303ea439b0dc2568459230ee6/src/utils/unit/formatUnits.ts

/**
 * Multiplies a string representation of a number by a given exponent of base 10 (10exponent).
 *
 * - Docs: https://viem.sh/docs/utilities/parseUnits
 *
 * @example
 * import { parseUnits } from 'viem'
 *
 * parseUnits('420', 9)
 * // 420000000000n
 */
export function parseUnits(value: string, decimals: number) {
  let [integer, fraction = '0'] = value.split('.')

  const negative = integer.startsWith('-')
  if (negative) integer = integer.slice(1)

  // trim leading zeros.
  fraction = fraction.replace(/(0+)$/, '')

  // round off if the fraction is larger than the number of decimals.
  if (decimals === 0) {
    if (Math.round(Number(`.${fraction}`)) === 1) integer = (BigInt(integer) + BigInt(1)).toString()
    fraction = ''
  } else if (fraction.length > decimals) {
    const [left, unit, right] = [
      fraction.slice(0, decimals - 1),
      fraction.slice(decimals - 1, decimals),
      fraction.slice(decimals),
    ]

    const rounded = Math.round(Number(`${unit}.${right}`))
    if (rounded > 9) fraction = (BigInt(left) + BigInt(1)).toString().padStart(left.length + 1, '0')
    else fraction = `${left}${rounded}`

    if (fraction.length > decimals) {
      fraction = fraction.slice(1)
      integer = (BigInt(integer) + BigInt(1)).toString()
    }

    fraction = fraction.slice(0, decimals)
  } else {
    fraction = fraction.padEnd(decimals, '0')
  }

  return BigInt(`${negative ? '-' : ''}${integer}${fraction}`)
}
/**
 *  Divides a number by a given exponent of base 10 (10exponent), and formats it into a string representation of the number.
 *
 * - Docs: https://viem.sh/docs/utilities/formatUnits
 *
 * @example
 * import { formatUnits } from 'viem'
 *
 * formatUnits(420000000000n, 9)
 * // '420'
 */
export function formatUnits(value: bigint, decimals: number) {
  let display = value.toString()

  const negative = display.startsWith('-')
  if (negative) display = display.slice(1)

  display = display.padStart(decimals, '0')

  // eslint-disable-next-line prefer-const
  let [integer, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals),
  ]
  fraction = fraction.replace(/(0+)$/, '')
  return `${negative ? '-' : ''}${integer || '0'}${fraction ? `.${fraction}` : ''}`
}

--------------------------------------------------------------------------------

Index: 187
File: /Users/cryptskii/client/src/lib/utils.ts

import { type ClassValue, clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

--------------------------------------------------------------------------------

Index: 188
File: /Users/cryptskii/client/src/api/blockchain_api.test.ts

import { TonClient } from '@ton/ton'
import {
  Address,
  OpenedContract,
  Contract,
  Transaction,
  Message,
  Dictionary,
  Cell,
  StateInit,
} from '@ton/core'
import {
  BlockchainApiWrapper,
  FetchAccountFromBlockchain,
  FetchDashboardData,
  FetchChannelState,
} from '../../api/blockchain_api.ts'
describe('BlockchainApi', () => {
  let mockClient: jest.Mocked<TonClient>

  beforeEach(() => {
    mockClient = {
      open: jest.fn(),
    } as unknown as jest.Mocked<TonClient>
  })

  test('getAccount should return account when successful', async () => {})
})

describe('BlockchainApiWrapper', () => {
  let mockClient: jest.Mocked<TonClient>
  let blockchainApiWrapper: BlockchainApiWrapper

  beforeEach(() => {
    mockClient = {
      open: jest.fn(),
      getContractState: jest.fn(),
      getTransactions: jest.fn(),
      getMasterchainInfo: jest.fn(),
    } as unknown as jest.Mocked<TonClient>
    blockchainApiWrapper = new BlockchainApiWrapper(mockClient)
  })

  test('getAccountState should call client.getContractState', async () => {
    const mockAddress = { toString: () => 'test_address' } as Address
    const mockState = {
      balance: BigInt(100),
      state: 'active' as const,
      code: null,
      data: null,
      lastTransaction: null,
      blockId: { workchain: 0, shard: '0', seqno: 0 },
      timestampt: 0,
    }
    mockClient.getContractState.mockResolvedValue(mockState)

    const result = await blockchainApiWrapper.getAccountState(mockAddress)

    expect(result).toEqual(mockState)
    expect(mockClient.getContractState).toHaveBeenCalledWith(mockAddress)
  })
  test('getTransaction should call client.getTransactions with correct parameters', async () => {
    const mockAddress = { toString: () => 'test_address' } as Address
    const mockLt = '123'
    const mockHash = 'abc'
    const mockTransaction: Transaction[] = [
      {
        address: BigInt(mockAddress.toString()),
        lt: BigInt(mockLt),
        prevTransactionHash: BigInt('0x' + mockHash),
        prevTransactionLt: BigInt(0),
        now: 0,
        outMessagesCount: 0,
        inMessage: null,
        outMessages: Dictionary.empty<number, Message>(),
        totalFees: { coins: BigInt(0) },
        oldStatus: 'active',
        endStatus: 'active',
        stateUpdate: {
          oldHash: Buffer.alloc(0),
          newHash: Buffer.alloc(0),
        },
        description: {
          type: 'generic',
          creditFirst: false,
          storagePhase: undefined,
          creditPhase: undefined,
          computePhase: {
            type: 'skipped',
            reason: 'no-state',
          },
          actionPhase: undefined,
          bouncePhase: undefined,
          aborted: false,
          destroyed: false,
        },
        raw: new Cell(),
        hash: function (): Buffer {
          throw new Error('Function not implemented.')
        },
      },
    ]
    mockClient.getTransactions.mockResolvedValue(mockTransaction)

    const result = await blockchainApiWrapper.getTransaction(mockAddress, mockLt, mockHash)

    expect(result).toEqual(mockTransaction)
    expect(mockClient.getTransactions).toHaveBeenCalledWith(mockAddress, {
      lt: mockLt,
      hash: mockHash,
      limit: 0,
    })
  })

  test('getBlockTransactions should call client.getTransactions with correct parameters', async () => {
    const mockSeqno = 1
    const mockWorkchain = 0
    const mockTransactions: Transaction[] = [
      {
        address: BigInt('0x' + 'test_address'),
        lt: BigInt(1),
        prevTransactionHash: BigInt('0x' + 'abc'),
        prevTransactionLt: BigInt(0),
        now: 0,
        outMessagesCount: 0,
        inMessage: null,
        outMessages: Dictionary.empty<number, Message>(),
        totalFees: { coins: BigInt(0) },
        oldStatus: 'active',
        endStatus: 'active',
        stateUpdate: {
          oldHash: Buffer.alloc(0),
          newHash: Buffer.alloc(0),
        },
        description: {
          type: 'generic',
          creditFirst: false,
          storagePhase: undefined,
          creditPhase: undefined,
          computePhase: {
            type: 'skipped',
            reason: 'no-state',
          },
          actionPhase: undefined,
          bouncePhase: undefined,
          aborted: false,
          destroyed: false,
        },
        raw: new Cell(),
        hash: function (): Buffer {
          throw new Error('Function not implemented.')
        },
      },
      {
        address: BigInt('0x' + 'test_address2'),
        lt: BigInt(2),
        prevTransactionHash: BigInt('0x' + 'def'),
        prevTransactionLt: BigInt(1),
        now: 0,
        outMessagesCount: 0,
        inMessage: null,
        outMessages: Dictionary.empty<number, Message>(),
        totalFees: { coins: BigInt(0) },
        oldStatus: 'active',
        endStatus: 'active',
        stateUpdate: {
          oldHash: Buffer.alloc(0),
          newHash: Buffer.alloc(0),
        },
        description: {
          type: 'generic',
          creditFirst: false,
          storagePhase: undefined,
          creditPhase: undefined,
          computePhase: {
            type: 'skipped',
            reason: 'no-state',
          },
          actionPhase: undefined,
          bouncePhase: undefined,
          aborted: false,
          destroyed: false,
        },
        raw: new Cell(),
        hash: function (): Buffer {
          throw new Error('Function not implemented.')
        },
      },
    ]
    mockClient.getTransactions.mockResolvedValue(mockTransactions)

    const result = await blockchainApiWrapper.getBlockTransactions(mockSeqno, mockWorkchain)

    expect(result).toEqual(mockTransactions)
    expect(mockClient.getTransactions).toHaveBeenCalledWith(expect.any(Object), { limit: 100 })
  })
})

describe('FetchAccountFromBlockchain', () => {
  let fetchAccountFromBlockchain: FetchAccountFromBlockchain
  beforeEach(() => {
    fetchAccountFromBlockchain = new FetchAccountFromBlockchain()
    fetchAccountFromBlockchain.client = {
      open: jest.fn(),
    }
  })

  test('fetchAccountFromBlockchain should return account when found', async () => {
    const mockAddress = { toString: () => 'test_address' } as Address
    const mockAccount: OpenedContract<Contract> = {
      address: mockAddress,
      init: jest.fn() as unknown as StateInit | null,
    }
    fetchAccountFromBlockchain.client.open.mockResolvedValue(mockAccount)

    const result = await fetchAccountFromBlockchain.fetchAccountFromBlockchain(mockAddress)

    expect(result).toEqual(mockAccount)
    expect(fetchAccountFromBlockchain.client.open).toHaveBeenCalledWith({ address: mockAddress })
  })
  test('fetchAccountFromBlockchain should throw error when account not found', async () => {
    const mockAddress = { toString: () => 'test_address' } as Address
    fetchAccountFromBlockchain.client.open.mockResolvedValue(
      null as unknown as OpenedContract<Contract>
    )

    await expect(
      fetchAccountFromBlockchain.fetchAccountFromBlockchain(mockAddress)
    ).rejects.toThrow(`Account not found for address ${mockAddress}`)
  })
})

describe('FetchDashboardData', () => {
  let fetchDashboardData: FetchDashboardData

  beforeEach(() => {
    fetchDashboardData = new FetchDashboardData()
    global.fetch = jest.fn()
  })

  test('fetchDashboardData should return data when successful', async () => {
    const mockData = { users: 100, transactions: 1000 }
    ;(global.fetch as jest.Mock).mockResolvedValue({
      json: jest.fn().mockResolvedValue(mockData),
    })

    const result = await fetchDashboardData.fetchDashboardData()

    expect(result).toEqual(mockData)
    expect(global.fetch).toHaveBeenCalledWith('https://api.example.com/dashboard')
  })

  test('fetchDashboardData should throw error when fetch fails', async () => {
    ;(global.fetch as jest.Mock).mockRejectedValue(new Error('Network error'))

    await expect(fetchDashboardData.fetchDashboardData()).rejects.toThrow('Network error')
  })
})

describe('FetchChannelState', () => {
  let fetchChannelState: FetchChannelState

  beforeEach(() => {
    fetchChannelState = new FetchChannelState()
    global.fetch = jest.fn()
  })

  test('fetchChannelState should return data when successful', async () => {
    const mockAddress = { toString: () => 'test_channel_address' } as Address
    const mockData = { balance: 1000, status: 'active' }
    ;(global.fetch as jest.Mock).mockResolvedValue({
      json: jest.fn().mockResolvedValue(mockData),
    })

    const result = await fetchChannelState.fetchChannelState(mockAddress)

    expect(result).toEqual(mockData)
    expect(global.fetch).toHaveBeenCalledWith(
      'https://api.example.com/channel/test_channel_address'
    )
  })

  test('fetchChannelState should throw error when fetch fails', async () => {
    const mockAddress = { toString: () => 'test_channel_address' } as Address
    ;(global.fetch as jest.Mock).mockRejectedValue(new Error('Network error'))

    await expect(fetchChannelState.fetchChannelState(mockAddress)).rejects.toThrow('Network error')
  })
})

--------------------------------------------------------------------------------

Index: 189
File: /Users/cryptskii/client/src/api/api.ts

// ./src/public/api.ts

import { TonClient } from '@ton/ton';
import { Address, Contract } from '@ton/core';

export class TonConnectBase {
  client: TonClient;

  constructor(client: TonClient) {
    this.client = client;
  }

  async getAccount(address: string) {
    const contract = this.client.provider(Address.parse(address));
    return this.client.open(contract as unknown as Contract);
  }

  async getAccountState(address: string) {
    return this.getAccount(address);
  }

  async getAccountStateWithProof(address: string) {
    return this.getAccount(address);
  }

  async getAccountStateWithProofAndBocCache(address: string) {
    return this.getAccount(address);
  }
}

export class TonConnectWrapper extends TonConnectBase {
  // No need to redefine the methods, as they are inherited from TonConnectBase.
}

export class TonConnect extends TonConnectBase {
  // Inherits everything from TonConnectBase, no need to redefine the methods here.
}       

export class BlockchainApi {
    private client: TonClient;
    constructor(client: TonClient) {
      this.client = client;
    }
  
    async getAccount(address: Address): Promise<any> {
      try {
        const account = await this.fetchAccountFromBlockchain(address);
        return account;
      } catch (error) {
        if (error instanceof Error) {
          throw new Error(`Failed to retrieve account for address ${address}: ${error.message}`);
        } else {
          throw new Error(`Failed to retrieve account for address ${address}: Unknown error`);
        }
      }
    }
  
    async fetchAccountFromBlockchain(address: Address): Promise<any> {
      const contract = { address } as Contract;
      const account = this.client.open(contract);
      if (!account) {
        throw new Error(`Account not found for address ${address}`);
      }
      return account;
    }
  }

export class BlockchainApiWrapper {
    private blockchainApi: BlockchainApi;

    constructor(client: TonClient) {
        this.blockchainApi = new BlockchainApi(client);
    }

    async getAccount(address: Address): Promise<any> {
        try {
            const account = await this.blockchainApi.getAccount(address);
            return account;
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to retrieve account for address ${address}: ${error.message}`);
            } else {
                throw new Error(`Failed to retrieve account for address ${address}: Unknown error`);
            }
        }
    }
}   

export const ton = {
    TonConnectBase,
    TonConnectWrapper,
    TonConnect,
    BlockchainApi,
    BlockchainApiWrapper
};
--------------------------------------------------------------------------------

Index: 190
File: /Users/cryptskii/client/src/react/react-ton-connect-ui-react-next.cjs.d.ts


--------------------------------------------------------------------------------

Index: 191
File: /Users/cryptskii/client/src/react/react-ton-connect-ui-react-next.mjs.map.d.ts


--------------------------------------------------------------------------------

Index: 192
File: /Users/cryptskii/client/src/react/react-ton-connect-ui-react-next.cjs.map.d.ts


--------------------------------------------------------------------------------

Index: 193
File: /Users/cryptskii/client/src/blueprint/StorageNodeState.ts

// ./src/blueprint/StorageNodeState.ts
import React, { useState, useEffect } from "react";
import { init } from '@/wasm/wasm_zksnark';
import * as storageNodeOps from '../wasm/storage_node_ops';
import wasm from 'vite-plugin-wasm/dist';

init();

// Example React Component
const NodeComponent: React.FC = () => {
  const [, setNode] = useState<any>(null);
  const [, setMerkleRoot] = useState<string>("");

  useEffect(() => {
    const initializeNode = async () => {
      await wasm();
      const nodeA = new (wasm as any).StorageNode("Node_A", "Root_A");
      setNode(nodeA);
      setMerkleRoot("Root_A");
    };
    initializeNode();
  }, []);

  return null;
};

export default NodeComponent;

// Define the ChannelStateUpdate class
export class ChannelStateUpdate {
  static create(
    newState: string,
    channelId: string,
    updateType: string,
    updateReason: string,
    additionalInfo: string
  ) {
    return new ChannelStateUpdate(
      newState,
      channelId,
      Date.now(),
      'System',
      updateType,
      updateReason,
      additionalInfo
    );
  }

  constructor(
    public newState: string,
    public channelId: string,
    public timestamp: number,
    public updatedBy: string,
    public updateType: string,
    public updateReason: string,
    public additionalInfo?: string
  ) {}

  toString() {
    return JSON.stringify(this);
  }
}

// Define the ChannelState class
export class ChannelState {
  static create(channelId: string, balance: bigint, nonce: number, merkleRoot: string) {
    const merkleRootBytes = Buffer.from(merkleRoot.slice(2), 'hex');
    return new ChannelState(channelId, balance, nonce, merkleRootBytes);
  }

  channelId: string;
  balance: bigint;
  nonce: number;
  merkleRoot: Uint8Array;

  static read(serializedState: Buffer | Uint8Array): ChannelState {
    const view = new DataView(
      serializedState.buffer,
      serializedState.byteOffset,
      serializedState.byteLength
    );
    let offset = 0;

    const channelIdLength = view.getUint8(offset);
    offset += 1;

    if (serializedState.byteLength < offset + channelIdLength) {
      throw new Error('Insufficient data for channelId');
    }
    const channelId = new TextDecoder().decode(
      serializedState.slice(offset, offset + channelIdLength)
    );
    offset += channelIdLength;

    if (serializedState.byteLength < offset + 8) {
      throw new Error('Insufficient data for balance');
    }
    const balance = view.getBigUint64(offset);
    offset += 8;

    if (serializedState.byteLength < offset + 4) {
      throw new Error('Insufficient data for nonce');
    }
    const nonce = view.getUint32(offset);
    offset += 4;

    if (serializedState.byteLength < offset + 32) {
      throw new Error('Insufficient data for merkleRoot');
    }
    const merkleRoot = new Uint8Array(serializedState.slice(offset, offset + 32));

    return new ChannelState(channelId, balance, nonce, merkleRoot);
  }

  write(): Buffer {
    const chunks: Buffer[] = [];

    // Channel ID
    const channelIdBuffer = Buffer.from(this.channelId, 'utf-8');
    if (channelIdBuffer.length > 255) {
      throw new Error('Channel ID length exceeds the allowed limit');
    }
    chunks.push(Buffer.from([channelIdBuffer.length]));
    chunks.push(channelIdBuffer);

    // Balance
    const balanceBuffer = Buffer.alloc(8);
    balanceBuffer.writeBigUInt64BE(this.balance);
    chunks.push(balanceBuffer);

    // Nonce
    const nonceBuffer = Buffer.alloc(4);
    nonceBuffer.writeUInt32BE(this.nonce);
    chunks.push(nonceBuffer);

    // Merkle Root
    if (this.merkleRoot.length !== 32) {
      throw new Error('Merkle root must be exactly 32 bytes');
    }
    chunks.push(Buffer.from(this.merkleRoot));

    return Buffer.concat(chunks);
  }

  constructor(channelId: string, balance: bigint, nonce: number, merkleRoot: Uint8Array) {
    if (merkleRoot.length !== 32) {
      throw new Error('Merkle root must be exactly 32 bytes');
    }
    this.channelId = channelId;
    this.balance = balance;
    this.nonce = nonce;
    this.merkleRoot = merkleRoot;
  }

  toString() {
    return JSON.stringify({
      channelId: this.channelId,
      balance: this.balance.toString(),
      nonce: this.nonce,
      merkleRoot: Buffer.from(this.merkleRoot).toString('hex'),
    });
  }

  toBoc() {
    // Assuming TonWeb is not available, we'll create a simple object to represent the data
    const bocData = {
      channelId: this.channelId,
      balance: this.balance.toString(),
      nonce: this.nonce,
      merkleRoot: Buffer.from(this.merkleRoot).toString('hex'),
    };
    return JSON.stringify(bocData);
  }
}

// Example usage
const exampleUpdate = ChannelStateUpdate.create(
  'Active',
  '1234567890',
  'Activation',
  'User request',
  'Channel activated by admin'
);

console.log(exampleUpdate.toString());

// Example usage
const exampleState = ChannelState.create(
  '1234567890',
  100n,
  0,
  '0x1234567890123456789012345678901234567890123456789012345678901234'
);

console.log(exampleState.toString());

// Example usage
(async () => {
  const exampleProof = await storageNodeOps.generateProof(exampleState.toBoc());
  console.log(exampleProof);
})();


--------------------------------------------------------------------------------

Index: 194
File: /Users/cryptskii/client/src/blueprint/WalletContract.ts

import { Address, Cell, TonClient } from '@ton/ton';
import { TonConnect } from '@tonconnect/sdk';
import { getWalletAddress } from '../store/wallet';
import { generateProof } from '../wasm/wasm_zksnark';
import * as zkSnarkModule from '../wasm/wasm_zksnark';
import * as createCellModule from '../wasm/wasm_create_cell_from_proof';

export class WalletContract {
  address: Address;
  zkSnarkModule: any;
  createCellModule: any;

  constructor(private client: TonClient) {
    // Assume wallet address is fetched from the store
    this.address = Address.parse(getWalletAddress());
    this.initWasmModules();
  }

  // Initializes WASM modules for zk-SNARKs and Cell creation
  async initWasmModules() {
    try {
      await Promise.all([zkSnarkModule.init(), createCellModule.init()]);
      this.zkSnarkModule = { generateProof };
      this.createCellModule = createCellModule;
    } catch (error) {
      console.error('Error initializing WASM modules:', error);
      throw error;
    }
  }

  // Creates a channel state update hash cell, which is a fundamental part of the TON network
  async createChannelStateUpdateHashCell(channelState: string): Promise<Cell> {
    const proof = await this.zkSnarkModule.generateProof(channelState);
    const updatedMerkleRoot = await this.updateMerkleTree(channelState);
    return this.createCellModule.createCellFromProof(proof, updatedMerkleRoot);
  }

  // Logic to update the Merkle tree based on the channel state
  private async updateMerkleTree(channelState: string): Promise<string> {
    const encoder = new TextEncoder();
    const data = encoder.encode(channelState);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');
    return hashHex;
  }

  // Retrieves the TonConnect contract using a manifest URL
  async getContract(): Promise<TonConnect> {
    return new TonConnect({
      manifestUrl: 'https://overpass-channels.vercel.app/tonconnect-manifest.json',
    });
  }

  // Retrieves the state of the wallet given the wallet address
  async getWalletState(walletAddress: Address): Promise<Cell> {
    const walletState = await this.client.callGetMethod(walletAddress, 'get_wallet_state', []);
    return walletState.stack.readCell();
  }

  // Submits the channel update by creating a state update cell and sending the transaction
  async submitChannelUpdate(channelState: string): Promise<void> {
    const stateUpdateCell = await this.createChannelStateUpdateHashCell(channelState);
    const contract = await this.getContract();

    const transaction = {
      validUntil: Math.floor(Date.now() / 1000) + 600, // 10 minutes from now
      messages: [
        {
          address: this.address.toString(),
          amount: '0',
          payload: stateUpdateCell.toBoc().toString('base64'),
        },
      ],
    };

    try {
      const result = await contract.sendTransaction(transaction);
      console.log('Channel update submitted successfully:', result);
    } catch (error) {
      console.error('Error submitting channel update:', error);
      throw error;
    }
  }
}

export default WalletContract;

--------------------------------------------------------------------------------

Index: 195
File: /Users/cryptskii/client/src/blueprint/ChannelError.ts

// ./blueprint/ChannelError.ts
export class ChannelError extends Error {
    constructor(message: string, public readonly details?: any) {
        super(message)
        this.name = 'ChannelError'
    }
}
    
--------------------------------------------------------------------------------

Index: 196
File: /Users/cryptskii/client/src/blueprint/ChannelState.ts

  import { Address, Cell, beginCell } from '@ton/core'
  import { Buffer } from 'buffer'
  import { ChannelStateUpdate } from './ChannelStateUpdate'
  import CryptoJS from 'crypto-js'

  export interface IPartialChannelState {
    ownerAddress?: Address
    seqno?: number
    nonce?: number
    currentTime?: number
    balance?: bigint
    channelId?: string
    merkleRoot?: Uint8Array
    status?: string
  }

  export class ChannelState implements IPartialChannelState {
    [x: string]: any
    isValid() {
      throw new Error('Method not implemented.')
    }
    update(updatedState: { ownerAddress: Address; seqno: number; nonce: number; currentTime: number; balance: bigint; channelId: string; merkleRoot: Uint8Array; status: string; write?: (() => Buffer) | undefined; toCell?: (() => Cell) | undefined; verifyMerkleRoot?: ((fieldElements: bigint[], merkleProof: Uint8Array, merkleRootValue: bigint) => boolean) | undefined; toUpdate?: (() => ChannelStateUpdate) | undefined }) {
      // Use updatedState to update the current state
      this.ownerAddress = updatedState.ownerAddress;
      this.seqno = updatedState.seqno;
      this.nonce = updatedState.nonce;
      this.currentTime = updatedState.currentTime;
      this.balance = updatedState.balance;
      this.channelId = updatedState.channelId;
      this.merkleRoot = updatedState.merkleRoot;
      this.status = updatedState.status;
    }
    close() {
      this.status = 'closed';
    }
    toJSON() {
      return {
        ownerAddress: this.ownerAddress.toString(),
        seqno: this.seqno,
        nonce: this.nonce,
        currentTime: this.currentTime,
        balance: this.balance.toString(),
        channelId: this.channelId,
        merkleRoot: Buffer.from(this.merkleRoot).toString('hex'),
        status: this.status
      };
    }
    constructor(
      public ownerAddress: Address,
      public seqno: number,
      public nonce: number,
      public currentTime: number,
      public balance: bigint,
      public channelId: string,
      public merkleRoot: Uint8Array,
      public status: string = 'open'
    ) {}

    static create(
      ownerAddress: Address,
      seqno: number,
      nonce: number,
      currentTime: number,
      balance: bigint,
      channelId: string,
      merkleRoot: Uint8Array
    ): ChannelState {
      return new ChannelState(ownerAddress, seqno, nonce, currentTime, balance, channelId, merkleRoot)
    }

    static fromPartial(partialState: IPartialChannelState): ChannelState {
      return new ChannelState(
        partialState.ownerAddress || Address.parse(''),
        partialState.seqno || 0,
        partialState.nonce || 0,
        partialState.currentTime || 0,
        partialState.balance || BigInt(0),
        partialState.channelId || '',
        partialState.merkleRoot || new Uint8Array(32), // Provide fixed length for consistency
        partialState.status || 'open'
      )
    }

    static fromCell(cell: Cell): ChannelState {
      const slice = cell.beginParse()
      const ownerAddress = slice.loadAddress()!
      const seqno = slice.loadUint(32)
      const nonce = slice.loadUint(32)
      const currentTime = slice.loadUint(64)
      const balance = slice.loadCoins()
      const channelId = slice.loadBuffer(32).toString('hex')
      const merkleRoot = slice.loadBuffer(32)
      const status = slice.loadStringTail()

      return new ChannelState(
        ownerAddress,
        Number(seqno),
        Number(nonce),
        Number(currentTime),
        balance,
        channelId,
        new Uint8Array(merkleRoot),
        status
      )
    }

    write(): Buffer {
      const cell = this.toCell()
      return cell.toBoc()
    }

    toCell(): Cell {
      return beginCell()
        .storeAddress(this.ownerAddress)
        .storeUint(this.seqno, 32) // Store as `number`
        .storeUint(this.nonce, 32) // Store as `number`
        .storeUint(this.currentTime, 64) // Store as `number`
        .storeCoins(this.balance) // Store as `bigint`
        .storeBuffer(Buffer.from(this.channelId, 'hex'))
        .storeBuffer(Buffer.from(this.merkleRoot))
        .storeStringTail(this.status)
        .endCell()
    }

    verifyMerkleRoot(
      fieldElements: bigint[],
      merkleProof: Uint8Array,
      merkleRootValue: bigint
    ): boolean {
      if (fieldElements.length === 0) {
        return false
      }

      let computedHash = fieldElements[0]
      let proofIndex = 0

      for (let i = 0; i < merkleProof.length; i += 32) {
        if (proofIndex >= fieldElements.length) {
          break
        }

        const proofElement = BigInt(`0x${Buffer.from(merkleProof.slice(i, i + 32)).toString('hex')}`)
        computedHash = this.hashPair(computedHash, proofElement)
        proofIndex++
      }

      return computedHash === merkleRootValue
    }

    private hashPair(a: bigint, b: bigint): bigint {
      const aBuffer = Buffer.alloc(32)
      const bBuffer = Buffer.alloc(32)

      // Split `bigint` into chunks and write them to buffers for hashing
      aBuffer.writeBigUInt64BE(a & BigInt('0xFFFFFFFFFFFFFFFF'), 24)
      aBuffer.writeBigUInt64BE((a >> BigInt(64)) & BigInt('0xFFFFFFFFFFFFFFFF'), 16)
      aBuffer.writeBigUInt64BE((a >> BigInt(128)) & BigInt('0xFFFFFFFFFFFFFFFF'), 8)
      aBuffer.writeBigUInt64BE((a >> BigInt(192)) & BigInt('0xFFFFFFFFFFFFFFFF'), 0)

      bBuffer.writeBigUInt64BE(b & BigInt('0xFFFFFFFFFFFFFFFF'), 24)
      bBuffer.writeBigUInt64BE((b >> BigInt(64)) & BigInt('0xFFFFFFFFFFFFFFFF'), 16)
      bBuffer.writeBigUInt64BE((b >> BigInt(128)) & BigInt('0xFFFFFFFFFFFFFFFF'), 8)
      bBuffer.writeBigUInt64BE((b >> BigInt(192)) & BigInt('0xFFFFFFFFFFFFFFFF'), 0)

      const combinedBuffer = Buffer.concat([aBuffer, bBuffer])
      const wordArray = CryptoJS.lib.WordArray.create(combinedBuffer)
      const hash = CryptoJS.SHA256(wordArray)

      return BigInt(`0x${hash.toString(CryptoJS.enc.Hex)}`)
    }

    toUpdate(): ChannelStateUpdate {
      return new ChannelStateUpdate(
        this.channelId,
        this.balance,
        this.nonce,
        this.merkleRoot,
        this.seqno,
        this.currentTime
      )
    }
  }

--------------------------------------------------------------------------------

Index: 197
File: /Users/cryptskii/client/src/blueprint/ChannelConfig.ts

// ./src/blueprint/ChannelConfig.ts
import { ChannelError } from './ChannelError'
import { Channel } from './Channel'
import { Address } from '@ton/core'

export interface ChannelConfig {
    [x: string]: any

    load(channelAddress: Address): Promise<void>
    clear(): void

    JSON(): Record<string, unknown>
    name: string
    channel: Channel
    onError?: (error: ChannelError) => void

    implement(channelAddress: Address): Promise<Channel>
}



--------------------------------------------------------------------------------

Index: 198
File: /Users/cryptskii/client/src/blueprint/OverpassChannels.ts

import { beginCell, Cell, Address } from '@ton/core'
import { Contract, TonClient, Sender, SenderArguments } from '@ton/ton' // Ensure Contract is imported from the correct module
import { EventEmitter } from 'events'
import { ChannelState } from './ChannelState'
import * as wasm from '../wasm/wasm_binding_p2'

export interface IPartialChannelState extends Partial<ChannelState> {
  write?: () => Buffer
  verifyMerkleRoot?: () => boolean
  toCell?: () => Cell
}

export class OverpassChannels extends EventEmitter {
  static CONTRACT_ADDRESS: string = process.env.TON_CONTRACT_ADDRESS || '0xYourContractAddressHere'

  private tonClient: TonClient
  tonContract: Contract // This is correct now as Contract is imported from the correct module

  constructor(tonClient: TonClient, tonContractAddress: string) {
    super()
    this.tonClient = tonClient
    this.tonContract = this.tonClient.open({ address: Address.parse(tonContractAddress) }) // Use the correct method to "open" a contract.
  }

  async getAccountState(tonContract: Contract): Promise<any> {
    try {
      const state = await this.tonClient.getContractState(tonContract.address)
      return state
    } catch (error) {
      console.error('Error getting account state:', error)
      throw new Error('Failed to get account state')
    }
  }

  async getChannelState(tonContract: Contract): Promise<ChannelState> {
    try {
      const contractState = await this.tonClient.getContractState(tonContract.address)
      if (contractState.state === 'active' && contractState.data) {
        return await wasm.deserializeChannelState(contractState.data)
      }
      throw new Error('Contract state is not active or data is missing')
    } catch (error) {
      console.error('Error getting channel state:', error)
      throw new Error('Failed to get channel state')
    }
  }

  async getChannelAddress(): Promise<string> {
    const channelAddress = process.env.TON_CHANNEL_ADDRESS || ''
    return channelAddress
  }

  async createChannel(tonContract: Contract, channelName: string, capacity: number): Promise<any> {
    const messageBody = beginCell()
      .storeUint(0, 32)
      .storeBuffer(Buffer.from(channelName))
      .storeUint(capacity, 32)
      .endCell()

    try {
      const sender = this.tonClient.open(tonContract) as Sender
      const senderArgs: SenderArguments = {
        to: tonContract.address,
        value: BigInt(0),
        body: messageBody,
      }
      const result = await sender.send(senderArgs)

      const transactionHash = (result as any)?.transactionHash || 'unknown'
      const newState: IPartialChannelState = {
        ownerAddress: Address.parse(tonContract.address.toString()),
        channelId: '0',
        balance: BigInt(0),
        nonce: 0,
        merkleRoot: new Uint8Array(32).fill(0),
        seqno: 0,
        currentTime: 0,
      }
      this.emit('channelCreated', {
        channelName,
        capacity,
        state: newState as unknown as ChannelState,
        transactionHash,
      })

      return result
    } catch (error) {
      console.error('Error creating channel:', error)
      throw new Error('Failed to create channel')
    }
  }

  async updateChannelState(
    tonContract: Contract,
    newState: ChannelState,
    signature: Uint8Array
  ): Promise<void> {
    try {
      const serializedState = await wasm.serializeChannelState(newState)
      const fieldElements = await wasm.convertBocToFieldElements(serializedState)
      const merkleProof = await wasm.generateMerkleProof(fieldElements)

      const merkleProofBuffer = serializeMerkleProof(merkleProof)

      const messageBody = beginCell()
        .storeUint(1, 32)
        .storeBuffer(Buffer.from(serializedState))
        .storeBuffer(Buffer.from(signature))
        .storeBuffer(Buffer.from(merkleProofBuffer))
        .endCell()

      const sender = this.tonClient.open(tonContract) as Sender
      const senderArgs: SenderArguments = {
        to: tonContract.address,
        value: BigInt(0),
        body: messageBody,
      }
      await sender.send(senderArgs)
    } catch (error) {
      console.error('Error updating channel state:', error)
      throw new Error('Failed to update channel state')
    }
  }

  async verifyChannelState(
    _tonContract: Contract,
    state: ChannelState,
    merkleProofBuffer: Uint8Array
  ): Promise<boolean> {
    try {
      const serializedState = await wasm.serializeChannelState(state)
      const fieldElements = await wasm.convertBocToFieldElements(serializedState)

      const merkleProof = deserializeMerkleProof(merkleProofBuffer)

      return await wasm.verifyMerkleProof(fieldElements, merkleProof, state.merkleRoot)
    } catch (error) {
      console.error('Error verifying channel state:', error)
      throw new Error('Failed to verify channel state')
    }
  }
}

// Helper functions to serialize and deserialize MerkleProof
interface MerkleProof {
  siblings: Uint8Array[]
  path: number[]
}

function serializeMerkleProof(merkleProof: MerkleProof): Uint8Array {
  const siblingsLength = merkleProof.siblings.length
  const pathLength = merkleProof.path.length
  const bufferArray: number[] = []

  bufferArray.push(siblingsLength)
  merkleProof.siblings.forEach((sibling) => {
    bufferArray.push(sibling.length)
    bufferArray.push(...sibling)
  })

  bufferArray.push(pathLength)
  merkleProof.path.forEach((p) => {
    bufferArray.push(p)
  })

  return Uint8Array.from(bufferArray)
}

function deserializeMerkleProof(buffer: Uint8Array): MerkleProof {
  let offset = 0
  const siblingsLength = buffer[offset++]
  const siblings: Uint8Array[] = []

  for (let i = 0; i < siblingsLength; i++) {
    const siblingLength = buffer[offset++]
    const sibling = buffer.slice(offset, offset + siblingLength)
    siblings.push(sibling)
    offset += siblingLength
  }

  const pathLength = buffer[offset++]
  const path: number[] = []
  for (let i = 0; i < pathLength; i++) {
    path.push(buffer[offset++])
  }

  return { siblings, path }
}

--------------------------------------------------------------------------------

Index: 199
File: /Users/cryptskii/client/src/blueprint/Channel.ts

import { ChannelState } from './ChannelState'
import { ChannelConfig } from './ChannelConfig'
import { ChannelError } from './ChannelError'
import { Address } from './types'

export class Channel {
  private config: ChannelConfig
  private channelState: ChannelState
  private channelAddress: Address

  constructor(config: ChannelConfig, channelAddress: Address) {
    this.config = config;
    this.channelAddress = channelAddress;
    this.channelState = new ChannelState(
      channelAddress,
      config.ownerAddress,
      BigInt(0),
      0,
      0,
      BigInt(0),
      'open',
      new Uint8Array(32)
    );
  }

  public async update(newState: Partial<ChannelState>): Promise<void> {
    const updatedState = new ChannelState(
      this.channelState.channelAddress,
      this.channelState.ownerAddress,
      newState.balance ?? this.channelState.balance,
      newState.nonce ?? this.channelState.nonce,
      newState.seqno ?? this.channelState.seqno,
      newState.currentTime ?? this.channelState.currentTime,
      newState.status ?? this.channelState.status,
      newState.merkleRoot ?? this.channelState.merkleRoot
    )

    if (!this.isValidStateTransition(updatedState)) {
      throw new ChannelError('Invalid state transition')
    }
    this.channelState = updatedState
    try {
      await this.config.channel.update(this.channelAddress, updatedState)
    } catch (error) {
      throw new ChannelError('Failed to update channel state', { cause: error })
    }
  }

  private isValidStateTransition(updatedState: ChannelState): boolean {
    if (JSON.stringify(updatedState) === JSON.stringify(this.channelState)) {
      return false
    }

    if (updatedState.balance < BigInt(0) || updatedState.balance < this.channelState.balance) {
      return false
    }

    if (updatedState.seqno <= this.channelState.seqno) {
      return false
    }

    if (!this.isValidStatusTransition(this.channelState.status, updatedState.status)) {
      return false
    }

    return true
  }

  private isValidStatusTransition(currentStatus: string, newStatus: string): boolean {
    const validTransitions: { [key: string]: string[] } = {
      'open': ['closed', 'disputed'],
      'closed': [],
      'disputed': ['closed'],
    }

    return validTransitions[currentStatus]?.includes(newStatus) ?? false
  }
}
--------------------------------------------------------------------------------

Index: 200
File: /Users/cryptskii/client/src/blueprint/merkle-wasm.ts

import { beginCell, Cell, Address } from '@ton/core'
import { Contract, TonClient, ContractProvider } from '@ton/ton'
import { EventEmitter } from 'events'
import { ChannelState } from './ChannelState'
import * as wasm from '../wasm/wasm_binding_p2'

export interface IPartialChannelState extends Partial<ChannelState> {
  write?: () => Buffer
  verifyMerkleRoot?: () => boolean
  toCell?: () => Cell
}

export class OverpassChannels extends EventEmitter {
  static CONTRACT_ADDRESS: string = process.env.TON_CONTRACT_ADDRESS || '0xYourContractAddressHere'

  private tonClient: TonClient

  constructor(tonClient: TonClient) {
    super()
    this.tonClient = tonClient
  }

  async getAccountState(tonContract: Contract): Promise<any> {
    try {
      const state = await this.tonClient.getContractState(tonContract.address)
      return state
    } catch (error) {
      console.error('Error getting account state:', error)
      throw new Error('Failed to get account state')
    }
  }

  async getChannelState(tonContract: Contract): Promise<ChannelState> {
    try {
      const contractState = await this.tonClient.getContractState(tonContract.address)
      if (contractState.state === 'active' && contractState.data) {
        return await wasm.deserializeChannelState(contractState.data)
      }
      throw new Error('Contract state is not active or data is missing')
    } catch (error) {
      console.error('Error getting channel state:', error)
      throw new Error('Failed to get channel state')
    }
  }

  async getChannelAddress(): Promise<string> {
    const channelAddress = process.env.TON_CHANNEL_ADDRESS || ''
    return channelAddress
  }

  async createChannel(tonContract: Contract, channelName: string, capacity: number): Promise<any> {
    const messageBody = beginCell()
      .storeUint(0, 32)
      .storeBuffer(Buffer.from(channelName))
      .storeUint(capacity, 32)
      .endCell()

    try {
      const provider = this.tonClient.open(tonContract) as unknown as ContractProvider
      const result = await provider.external(messageBody)

      const transactionHash = (result as any)?.transactionHash || 'unknown'
      const newState: IPartialChannelState = {
        ownerAddress: Address.parse(tonContract.address.toString()),
        channelId: '0',
        balance: BigInt(0),
        nonce: 0,
        merkleRoot: new Uint8Array(32).fill(0),
        seqno: 0,
        currentTime: 0,
      }
      this.emit('channelCreated', {
        channelName,
        capacity,
        state: newState as unknown as ChannelState,
        transactionHash,
      })

      return result
    } catch (error) {
      console.error('Error creating channel:', error)
      throw new Error('Failed to create channel')
    }
  }

  async updateChannelState(
    tonContract: Contract,
    newState: ChannelState,
    signature: Uint8Array
  ): Promise<void> {
    try {
      const serializedState = await wasm.serializeChannelState(newState)
      const fieldElements = await wasm.convertBocToFieldElements(serializedState)
      const merkleProof = await wasm.generateMerkleProof(fieldElements)

      // Serialize merkleProof to Uint8Array
      const merkleProofBuffer = serializeMerkleProof(merkleProof)

      const messageBody = beginCell()
        .storeUint(1, 32)
        .storeBuffer(Buffer.from(serializedState))
        .storeBuffer(Buffer.from(signature))
        .storeBuffer(Buffer.from(merkleProofBuffer))
        .endCell()

      const provider = this.tonClient.open(tonContract) as unknown as ContractProvider
      await provider.external(messageBody)
    } catch (error) {
      console.error('Error updating channel state:', error)
      throw new Error('Failed to update channel state')
    }
  }

  async verifyChannelState(
    _tonContract: Contract,
    state: ChannelState,
    merkleProofBuffer: Uint8Array
  ): Promise<boolean> {
    try {
      const serializedState = await wasm.serializeChannelState(state)
      const fieldElements = await wasm.convertBocToFieldElements(serializedState)

      const merkleProof = deserializeMerkleProof(merkleProofBuffer)

      return await wasm.verifyMerkleProof(fieldElements, merkleProof, state.merkleRoot)
    } catch (error) {
      console.error('Error verifying channel state:', error)
      throw new Error('Failed to verify channel state')
    }
  }
}

// Helper functions to serialize and deserialize MerkleProof
interface MerkleProof {
  siblings: Uint8Array[]
  path: number[]
}

function serializeMerkleProof(merkleProof: MerkleProof): Uint8Array {
  const siblingsLength = merkleProof.siblings.length
  const pathLength = merkleProof.path.length
  const bufferArray: number[] = []

  bufferArray.push(siblingsLength)
  merkleProof.siblings.forEach((sibling) => {
    bufferArray.push(sibling.length)
    bufferArray.push(...sibling)
  })

  bufferArray.push(pathLength)
  merkleProof.path.forEach((p) => {
    bufferArray.push(p)
  })

  return Uint8Array.from(bufferArray)
}

function deserializeMerkleProof(buffer: Uint8Array): MerkleProof {
  let offset = 0
  const siblingsLength = buffer[offset++]
  const siblings: Uint8Array[] = []

  for (let i = 0; i < siblingsLength; i++) {
    const siblingLength = buffer[offset++]
    const sibling = buffer.slice(offset, offset + siblingLength)
    siblings.push(sibling)
    offset += siblingLength
  }

  const pathLength = buffer[offset++]
  const path: number[] = []
  for (let i = 0; i < pathLength; i++) {
    path.push(buffer[offset++])
  }

  return { siblings, path }
}

--------------------------------------------------------------------------------

Index: 201
File: /Users/cryptskii/client/src/blueprint/Merkle.ts

import { Address, Cell, TonClient, ContractProvider, TupleReader } from '@ton/ton'

export class MerkleProof {
  constructor(
    public siblings: Cell[],
    public path: number[]
  ) {}
}

export class Merkle {
  generateRoot(initialState: { data: string }) {
    throw new Error("Method not implemented.")
  }
  private provider: ContractProvider

  constructor(client: TonClient, address: Address) {
    this.provider = client.provider(address)
  }

  async init(): Promise<void> {
    // Initialize contract if needed
  }

  async addValue(): Promise<void> {
    // Implementation for adding a value to the Merkle tree
  }

  async updateValue(): Promise<void> {
    // Implementation for updating a value in the Merkle tree
  }

  async getMerkleValue(index: number): Promise<Cell> {
    try {
      const result = await this.provider.get('get_merkle_value', [
        { type: 'int', value: BigInt(index) },
      ])
      return result.stack.readCell()
    } catch (error) {
      console.error('Failed to get Merkle value:', error)
      throw error
    }
  }

  async getMerkleProof(index: number): Promise<MerkleProof> {
    try {
      const result = await this.provider.get('get_merkle_proof', [
        { type: 'int', value: BigInt(index) },
      ])

      const siblings: Cell[] = []
      const path: number[] = []

      // Assuming the result has a list of siblings and a list of path values in the stack.
      const tupleReader: TupleReader = result.stack

      // Example assumption: first value is list of siblings (cells), second is list of path indexes (integers)
      const siblingsReader = tupleReader.readTuple() // Reading the tuple that holds the siblings
      while (siblingsReader.remaining > 0) {
        siblings.push(siblingsReader.readCell())
      }

      const pathReader = tupleReader.readTuple() // Reading the tuple that holds the path
      while (pathReader.remaining > 0) {
        path.push(Number(pathReader.readBigNumber())) // Convert to `number`
      }

      return new MerkleProof(siblings, path)
    } catch (error) {
      console.error('Failed to get Merkle proof:', error)
      throw error
    }
  }

  async getMerkleRoot(): Promise<Cell> {
    try {
      const result = await this.provider.get('get_merkle_root', [])
      return result.stack.readCell()
    } catch (error) {
      console.error('Failed to get Merkle root:', error)
      throw error
    }
  }
}

--------------------------------------------------------------------------------

Index: 202
File: /Users/cryptskii/client/src/blueprint/ChannelStateUpdate.ts

// ./src/blueprint/ChannelStateUpdate.ts

import { MessageRelaxed, Cell, Address } from '@ton/core'

export class ChannelStateUpdate {
  constructor(
    public readonly channelId: string,
    public readonly balance: bigint,
    public readonly nonce: number,
    public readonly merkleRoot: Uint8Array,
    public readonly seqno: number,
    public readonly currentTime: number
  ) {}

  static create(
    channelId: string,
    balance: bigint,
    nonce: number,
    merkleRoot: Uint8Array,
    seqno: number,
    currentTime: number
  ): ChannelStateUpdate {
    return new ChannelStateUpdate(channelId, balance, nonce, merkleRoot, seqno, currentTime)
  }

  toMessageRelaxed(): MessageRelaxed {
    return {
      info: {
        type: 'internal',
        src: Address.parse('EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c'),
        dest: Address.parse('EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c'),
        value: { coins: 0n },
        ihrDisabled: true,
        bounce: false,
        bounced: false,
        createdLt: 0n,
        createdAt: 0,
        ihrFee: 0n,
        forwardFee: 0n,
      },
      body: Cell.fromBoc(
        Buffer.from(
          JSON.stringify({
            seqno: this.seqno,
            channelId: this.channelId,
            balance: this.balance.toString(),
            nonce: this.nonce,
            merkleRoot: Buffer.from(this.merkleRoot).toString('hex'),
            currentTime: this.currentTime,
          })
        )
      )[0],
    }
  }
}

// Example usage
const exampleUpdate = ChannelStateUpdate.create(
  '1234567890',
  100n,
  0,
  new Uint8Array(32),
  1,
  Date.now()
)

console.log(exampleUpdate.toMessageRelaxed())

--------------------------------------------------------------------------------

Index: 203
File: /Users/cryptskii/client/src/blueprint/GlobalRoot.ts

import { Address, Cell, TonClient } from '@ton/ton'
import { TonConnect } from '@tonconnect/sdk'

export class GlobalRootContract {
  address: Address
  constructor(private client: TonClient) {
    this.address = Address.parse(
      'EQD1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef'
    )
  }
  async getContract(): Promise<TonConnect> {
    return new TonConnect({ manifestUrl: 'https://example.com/tonconnect-manifest.json' })
  }
  async getGlobalRootState(globalRootAddress: Address): Promise<Cell> {
    const globalRootState = await this.client.callGetMethod(
      globalRootAddress,
      'get_global_root_state',
      []
    )
    return globalRootState.stack.readCell()
  }
}

--------------------------------------------------------------------------------

Index: 204
File: /Users/cryptskii/client/src/analytics/analytics.ts

// ./src/analytics/analytics.ts
import Analytics from '@vercel/analytics'

export function logPageView(pageName: string): void {
  try {
    Analytics.track('Page View', { pageName })
  } catch (error) {
    console.error('Failed to log page view:', error)
    // Optionally, you can call logError here to track the error
    logError(error as Error, { context: 'logPageView', pageName })
  }
}

export function logEvent(eventName: string, eventProperties?: Record<string, any>): void {
  try {
    Analytics.track(eventName, eventProperties)
  } catch (error) {
    console.error('Failed to log event:', error)
    logError(error as Error, { context: 'logEvent', eventName, ...eventProperties })
  }
}

export function logError(error: Error, eventProperties?: Record<string, any>): void {
  try {
    const errorEventProperties = {
      ...eventProperties,
      error: error.message,
      stack: error.stack || '',
    }
    Analytics.track('error', errorEventProperties)
  } catch (trackError) {
    console.error('Failed to log error:', trackError)
    // As a fallback, log to console
    console.error('Original error:', error)
    console.error('Error properties:', eventProperties)
  }
}

export function initializeAnalytics(): void {
  try {
    Analytics.inject()
    console.log('Analytics initialized successfully')
  } catch (error) {
    console.error('Failed to initialize analytics:', error)
  }
}

export default {
  logPageView,
  logEvent,
  logError,
  initializeAnalytics,
}

--------------------------------------------------------------------------------

Index: 205
File: /Users/cryptskii/client/src/store/wallet.ts

import { hookstate, useHookstate } from '@hookstate/core'

const WalletAddress = hookstate<string>(
  'EQD1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef'
)

export function useWalletAddress() {
  return useHookstate(WalletAddress)
}

export function setWalletAddress(newAddress: string) {
  WalletAddress.set(newAddress)
}

export function getWalletAddress() {
  return WalletAddress.get()
}

--------------------------------------------------------------------------------

Index: 206
File: /Users/cryptskii/client/src/store/tonClient.ts

import { hookstate, useHookstate } from '@hookstate/core'
import { Address, Cell } from '@ton/ton'
import { getHttpEndpoint } from '@orbs-network/ton-access'
import { TonClient } from '@ton/ton'

const TonConnection = hookstate<TonClient | null>(null)

getHttpEndpoint().then((endpoint) => {
  TonConnection.set(new TonClient({ endpoint }))
})

export function useTonClient() {
  return useHookstate(TonConnection).get()
}

const TonapiConnection = hookstate<TonClient>(getTonapi(false))

export function useTonapiClient() {
  return useHookstate(TonapiConnection).get()
}

export function setTonapiClient(newClient: TonClient) {
  TonapiConnection.set(newClient)
}

export { TonConnection }

export function getTonapi(isTestnet: boolean) {
  const mainnetRpc = 'https://mainnet.tonhubapi.com/jsonRPC'
  const testnetRpc = 'https://testnet.tonhubapi.com/jsonRPC'
  const endpoint = isTestnet ? testnetRpc : mainnetRpc

  // Initialize the TonClient instance
  const client = new TonClient({ endpoint })
  return client
}

// Additional exports for Address and Cell
export { Address, Cell }

// Utility function to create a new TonClient instance
export function createTonClient(endpoint: string): TonClient {
  return new TonClient({ endpoint })
}

// Utility function to create a new TonClient instance for Tonapi
export function createTonapiClient(isTestnet: boolean): TonClient {
  const mainnetRpc = 'https://mainnet.tonhubapi.com/jsonRPC'
  const testnetRpc = 'https://testnet.tonhubapi.com/jsonRPC'
  const endpoint = isTestnet ? testnetRpc : mainnetRpc
  const client = new TonClient({ endpoint })
  return client
}

--------------------------------------------------------------------------------

